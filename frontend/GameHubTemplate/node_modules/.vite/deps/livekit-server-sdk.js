import {
  __export
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@bufbuild/protobuf/dist/esm/private/assert.js
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}
var FLOAT32_MAX = 34028234663852886e22;
var FLOAT32_MIN = -34028234663852886e22;
var UINT32_MAX = 4294967295;
var INT32_MAX = 2147483647;
var INT32_MIN = -2147483648;
function assertInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid int 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int 32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid uint 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint 32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid float 32: " + typeof arg);
  if (!Number.isFinite(arg))
    return;
  if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
    throw new Error("invalid float 32: " + arg);
}

// node_modules/@bufbuild/protobuf/dist/esm/private/enum.js
var enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
function getEnumType(enumObject) {
  const t = enumObject[enumTypeSymbol];
  assert(t, "missing enum type on enum object");
  return t;
}
function setEnumType(enumObject, typeName, values, opt) {
  enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v) => ({
    no: v.no,
    name: v.name,
    localName: enumObject[v.no]
  })), opt);
}
function makeEnumType(typeName, values, _opt) {
  const names = /* @__PURE__ */ Object.create(null);
  const numbers = /* @__PURE__ */ Object.create(null);
  const normalValues = [];
  for (const value of values) {
    const n = normalizeEnumValue(value);
    normalValues.push(n);
    names[value.name] = n;
    numbers[value.no] = n;
  }
  return {
    typeName,
    values: normalValues,
    // We do not surface options at this time
    // options: opt?.options ?? Object.create(null),
    findName(name) {
      return names[name];
    },
    findNumber(no) {
      return numbers[no];
    }
  };
}
function makeEnum(typeName, values, opt) {
  const enumObject = {};
  for (const value of values) {
    const n = normalizeEnumValue(value);
    enumObject[n.localName] = n.no;
    enumObject[n.no] = n.localName;
  }
  setEnumType(enumObject, typeName, values, opt);
  return enumObject;
}
function normalizeEnumValue(value) {
  if ("localName" in value) {
    return value;
  }
  return Object.assign(Object.assign({}, value), { localName: value.name });
}

// node_modules/@bufbuild/protobuf/dist/esm/message.js
var Message = class {
  /**
   * Compare with a message of the same type.
   * Note that this function disregards extensions and unknown fields.
   */
  equals(other) {
    return this.getType().runtime.util.equals(this.getType(), this, other);
  }
  /**
   * Create a deep copy.
   */
  clone() {
    return this.getType().runtime.util.clone(this);
  }
  /**
   * Parse from binary data, merging fields.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  fromBinary(bytes, options) {
    const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);
    format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);
    return this;
  }
  /**
   * Parse a message from a JSON value.
   */
  fromJson(jsonValue, options) {
    const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);
    format.readMessage(type, jsonValue, opt, this);
    return this;
  }
  /**
   * Parse a message from a JSON string.
   */
  fromJsonString(jsonString, options) {
    let json;
    try {
      json = JSON.parse(jsonString);
    } catch (e) {
      throw new Error(`cannot decode ${this.getType().typeName} from JSON: ${e instanceof Error ? e.message : String(e)}`);
    }
    return this.fromJson(json, options);
  }
  /**
   * Serialize the message to binary data.
   */
  toBinary(options) {
    const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer = opt.writerFactory();
    bin.writeMessage(this, writer, opt);
    return writer.finish();
  }
  /**
   * Serialize the message to a JSON value, a JavaScript value that can be
   * passed to JSON.stringify().
   */
  toJson(options) {
    const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);
    return json.writeMessage(this, opt);
  }
  /**
   * Serialize the message to a JSON string.
   */
  toJsonString(options) {
    var _a2;
    const value = this.toJson(options);
    return JSON.stringify(value, null, (_a2 = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a2 !== void 0 ? _a2 : 0);
  }
  /**
   * Override for serialization behavior. This will be invoked when calling
   * JSON.stringify on this message (i.e. JSON.stringify(msg)).
   *
   * Note that this will not serialize google.protobuf.Any with a packed
   * message because the protobuf JSON format specifies that it needs to be
   * unpacked, and this is only possible with a type registry to look up the
   * message type.  As a result, attempting to serialize a message with this
   * type will throw an Error.
   *
   * This method is protected because you should not need to invoke it
   * directly -- instead use JSON.stringify or toJsonString for
   * stringified JSON.  Alternatively, if actual JSON is desired, you should
   * use toJson.
   */
  toJSON() {
    return this.toJson({
      emitDefaultValues: true
    });
  }
  /**
   * Retrieve the MessageType of this message - a singleton that represents
   * the protobuf message declaration and provides metadata for reflection-
   * based operations.
   */
  getType() {
    return Object.getPrototypeOf(this).constructor;
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/private/message-type.js
function makeMessageType(runtime, typeName, fields, opt) {
  var _a2;
  const localName2 = (_a2 = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a2 !== void 0 ? _a2 : typeName.substring(typeName.lastIndexOf(".") + 1);
  const type = {
    [localName2]: function(data) {
      runtime.util.initFields(this);
      runtime.util.initPartial(data, this);
    }
  }[localName2];
  Object.setPrototypeOf(type.prototype, new Message());
  Object.assign(type, {
    runtime,
    typeName,
    fields: runtime.util.newFieldList(fields),
    fromBinary(bytes, options) {
      return new type().fromBinary(bytes, options);
    },
    fromJson(jsonValue, options) {
      return new type().fromJson(jsonValue, options);
    },
    fromJsonString(jsonString, options) {
      return new type().fromJsonString(jsonString, options);
    },
    equals(a, b) {
      return runtime.util.equals(type, a, b);
    }
  });
  return type;
}

// node_modules/@bufbuild/protobuf/dist/esm/google/varint.js
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift = 0; shift < 28; shift += 7) {
    let b = this.buf[this.pos++];
    lowBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift = 3; shift <= 31; shift += 7) {
    let b = this.buf[this.pos++];
    highBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo, hi, bytes) {
  for (let i = 0; i < 28; i = i + 7) {
    const shift = lo >>> i;
    const hasNext = !(shift >>> 7 == 0 && hi == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
  const hasMoreBits = !(hi >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i = 3; i < 31; i = i + 7) {
    const shift = hi >>> i;
    const hasNext = !(shift >>> 7 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi >>> 31 & 1);
}
var TWO_PWR_32_DBL = 4294967296;
function int64FromString(dec) {
  const minus = dec[0] === "-";
  if (minus) {
    dec = dec.slice(1);
  }
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end) {
    const digit1e6 = Number(dec.slice(begin, end));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
      lowBits = lowBits % TWO_PWR_32_DBL;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
}
function int64ToString(lo, hi) {
  let bits = newBits(lo, hi);
  const negative = bits.hi & 2147483648;
  if (negative) {
    bits = negate(bits.lo, bits.hi);
  }
  const result = uInt64ToString(bits.lo, bits.hi);
  return negative ? "-" + result : result;
}
function uInt64ToString(lo, hi) {
  ({ lo, hi } = toUnsigned(lo, hi));
  if (hi <= 2097151) {
    return String(TWO_PWR_32_DBL * hi + lo);
  }
  const low = lo & 16777215;
  const mid = (lo >>> 24 | hi << 8) & 16777215;
  const high = hi >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  const base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
}
function toUnsigned(lo, hi) {
  return { lo: lo >>> 0, hi: hi >>> 0 };
}
function newBits(lo, hi) {
  return { lo: lo | 0, hi: hi | 0 };
}
function negate(lowBits, highBits) {
  highBits = ~highBits;
  if (lowBits) {
    lowBits = ~lowBits + 1;
  } else {
    highBits += 1;
  }
  return newBits(lowBits, highBits);
}
var decimalFrom1e7WithLeadingZeros = (digit1e7) => {
  const partial = String(digit1e7);
  return "0000000".slice(partial.length) + partial;
};
function varint32write(value, bytes) {
  if (value >= 0) {
    while (value > 127) {
      bytes.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes.push(value);
  } else {
    for (let i = 0; i < 9; i++) {
      bytes.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes.push(1);
  }
}
function varint32read() {
  let b = this.buf[this.pos++];
  let result = b & 127;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 7;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 14;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 21;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 15) << 28;
  for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
    b = this.buf[this.pos++];
  if ((b & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}

// node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js
function makeInt64Support() {
  const dv = new DataView(new ArrayBuffer(8));
  const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
  if (ok) {
    const MIN = BigInt("-9223372036854775808"), MAX = BigInt("9223372036854775807"), UMIN = BigInt("0"), UMAX = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: true,
      parse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > MAX || bi < MIN) {
          throw new Error(`int64 invalid: ${value}`);
        }
        return bi;
      },
      uParse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > UMAX || bi < UMIN) {
          throw new Error(`uint64 invalid: ${value}`);
        }
        return bi;
      },
      enc(value) {
        dv.setBigInt64(0, this.parse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      uEnc(value) {
        dv.setBigInt64(0, this.uParse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      dec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigInt64(0, true);
      },
      uDec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigUint64(0, true);
      }
    };
  }
  const assertInt64String = (value) => assert(/^-?[0-9]+$/.test(value), `int64 invalid: ${value}`);
  const assertUInt64String = (value) => assert(/^[0-9]+$/.test(value), `uint64 invalid: ${value}`);
  return {
    zero: "0",
    supported: false,
    parse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return value;
    },
    uParse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return value;
    },
    enc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return int64FromString(value);
    },
    uEnc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return int64FromString(value);
    },
    dec(lo, hi) {
      return int64ToString(lo, hi);
    },
    uDec(lo, hi) {
      return uInt64ToString(lo, hi);
    }
  };
}
var protoInt64 = makeInt64Support();

// node_modules/@bufbuild/protobuf/dist/esm/scalar.js
var ScalarType;
(function(ScalarType2) {
  ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
  ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
  ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
  ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
  ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
  ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
  ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
  ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
  ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
  ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
  ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
  ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
  ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
  ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
  ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
var LongType;
(function(LongType2) {
  LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
  LongType2[LongType2["STRING"] = 1] = "STRING";
})(LongType || (LongType = {}));

// node_modules/@bufbuild/protobuf/dist/esm/private/scalars.js
function scalarEquals(type, a, b) {
  if (a === b) {
    return true;
  }
  if (type == ScalarType.BYTES) {
    if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  switch (type) {
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return a == b;
  }
  return false;
}
function scalarZeroValue(type, longType) {
  switch (type) {
    case ScalarType.BOOL:
      return false;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return longType == 0 ? protoInt64.zero : "0";
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    case ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}
function isScalarZeroValue(type, value) {
  switch (type) {
    case ScalarType.BOOL:
      return value === false;
    case ScalarType.STRING:
      return value === "";
    case ScalarType.BYTES:
      return value instanceof Uint8Array && !value.byteLength;
    default:
      return value == 0;
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/binary-encoding.js
var WireType;
(function(WireType2) {
  WireType2[WireType2["Varint"] = 0] = "Varint";
  WireType2[WireType2["Bit64"] = 1] = "Bit64";
  WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
  WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
  WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
  WireType2[WireType2["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));
var BinaryWriter = class {
  constructor(textEncoder) {
    this.stack = [];
    this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
    this.chunks = [];
    this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let len = 0;
    for (let i = 0; i < this.chunks.length; i++)
      len += this.chunks[i].length;
    let bytes = new Uint8Array(len);
    let offset = 0;
    for (let i = 0; i < this.chunks.length; i++) {
      bytes.set(this.chunks[i], offset);
      offset += this.chunks[i].length;
    }
    this.chunks = [];
    return bytes;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    this.stack.push({ chunks: this.chunks, buf: this.buf });
    this.chunks = [];
    this.buf = [];
    return this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let chunk = this.finish();
    let prev = this.stack.pop();
    if (!prev)
      throw new Error("invalid state, fork stack empty");
    this.chunks = prev.chunks;
    this.buf = prev.buf;
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(fieldNo, type) {
    return this.uint32((fieldNo << 3 | type) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(chunk) {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    this.chunks.push(chunk);
    return this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(value) {
    assertUInt32(value);
    while (value > 127) {
      this.buf.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buf.push(value);
    return this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(value) {
    assertInt32(value);
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(value) {
    this.buf.push(value ? 1 : 0);
    return this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(value) {
    this.uint32(value.byteLength);
    return this.raw(value);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(value) {
    let chunk = this.textEncoder.encode(value);
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(value) {
    assertFloat32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setFloat32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(value) {
    let chunk = new Uint8Array(8);
    new DataView(chunk.buffer).setFloat64(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(value) {
    assertUInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setUint32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(value) {
    assertInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setInt32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(value) {
    assertInt32(value);
    value = (value << 1 ^ value >> 31) >>> 0;
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(value) {
    let tc = protoInt64.enc(value);
    varint64write(tc.lo, tc.hi, this.buf);
    return this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(value) {
    let tc = protoInt64.enc(value), sign2 = tc.hi >> 31, lo = tc.lo << 1 ^ sign2, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign2;
    varint64write(lo, hi, this.buf);
    return this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(value) {
    let tc = protoInt64.uEnc(value);
    varint64write(tc.lo, tc.hi, this.buf);
    return this;
  }
};
var BinaryReader = class {
  constructor(buf, textDecoder) {
    this.varint64 = varint64read;
    this.uint32 = varint32read;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let tag2 = this.uint32(), fieldNo = tag2 >>> 3, wireType = tag2 & 7;
    if (fieldNo <= 0 || wireType < 0 || wireType > 5)
      throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
    return [fieldNo, wireType];
  }
  /**
   * Skip one element and return the skipped data.
   *
   * When skipping StartGroup, provide the tags field number to check for
   * matching field number in the EndGroup tag.
   */
  skip(wireType, fieldNo) {
    let start = this.pos;
    switch (wireType) {
      case WireType.Varint:
        while (this.buf[this.pos++] & 128) {
        }
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let len = this.uint32();
        this.pos += len;
        break;
      case WireType.StartGroup:
        for (; ; ) {
          const [fn, wt] = this.tag();
          if (wt === WireType.EndGroup) {
            if (fieldNo !== void 0 && fn !== fieldNo) {
              throw new Error("invalid end group tag");
            }
            break;
          }
          this.skip(wt, fn);
        }
        break;
      default:
        throw new Error("cant skip wire type " + wireType);
    }
    this.assertBounds();
    return this.buf.subarray(start, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let zze = this.uint32();
    return zze >>> 1 ^ -(zze & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return protoInt64.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return protoInt64.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [lo, hi] = this.varint64();
    let s = -(lo & 1);
    lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
    hi = hi >>> 1 ^ s;
    return protoInt64.dec(lo, hi);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [lo, hi] = this.varint64();
    return lo !== 0 || hi !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return protoInt64.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return protoInt64.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let len = this.uint32(), start = this.pos;
    this.pos += len;
    this.assertBounds();
    return this.buf.subarray(start, start + len);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.textDecoder.decode(this.bytes());
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/private/extensions.js
function makeExtension(runtime, typeName, extendee, field) {
  let fi;
  return {
    typeName,
    extendee,
    get field() {
      if (!fi) {
        const i = typeof field == "function" ? field() : field;
        i.name = typeName.split(".").pop();
        i.jsonName = `[${typeName}]`;
        fi = runtime.util.newFieldList([i]).list()[0];
      }
      return fi;
    },
    runtime
  };
}
function createExtensionContainer(extension) {
  const localName2 = extension.field.localName;
  const container = /* @__PURE__ */ Object.create(null);
  container[localName2] = initExtensionField(extension);
  return [container, () => container[localName2]];
}
function initExtensionField(ext) {
  const field = ext.field;
  if (field.repeated) {
    return [];
  }
  if (field.default !== void 0) {
    return field.default;
  }
  switch (field.kind) {
    case "enum":
      return field.T.values[0].no;
    case "scalar":
      return scalarZeroValue(field.T, field.L);
    case "message":
      const T = field.T, value = new T();
      return T.fieldWrapper ? T.fieldWrapper.unwrapField(value) : value;
    case "map":
      throw "map fields are not allowed to be extensions";
  }
}
function filterUnknownFields(unknownFields, field) {
  if (!field.repeated && (field.kind == "enum" || field.kind == "scalar")) {
    for (let i = unknownFields.length - 1; i >= 0; --i) {
      if (unknownFields[i].no == field.no) {
        return [unknownFields[i]];
      }
    }
    return [];
  }
  return unknownFields.filter((uf) => uf.no === field.no);
}

// node_modules/@bufbuild/protobuf/dist/esm/proto-base64.js
var encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
var decTable = [];
for (let i = 0; i < encTable.length; i++)
  decTable[encTable[i].charCodeAt(0)] = i;
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
var protoBase64 = {
  /**
   * Decodes a base64 string to a byte array.
   *
   * - ignores white-space, including line breaks and tabs
   * - allows inner padding (can decode concatenated base64 strings)
   * - does not require padding
   * - understands base64url encoding:
   *   "-" instead of "+",
   *   "_" instead of "/",
   *   no padding
   */
  dec(base64Str) {
    let es = base64Str.length * 3 / 4;
    if (base64Str[base64Str.length - 2] == "=")
      es -= 2;
    else if (base64Str[base64Str.length - 1] == "=")
      es -= 1;
    let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0;
    for (let i = 0; i < base64Str.length; i++) {
      b = decTable[base64Str.charCodeAt(i)];
      if (b === void 0) {
        switch (base64Str[i]) {
          case "=":
            groupPos = 0;
          case "\n":
          case "\r":
          case "	":
          case " ":
            continue;
          default:
            throw Error("invalid base64 string.");
        }
      }
      switch (groupPos) {
        case 0:
          p = b;
          groupPos = 1;
          break;
        case 1:
          bytes[bytePos++] = p << 2 | (b & 48) >> 4;
          p = b;
          groupPos = 2;
          break;
        case 2:
          bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
          p = b;
          groupPos = 3;
          break;
        case 3:
          bytes[bytePos++] = (p & 3) << 6 | b;
          groupPos = 0;
          break;
      }
    }
    if (groupPos == 1)
      throw Error("invalid base64 string.");
    return bytes.subarray(0, bytePos);
  },
  /**
   * Encode a byte array to a base64 string.
   */
  enc(bytes) {
    let base64 = "", groupPos = 0, b, p = 0;
    for (let i = 0; i < bytes.length; i++) {
      b = bytes[i];
      switch (groupPos) {
        case 0:
          base64 += encTable[b >> 2];
          p = (b & 3) << 4;
          groupPos = 1;
          break;
        case 1:
          base64 += encTable[p | b >> 4];
          p = (b & 15) << 2;
          groupPos = 2;
          break;
        case 2:
          base64 += encTable[p | b >> 6];
          base64 += encTable[b & 63];
          groupPos = 0;
          break;
      }
    }
    if (groupPos) {
      base64 += encTable[p];
      base64 += "=";
      if (groupPos == 1)
        base64 += "=";
    }
    return base64;
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/extension-accessor.js
function getExtension(message2, extension, options) {
  assertExtendee(extension, message2);
  const opt = extension.runtime.bin.makeReadOptions(options);
  const ufs = filterUnknownFields(message2.getType().runtime.bin.listUnknownFields(message2), extension.field);
  const [container, get] = createExtensionContainer(extension);
  for (const uf of ufs) {
    extension.runtime.bin.readField(container, opt.readerFactory(uf.data), extension.field, uf.wireType, opt);
  }
  return get();
}
function setExtension(message2, extension, value, options) {
  assertExtendee(extension, message2);
  const readOpt = extension.runtime.bin.makeReadOptions(options);
  const writeOpt = extension.runtime.bin.makeWriteOptions(options);
  if (hasExtension(message2, extension)) {
    const ufs = message2.getType().runtime.bin.listUnknownFields(message2).filter((uf) => uf.no != extension.field.no);
    message2.getType().runtime.bin.discardUnknownFields(message2);
    for (const uf of ufs) {
      message2.getType().runtime.bin.onUnknownField(message2, uf.no, uf.wireType, uf.data);
    }
  }
  const writer = writeOpt.writerFactory();
  let f = extension.field;
  if (!f.opt && !f.repeated && (f.kind == "enum" || f.kind == "scalar")) {
    f = Object.assign(Object.assign({}, extension.field), { opt: true });
  }
  extension.runtime.bin.writeField(f, value, writer, writeOpt);
  const reader = readOpt.readerFactory(writer.finish());
  while (reader.pos < reader.len) {
    const [no, wireType] = reader.tag();
    const data = reader.skip(wireType, no);
    message2.getType().runtime.bin.onUnknownField(message2, no, wireType, data);
  }
}
function hasExtension(message2, extension) {
  const messageType = message2.getType();
  return extension.extendee.typeName === messageType.typeName && !!messageType.runtime.bin.listUnknownFields(message2).find((uf) => uf.no == extension.field.no);
}
function assertExtendee(extension, message2) {
  assert(extension.extendee.typeName == message2.getType().typeName, `extension ${extension.typeName} can only be applied to message ${extension.extendee.typeName}`);
}

// node_modules/@bufbuild/protobuf/dist/esm/private/reflect.js
function isFieldSet(field, target) {
  const localName2 = field.localName;
  if (field.repeated) {
    return target[localName2].length > 0;
  }
  if (field.oneof) {
    return target[field.oneof.localName].case === localName2;
  }
  switch (field.kind) {
    case "enum":
    case "scalar":
      if (field.opt || field.req) {
        return target[localName2] !== void 0;
      }
      if (field.kind == "enum") {
        return target[localName2] !== field.T.values[0].no;
      }
      return !isScalarZeroValue(field.T, target[localName2]);
    case "message":
      return target[localName2] !== void 0;
    case "map":
      return Object.keys(target[localName2]).length > 0;
  }
}
function clearField(field, target) {
  const localName2 = field.localName;
  const implicitPresence = !field.opt && !field.req;
  if (field.repeated) {
    target[localName2] = [];
  } else if (field.oneof) {
    target[field.oneof.localName] = { case: void 0 };
  } else {
    switch (field.kind) {
      case "map":
        target[localName2] = {};
        break;
      case "enum":
        target[localName2] = implicitPresence ? field.T.values[0].no : void 0;
        break;
      case "scalar":
        target[localName2] = implicitPresence ? scalarZeroValue(field.T, field.L) : void 0;
        break;
      case "message":
        target[localName2] = void 0;
        break;
    }
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/is-message.js
function isMessage(arg, type) {
  if (arg === null || typeof arg != "object") {
    return false;
  }
  if (!Object.getOwnPropertyNames(Message.prototype).every((m) => m in arg && typeof arg[m] == "function")) {
    return false;
  }
  const actualType = arg.getType();
  if (actualType === null || typeof actualType != "function" || !("typeName" in actualType) || typeof actualType.typeName != "string") {
    return false;
  }
  return type === void 0 ? true : actualType.typeName == type.typeName;
}

// node_modules/@bufbuild/protobuf/dist/esm/private/field-wrapper.js
function wrapField(type, value) {
  if (isMessage(value) || !type.fieldWrapper) {
    return value;
  }
  return type.fieldWrapper.wrapField(value);
}
var wktWrapperToScalarType = {
  "google.protobuf.DoubleValue": ScalarType.DOUBLE,
  "google.protobuf.FloatValue": ScalarType.FLOAT,
  "google.protobuf.Int64Value": ScalarType.INT64,
  "google.protobuf.UInt64Value": ScalarType.UINT64,
  "google.protobuf.Int32Value": ScalarType.INT32,
  "google.protobuf.UInt32Value": ScalarType.UINT32,
  "google.protobuf.BoolValue": ScalarType.BOOL,
  "google.protobuf.StringValue": ScalarType.STRING,
  "google.protobuf.BytesValue": ScalarType.BYTES
};

// node_modules/@bufbuild/protobuf/dist/esm/private/json-format.js
var jsonReadDefaults = {
  ignoreUnknownFields: false
};
var jsonWriteDefaults = {
  emitDefaultValues: false,
  enumAsInteger: false,
  useProtoFieldName: false,
  prettySpaces: 0
};
function makeReadOptions(options) {
  return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;
}
function makeWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;
}
var tokenNull = Symbol();
var tokenIgnoredUnknownEnum = Symbol();
function makeJsonFormat() {
  return {
    makeReadOptions,
    makeWriteOptions,
    readMessage(type, json, options, message2) {
      if (json == null || Array.isArray(json) || typeof json != "object") {
        throw new Error(`cannot decode message ${type.typeName} from JSON: ${debugJsonValue(json)}`);
      }
      message2 = message2 !== null && message2 !== void 0 ? message2 : new type();
      const oneofSeen = /* @__PURE__ */ new Map();
      const registry = options.typeRegistry;
      for (const [jsonKey, jsonValue] of Object.entries(json)) {
        const field = type.fields.findJsonName(jsonKey);
        if (field) {
          if (field.oneof) {
            if (jsonValue === null && field.kind == "scalar") {
              continue;
            }
            const seen = oneofSeen.get(field.oneof);
            if (seen !== void 0) {
              throw new Error(`cannot decode message ${type.typeName} from JSON: multiple keys for oneof "${field.oneof.name}" present: "${seen}", "${jsonKey}"`);
            }
            oneofSeen.set(field.oneof, jsonKey);
          }
          readField(message2, jsonValue, field, options, type);
        } else {
          let found = false;
          if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith("[") && jsonKey.endsWith("]")) {
            const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));
            if (ext && ext.extendee.typeName == type.typeName) {
              found = true;
              const [container, get] = createExtensionContainer(ext);
              readField(container, jsonValue, ext.field, options, ext);
              setExtension(message2, ext, get(), options);
            }
          }
          if (!found && !options.ignoreUnknownFields) {
            throw new Error(`cannot decode message ${type.typeName} from JSON: key "${jsonKey}" is unknown`);
          }
        }
      }
      return message2;
    },
    writeMessage(message2, options) {
      const type = message2.getType();
      const json = {};
      let field;
      try {
        for (field of type.fields.byNumber()) {
          if (!isFieldSet(field, message2)) {
            if (field.req) {
              throw `required field not set`;
            }
            if (!options.emitDefaultValues) {
              continue;
            }
            if (!canEmitFieldDefaultValue(field)) {
              continue;
            }
          }
          const value = field.oneof ? message2[field.oneof.localName].value : message2[field.localName];
          const jsonValue = writeField(field, value, options);
          if (jsonValue !== void 0) {
            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
          }
        }
        const registry = options.typeRegistry;
        if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {
          for (const uf of type.runtime.bin.listUnknownFields(message2)) {
            const ext = registry.findExtensionFor(type.typeName, uf.no);
            if (ext && hasExtension(message2, ext)) {
              const value = getExtension(message2, ext, options);
              const jsonValue = writeField(ext.field, value, options);
              if (jsonValue !== void 0) {
                json[ext.field.jsonName] = jsonValue;
              }
            }
          }
        }
      } catch (e) {
        const m = field ? `cannot encode field ${type.typeName}.${field.name} to JSON` : `cannot encode message ${type.typeName} to JSON`;
        const r = e instanceof Error ? e.message : String(e);
        throw new Error(m + (r.length > 0 ? `: ${r}` : ""));
      }
      return json;
    },
    readScalar(type, json, longType) {
      return readScalar(type, json, longType !== null && longType !== void 0 ? longType : LongType.BIGINT, true);
    },
    writeScalar(type, value, emitDefaultValues) {
      if (value === void 0) {
        return void 0;
      }
      if (emitDefaultValues || isScalarZeroValue(type, value)) {
        return writeScalar(type, value);
      }
      return void 0;
    },
    debug: debugJsonValue
  };
}
function debugJsonValue(json) {
  if (json === null) {
    return "null";
  }
  switch (typeof json) {
    case "object":
      return Array.isArray(json) ? "array" : "object";
    case "string":
      return json.length > 100 ? "string" : `"${json.split('"').join('\\"')}"`;
    default:
      return String(json);
  }
}
function readField(target, jsonValue, field, options, parentType) {
  let localName2 = field.localName;
  if (field.repeated) {
    assert(field.kind != "map");
    if (jsonValue === null) {
      return;
    }
    if (!Array.isArray(jsonValue)) {
      throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`);
    }
    const targetArray = target[localName2];
    for (const jsonItem of jsonValue) {
      if (jsonItem === null) {
        throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonItem)}`);
      }
      switch (field.kind) {
        case "message":
          targetArray.push(field.T.fromJson(jsonItem, options));
          break;
        case "enum":
          const enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);
          if (enumValue !== tokenIgnoredUnknownEnum) {
            targetArray.push(enumValue);
          }
          break;
        case "scalar":
          try {
            targetArray.push(readScalar(field.T, jsonItem, field.L, true));
          } catch (e) {
            let m = `cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonItem)}`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          break;
      }
    }
  } else if (field.kind == "map") {
    if (jsonValue === null) {
      return;
    }
    if (typeof jsonValue != "object" || Array.isArray(jsonValue)) {
      throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`);
    }
    const targetMap = target[localName2];
    for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)) {
      if (jsonMapValue === null) {
        throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: map value null`);
      }
      let key;
      try {
        key = readMapKey(field.K, jsonMapKey);
      } catch (e) {
        let m = `cannot decode map key for field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`;
        if (e instanceof Error && e.message.length > 0) {
          m += `: ${e.message}`;
        }
        throw new Error(m);
      }
      switch (field.V.kind) {
        case "message":
          targetMap[key] = field.V.T.fromJson(jsonMapValue, options);
          break;
        case "enum":
          const enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);
          if (enumValue !== tokenIgnoredUnknownEnum) {
            targetMap[key] = enumValue;
          }
          break;
        case "scalar":
          try {
            targetMap[key] = readScalar(field.V.T, jsonMapValue, LongType.BIGINT, true);
          } catch (e) {
            let m = `cannot decode map value for field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          break;
      }
    }
  } else {
    if (field.oneof) {
      target = target[field.oneof.localName] = { case: localName2 };
      localName2 = "value";
    }
    switch (field.kind) {
      case "message":
        const messageType = field.T;
        if (jsonValue === null && messageType.typeName != "google.protobuf.Value") {
          return;
        }
        let currentValue = target[localName2];
        if (isMessage(currentValue)) {
          currentValue.fromJson(jsonValue, options);
        } else {
          target[localName2] = currentValue = messageType.fromJson(jsonValue, options);
          if (messageType.fieldWrapper && !field.oneof) {
            target[localName2] = messageType.fieldWrapper.unwrapField(currentValue);
          }
        }
        break;
      case "enum":
        const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields, false);
        switch (enumValue) {
          case tokenNull:
            clearField(field, target);
            break;
          case tokenIgnoredUnknownEnum:
            break;
          default:
            target[localName2] = enumValue;
            break;
        }
        break;
      case "scalar":
        try {
          const scalarValue = readScalar(field.T, jsonValue, field.L, false);
          switch (scalarValue) {
            case tokenNull:
              clearField(field, target);
              break;
            default:
              target[localName2] = scalarValue;
              break;
          }
        } catch (e) {
          let m = `cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`;
          if (e instanceof Error && e.message.length > 0) {
            m += `: ${e.message}`;
          }
          throw new Error(m);
        }
        break;
    }
  }
}
function readMapKey(type, json) {
  if (type === ScalarType.BOOL) {
    switch (json) {
      case "true":
        json = true;
        break;
      case "false":
        json = false;
        break;
    }
  }
  return readScalar(type, json, LongType.BIGINT, true).toString();
}
function readScalar(type, json, longType, nullAsZeroValue) {
  if (json === null) {
    if (nullAsZeroValue) {
      return scalarZeroValue(type, longType);
    }
    return tokenNull;
  }
  switch (type) {
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      if (json === "NaN")
        return Number.NaN;
      if (json === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (json === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (json === "") {
        break;
      }
      if (typeof json == "string" && json.trim().length !== json.length) {
        break;
      }
      if (typeof json != "string" && typeof json != "number") {
        break;
      }
      const float = Number(json);
      if (Number.isNaN(float)) {
        break;
      }
      if (!Number.isFinite(float)) {
        break;
      }
      if (type == ScalarType.FLOAT)
        assertFloat32(float);
      return float;
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
    case ScalarType.UINT32:
      let int32;
      if (typeof json == "number")
        int32 = json;
      else if (typeof json == "string" && json.length > 0) {
        if (json.trim().length === json.length)
          int32 = Number(json);
      }
      if (int32 === void 0)
        break;
      if (type == ScalarType.UINT32 || type == ScalarType.FIXED32)
        assertUInt32(int32);
      else
        assertInt32(int32);
      return int32;
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      if (typeof json != "number" && typeof json != "string")
        break;
      const long = protoInt64.parse(json);
      return longType ? long.toString() : long;
    case ScalarType.FIXED64:
    case ScalarType.UINT64:
      if (typeof json != "number" && typeof json != "string")
        break;
      const uLong = protoInt64.uParse(json);
      return longType ? uLong.toString() : uLong;
    case ScalarType.BOOL:
      if (typeof json !== "boolean")
        break;
      return json;
    case ScalarType.STRING:
      if (typeof json !== "string") {
        break;
      }
      try {
        encodeURIComponent(json);
      } catch (e) {
        throw new Error("invalid UTF8");
      }
      return json;
    case ScalarType.BYTES:
      if (json === "")
        return new Uint8Array(0);
      if (typeof json !== "string")
        break;
      return protoBase64.dec(json);
  }
  throw new Error();
}
function readEnum(type, json, ignoreUnknownFields, nullAsZeroValue) {
  if (json === null) {
    if (type.typeName == "google.protobuf.NullValue") {
      return 0;
    }
    return nullAsZeroValue ? type.values[0].no : tokenNull;
  }
  switch (typeof json) {
    case "number":
      if (Number.isInteger(json)) {
        return json;
      }
      break;
    case "string":
      const value = type.findName(json);
      if (value !== void 0) {
        return value.no;
      }
      if (ignoreUnknownFields) {
        return tokenIgnoredUnknownEnum;
      }
      break;
  }
  throw new Error(`cannot decode enum ${type.typeName} from JSON: ${debugJsonValue(json)}`);
}
function canEmitFieldDefaultValue(field) {
  if (field.repeated || field.kind == "map") {
    return true;
  }
  if (field.oneof) {
    return false;
  }
  if (field.kind == "message") {
    return false;
  }
  if (field.opt || field.req) {
    return false;
  }
  return true;
}
function writeField(field, value, options) {
  if (field.kind == "map") {
    assert(typeof value == "object" && value != null);
    const jsonObj = {};
    const entries = Object.entries(value);
    switch (field.V.kind) {
      case "scalar":
        for (const [entryKey, entryValue] of entries) {
          jsonObj[entryKey.toString()] = writeScalar(field.V.T, entryValue);
        }
        break;
      case "message":
        for (const [entryKey, entryValue] of entries) {
          jsonObj[entryKey.toString()] = entryValue.toJson(options);
        }
        break;
      case "enum":
        const enumType = field.V.T;
        for (const [entryKey, entryValue] of entries) {
          jsonObj[entryKey.toString()] = writeEnum(enumType, entryValue, options.enumAsInteger);
        }
        break;
    }
    return options.emitDefaultValues || entries.length > 0 ? jsonObj : void 0;
  }
  if (field.repeated) {
    assert(Array.isArray(value));
    const jsonArr = [];
    switch (field.kind) {
      case "scalar":
        for (let i = 0; i < value.length; i++) {
          jsonArr.push(writeScalar(field.T, value[i]));
        }
        break;
      case "enum":
        for (let i = 0; i < value.length; i++) {
          jsonArr.push(writeEnum(field.T, value[i], options.enumAsInteger));
        }
        break;
      case "message":
        for (let i = 0; i < value.length; i++) {
          jsonArr.push(value[i].toJson(options));
        }
        break;
    }
    return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : void 0;
  }
  switch (field.kind) {
    case "scalar":
      return writeScalar(field.T, value);
    case "enum":
      return writeEnum(field.T, value, options.enumAsInteger);
    case "message":
      return wrapField(field.T, value).toJson(options);
  }
}
function writeEnum(type, value, enumAsInteger) {
  var _a2;
  assert(typeof value == "number");
  if (type.typeName == "google.protobuf.NullValue") {
    return null;
  }
  if (enumAsInteger) {
    return value;
  }
  const val = type.findNumber(value);
  return (_a2 = val === null || val === void 0 ? void 0 : val.name) !== null && _a2 !== void 0 ? _a2 : value;
}
function writeScalar(type, value) {
  switch (type) {
    case ScalarType.INT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
      assert(typeof value == "number");
      return value;
    case ScalarType.FLOAT:
    case ScalarType.DOUBLE:
      assert(typeof value == "number");
      if (Number.isNaN(value))
        return "NaN";
      if (value === Number.POSITIVE_INFINITY)
        return "Infinity";
      if (value === Number.NEGATIVE_INFINITY)
        return "-Infinity";
      return value;
    case ScalarType.STRING:
      assert(typeof value == "string");
      return value;
    case ScalarType.BOOL:
      assert(typeof value == "boolean");
      return value;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      assert(typeof value == "bigint" || typeof value == "string" || typeof value == "number");
      return value.toString();
    case ScalarType.BYTES:
      assert(value instanceof Uint8Array);
      return protoBase64.enc(value);
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/private/binary-format.js
var unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields");
var readDefaults = {
  readUnknownFields: true,
  readerFactory: (bytes) => new BinaryReader(bytes)
};
var writeDefaults = {
  writeUnknownFields: true,
  writerFactory: () => new BinaryWriter()
};
function makeReadOptions2(options) {
  return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
}
function makeWriteOptions2(options) {
  return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
}
function makeBinaryFormat() {
  return {
    makeReadOptions: makeReadOptions2,
    makeWriteOptions: makeWriteOptions2,
    listUnknownFields(message2) {
      var _a2;
      return (_a2 = message2[unknownFieldsSymbol]) !== null && _a2 !== void 0 ? _a2 : [];
    },
    discardUnknownFields(message2) {
      delete message2[unknownFieldsSymbol];
    },
    writeUnknownFields(message2, writer) {
      const m = message2;
      const c = m[unknownFieldsSymbol];
      if (c) {
        for (const f of c) {
          writer.tag(f.no, f.wireType).raw(f.data);
        }
      }
    },
    onUnknownField(message2, no, wireType, data) {
      const m = message2;
      if (!Array.isArray(m[unknownFieldsSymbol])) {
        m[unknownFieldsSymbol] = [];
      }
      m[unknownFieldsSymbol].push({ no, wireType, data });
    },
    readMessage(message2, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {
      const type = message2.getType();
      const end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;
      let fieldNo, wireType;
      while (reader.pos < end) {
        [fieldNo, wireType] = reader.tag();
        if (delimitedMessageEncoding === true && wireType == WireType.EndGroup) {
          break;
        }
        const field = type.fields.find(fieldNo);
        if (!field) {
          const data = reader.skip(wireType, fieldNo);
          if (options.readUnknownFields) {
            this.onUnknownField(message2, fieldNo, wireType, data);
          }
          continue;
        }
        readField2(message2, reader, field, wireType, options);
      }
      if (delimitedMessageEncoding && // eslint-disable-line @typescript-eslint/strict-boolean-expressions
      (wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {
        throw new Error(`invalid end group tag`);
      }
    },
    readField: readField2,
    writeMessage(message2, writer, options) {
      const type = message2.getType();
      for (const field of type.fields.byNumber()) {
        if (!isFieldSet(field, message2)) {
          if (field.req) {
            throw new Error(`cannot encode field ${type.typeName}.${field.name} to binary: required field not set`);
          }
          continue;
        }
        const value = field.oneof ? message2[field.oneof.localName].value : message2[field.localName];
        writeField2(field, value, writer, options);
      }
      if (options.writeUnknownFields) {
        this.writeUnknownFields(message2, writer);
      }
      return writer;
    },
    writeField(field, value, writer, options) {
      if (value === void 0) {
        return void 0;
      }
      writeField2(field, value, writer, options);
    }
  };
}
function readField2(target, reader, field, wireType, options) {
  let { repeated, localName: localName2 } = field;
  if (field.oneof) {
    target = target[field.oneof.localName];
    if (target.case != localName2) {
      delete target.value;
    }
    target.case = localName2;
    localName2 = "value";
  }
  switch (field.kind) {
    case "scalar":
    case "enum":
      const scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
      let read = readScalar2;
      if (field.kind == "scalar" && field.L > 0) {
        read = readScalarLTString;
      }
      if (repeated) {
        let arr = target[localName2];
        const isPacked = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;
        if (isPacked) {
          let e = reader.uint32() + reader.pos;
          while (reader.pos < e) {
            arr.push(read(reader, scalarType));
          }
        } else {
          arr.push(read(reader, scalarType));
        }
      } else {
        target[localName2] = read(reader, scalarType);
      }
      break;
    case "message":
      const messageType = field.T;
      if (repeated) {
        target[localName2].push(readMessageField(reader, new messageType(), options, field));
      } else {
        if (isMessage(target[localName2])) {
          readMessageField(reader, target[localName2], options, field);
        } else {
          target[localName2] = readMessageField(reader, new messageType(), options, field);
          if (messageType.fieldWrapper && !field.oneof && !field.repeated) {
            target[localName2] = messageType.fieldWrapper.unwrapField(target[localName2]);
          }
        }
      }
      break;
    case "map":
      let [mapKey, mapVal] = readMapEntry(field, reader, options);
      target[localName2][mapKey] = mapVal;
      break;
  }
}
function readMessageField(reader, message2, options, field) {
  const format = message2.getType().runtime.bin;
  const delimited = field === null || field === void 0 ? void 0 : field.delimited;
  format.readMessage(
    message2,
    reader,
    delimited ? field.no : reader.uint32(),
    // eslint-disable-line @typescript-eslint/strict-boolean-expressions
    options,
    delimited
  );
  return message2;
}
function readMapEntry(field, reader, options) {
  const length = reader.uint32(), end = reader.pos + length;
  let key, val;
  while (reader.pos < end) {
    const [fieldNo] = reader.tag();
    switch (fieldNo) {
      case 1:
        key = readScalar2(reader, field.K);
        break;
      case 2:
        switch (field.V.kind) {
          case "scalar":
            val = readScalar2(reader, field.V.T);
            break;
          case "enum":
            val = reader.int32();
            break;
          case "message":
            val = readMessageField(reader, new field.V.T(), options, void 0);
            break;
        }
        break;
    }
  }
  if (key === void 0) {
    key = scalarZeroValue(field.K, LongType.BIGINT);
  }
  if (typeof key != "string" && typeof key != "number") {
    key = key.toString();
  }
  if (val === void 0) {
    switch (field.V.kind) {
      case "scalar":
        val = scalarZeroValue(field.V.T, LongType.BIGINT);
        break;
      case "enum":
        val = field.V.T.values[0].no;
        break;
      case "message":
        val = new field.V.T();
        break;
    }
  }
  return [key, val];
}
function readScalarLTString(reader, type) {
  const v = readScalar2(reader, type);
  return typeof v == "bigint" ? v.toString() : v;
}
function readScalar2(reader, type) {
  switch (type) {
    case ScalarType.STRING:
      return reader.string();
    case ScalarType.BOOL:
      return reader.bool();
    case ScalarType.DOUBLE:
      return reader.double();
    case ScalarType.FLOAT:
      return reader.float();
    case ScalarType.INT32:
      return reader.int32();
    case ScalarType.INT64:
      return reader.int64();
    case ScalarType.UINT64:
      return reader.uint64();
    case ScalarType.FIXED64:
      return reader.fixed64();
    case ScalarType.BYTES:
      return reader.bytes();
    case ScalarType.FIXED32:
      return reader.fixed32();
    case ScalarType.SFIXED32:
      return reader.sfixed32();
    case ScalarType.SFIXED64:
      return reader.sfixed64();
    case ScalarType.SINT64:
      return reader.sint64();
    case ScalarType.UINT32:
      return reader.uint32();
    case ScalarType.SINT32:
      return reader.sint32();
  }
}
function writeField2(field, value, writer, options) {
  assert(value !== void 0);
  const repeated = field.repeated;
  switch (field.kind) {
    case "scalar":
    case "enum":
      let scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
      if (repeated) {
        assert(Array.isArray(value));
        if (field.packed) {
          writePacked(writer, scalarType, field.no, value);
        } else {
          for (const item of value) {
            writeScalar2(writer, scalarType, field.no, item);
          }
        }
      } else {
        writeScalar2(writer, scalarType, field.no, value);
      }
      break;
    case "message":
      if (repeated) {
        assert(Array.isArray(value));
        for (const item of value) {
          writeMessageField(writer, options, field, item);
        }
      } else {
        writeMessageField(writer, options, field, value);
      }
      break;
    case "map":
      assert(typeof value == "object" && value != null);
      for (const [key, val] of Object.entries(value)) {
        writeMapEntry(writer, options, field, key, val);
      }
      break;
  }
}
function writeMapEntry(writer, options, field, key, value) {
  writer.tag(field.no, WireType.LengthDelimited);
  writer.fork();
  let keyValue = key;
  switch (field.K) {
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
      keyValue = Number.parseInt(key);
      break;
    case ScalarType.BOOL:
      assert(key == "true" || key == "false");
      keyValue = key == "true";
      break;
  }
  writeScalar2(writer, field.K, 1, keyValue);
  switch (field.V.kind) {
    case "scalar":
      writeScalar2(writer, field.V.T, 2, value);
      break;
    case "enum":
      writeScalar2(writer, ScalarType.INT32, 2, value);
      break;
    case "message":
      assert(value !== void 0);
      writer.tag(2, WireType.LengthDelimited).bytes(value.toBinary(options));
      break;
  }
  writer.join();
}
function writeMessageField(writer, options, field, value) {
  const message2 = wrapField(field.T, value);
  if (field.delimited)
    writer.tag(field.no, WireType.StartGroup).raw(message2.toBinary(options)).tag(field.no, WireType.EndGroup);
  else
    writer.tag(field.no, WireType.LengthDelimited).bytes(message2.toBinary(options));
}
function writeScalar2(writer, type, fieldNo, value) {
  assert(value !== void 0);
  let [wireType, method] = scalarTypeInfo(type);
  writer.tag(fieldNo, wireType)[method](value);
}
function writePacked(writer, type, fieldNo, value) {
  if (!value.length) {
    return;
  }
  writer.tag(fieldNo, WireType.LengthDelimited).fork();
  let [, method] = scalarTypeInfo(type);
  for (let i = 0; i < value.length; i++) {
    writer[method](value[i]);
  }
  writer.join();
}
function scalarTypeInfo(type) {
  let wireType = WireType.Varint;
  switch (type) {
    case ScalarType.BYTES:
    case ScalarType.STRING:
      wireType = WireType.LengthDelimited;
      break;
    case ScalarType.DOUBLE:
    case ScalarType.FIXED64:
    case ScalarType.SFIXED64:
      wireType = WireType.Bit64;
      break;
    case ScalarType.FIXED32:
    case ScalarType.SFIXED32:
    case ScalarType.FLOAT:
      wireType = WireType.Bit32;
      break;
  }
  const method = ScalarType[type].toLowerCase();
  return [wireType, method];
}

// node_modules/@bufbuild/protobuf/dist/esm/private/util-common.js
function makeUtilCommon() {
  return {
    setEnumType,
    initPartial(source, target) {
      if (source === void 0) {
        return;
      }
      const type = target.getType();
      for (const member of type.fields.byMember()) {
        const localName2 = member.localName, t = target, s = source;
        if (s[localName2] == null) {
          continue;
        }
        switch (member.kind) {
          case "oneof":
            const sk = s[localName2].case;
            if (sk === void 0) {
              continue;
            }
            const sourceField = member.findField(sk);
            let val = s[localName2].value;
            if (sourceField && sourceField.kind == "message" && !isMessage(val, sourceField.T)) {
              val = new sourceField.T(val);
            } else if (sourceField && sourceField.kind === "scalar" && sourceField.T === ScalarType.BYTES) {
              val = toU8Arr(val);
            }
            t[localName2] = { case: sk, value: val };
            break;
          case "scalar":
          case "enum":
            let copy = s[localName2];
            if (member.T === ScalarType.BYTES) {
              copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);
            }
            t[localName2] = copy;
            break;
          case "map":
            switch (member.V.kind) {
              case "scalar":
              case "enum":
                if (member.V.T === ScalarType.BYTES) {
                  for (const [k, v] of Object.entries(s[localName2])) {
                    t[localName2][k] = toU8Arr(v);
                  }
                } else {
                  Object.assign(t[localName2], s[localName2]);
                }
                break;
              case "message":
                const messageType = member.V.T;
                for (const k of Object.keys(s[localName2])) {
                  let val2 = s[localName2][k];
                  if (!messageType.fieldWrapper) {
                    val2 = new messageType(val2);
                  }
                  t[localName2][k] = val2;
                }
                break;
            }
            break;
          case "message":
            const mt = member.T;
            if (member.repeated) {
              t[localName2] = s[localName2].map((val2) => isMessage(val2, mt) ? val2 : new mt(val2));
            } else {
              const val2 = s[localName2];
              if (mt.fieldWrapper) {
                if (
                  // We can't use BytesValue.typeName as that will create a circular import
                  mt.typeName === "google.protobuf.BytesValue"
                ) {
                  t[localName2] = toU8Arr(val2);
                } else {
                  t[localName2] = val2;
                }
              } else {
                t[localName2] = isMessage(val2, mt) ? val2 : new mt(val2);
              }
            }
            break;
        }
      }
    },
    // TODO use isFieldSet() here to support future field presence
    equals(type, a, b) {
      if (a === b) {
        return true;
      }
      if (!a || !b) {
        return false;
      }
      return type.fields.byMember().every((m) => {
        const va = a[m.localName];
        const vb = b[m.localName];
        if (m.repeated) {
          if (va.length !== vb.length) {
            return false;
          }
          switch (m.kind) {
            case "message":
              return va.every((a2, i) => m.T.equals(a2, vb[i]));
            case "scalar":
              return va.every((a2, i) => scalarEquals(m.T, a2, vb[i]));
            case "enum":
              return va.every((a2, i) => scalarEquals(ScalarType.INT32, a2, vb[i]));
          }
          throw new Error(`repeated cannot contain ${m.kind}`);
        }
        switch (m.kind) {
          case "message":
            return m.T.equals(va, vb);
          case "enum":
            return scalarEquals(ScalarType.INT32, va, vb);
          case "scalar":
            return scalarEquals(m.T, va, vb);
          case "oneof":
            if (va.case !== vb.case) {
              return false;
            }
            const s = m.findField(va.case);
            if (s === void 0) {
              return true;
            }
            switch (s.kind) {
              case "message":
                return s.T.equals(va.value, vb.value);
              case "enum":
                return scalarEquals(ScalarType.INT32, va.value, vb.value);
              case "scalar":
                return scalarEquals(s.T, va.value, vb.value);
            }
            throw new Error(`oneof cannot contain ${s.kind}`);
          case "map":
            const keys = Object.keys(va).concat(Object.keys(vb));
            switch (m.V.kind) {
              case "message":
                const messageType = m.V.T;
                return keys.every((k) => messageType.equals(va[k], vb[k]));
              case "enum":
                return keys.every((k) => scalarEquals(ScalarType.INT32, va[k], vb[k]));
              case "scalar":
                const scalarType = m.V.T;
                return keys.every((k) => scalarEquals(scalarType, va[k], vb[k]));
            }
            break;
        }
      });
    },
    // TODO use isFieldSet() here to support future field presence
    clone(message2) {
      const type = message2.getType(), target = new type(), any = target;
      for (const member of type.fields.byMember()) {
        const source = message2[member.localName];
        let copy;
        if (member.repeated) {
          copy = source.map(cloneSingularField);
        } else if (member.kind == "map") {
          copy = any[member.localName];
          for (const [key, v] of Object.entries(source)) {
            copy[key] = cloneSingularField(v);
          }
        } else if (member.kind == "oneof") {
          const f = member.findField(source.case);
          copy = f ? { case: source.case, value: cloneSingularField(source.value) } : { case: void 0 };
        } else {
          copy = cloneSingularField(source);
        }
        any[member.localName] = copy;
      }
      for (const uf of type.runtime.bin.listUnknownFields(message2)) {
        type.runtime.bin.onUnknownField(any, uf.no, uf.wireType, uf.data);
      }
      return target;
    }
  };
}
function cloneSingularField(value) {
  if (value === void 0) {
    return value;
  }
  if (isMessage(value)) {
    return value.clone();
  }
  if (value instanceof Uint8Array) {
    const c = new Uint8Array(value.byteLength);
    c.set(value);
    return c;
  }
  return value;
}
function toU8Arr(input) {
  return input instanceof Uint8Array ? input : new Uint8Array(input);
}

// node_modules/@bufbuild/protobuf/dist/esm/private/proto-runtime.js
function makeProtoRuntime(syntax, newFieldList, initFields) {
  return {
    syntax,
    json: makeJsonFormat(),
    bin: makeBinaryFormat(),
    util: Object.assign(Object.assign({}, makeUtilCommon()), {
      newFieldList,
      initFields
    }),
    makeMessageType(typeName, fields, opt) {
      return makeMessageType(this, typeName, fields, opt);
    },
    makeEnum,
    makeEnumType,
    getEnumType,
    makeExtension(typeName, extendee, field) {
      return makeExtension(this, typeName, extendee, field);
    }
  };
}

// node_modules/@bufbuild/protobuf/dist/esm/private/field-list.js
var InternalFieldList = class {
  constructor(fields, normalizer) {
    this._fields = fields;
    this._normalizer = normalizer;
  }
  findJsonName(jsonName) {
    if (!this.jsonNames) {
      const t = {};
      for (const f of this.list()) {
        t[f.jsonName] = t[f.name] = f;
      }
      this.jsonNames = t;
    }
    return this.jsonNames[jsonName];
  }
  find(fieldNo) {
    if (!this.numbers) {
      const t = {};
      for (const f of this.list()) {
        t[f.no] = f;
      }
      this.numbers = t;
    }
    return this.numbers[fieldNo];
  }
  list() {
    if (!this.all) {
      this.all = this._normalizer(this._fields);
    }
    return this.all;
  }
  byNumber() {
    if (!this.numbersAsc) {
      this.numbersAsc = this.list().concat().sort((a, b) => a.no - b.no);
    }
    return this.numbersAsc;
  }
  byMember() {
    if (!this.members) {
      this.members = [];
      const a = this.members;
      let o;
      for (const f of this.list()) {
        if (f.oneof) {
          if (f.oneof !== o) {
            o = f.oneof;
            a.push(o);
          }
        } else {
          a.push(f);
        }
      }
    }
    return this.members;
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/private/names.js
function localFieldName(protoName, inOneof) {
  const name = protoCamelCase(protoName);
  if (inOneof) {
    return name;
  }
  return safeObjectProperty(safeMessageProperty(name));
}
function localOneofName(protoName) {
  return localFieldName(protoName, false);
}
var fieldJsonName = protoCamelCase;
function protoCamelCase(snakeCase) {
  let capNext = false;
  const b = [];
  for (let i = 0; i < snakeCase.length; i++) {
    let c = snakeCase.charAt(i);
    switch (c) {
      case "_":
        capNext = true;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        b.push(c);
        capNext = false;
        break;
      default:
        if (capNext) {
          capNext = false;
          c = c.toUpperCase();
        }
        b.push(c);
        break;
    }
  }
  return b.join("");
}
var reservedObjectProperties = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]);
var reservedMessageProperties = /* @__PURE__ */ new Set([
  // names reserved by the runtime
  "getType",
  "clone",
  "equals",
  "fromBinary",
  "fromJson",
  "fromJsonString",
  "toBinary",
  "toJson",
  "toJsonString",
  // names reserved by the runtime for the future
  "toObject"
]);
var fallback = (name) => `${name}$`;
var safeMessageProperty = (name) => {
  if (reservedMessageProperties.has(name)) {
    return fallback(name);
  }
  return name;
};
var safeObjectProperty = (name) => {
  if (reservedObjectProperties.has(name)) {
    return fallback(name);
  }
  return name;
};

// node_modules/@bufbuild/protobuf/dist/esm/private/field.js
var InternalOneofInfo = class {
  constructor(name) {
    this.kind = "oneof";
    this.repeated = false;
    this.packed = false;
    this.opt = false;
    this.req = false;
    this.default = void 0;
    this.fields = [];
    this.name = name;
    this.localName = localOneofName(name);
  }
  addField(field) {
    assert(field.oneof === this, `field ${field.name} not one of ${this.name}`);
    this.fields.push(field);
  }
  findField(localName2) {
    if (!this._lookup) {
      this._lookup = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < this.fields.length; i++) {
        this._lookup[this.fields[i].localName] = this.fields[i];
      }
    }
    return this._lookup[localName2];
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/private/field-normalize.js
function normalizeFieldInfos(fieldInfos, packedByDefault) {
  var _a2, _b2, _c, _d, _e, _f;
  const r = [];
  let o;
  for (const field of typeof fieldInfos == "function" ? fieldInfos() : fieldInfos) {
    const f = field;
    f.localName = localFieldName(field.name, field.oneof !== void 0);
    f.jsonName = (_a2 = field.jsonName) !== null && _a2 !== void 0 ? _a2 : fieldJsonName(field.name);
    f.repeated = (_b2 = field.repeated) !== null && _b2 !== void 0 ? _b2 : false;
    if (field.kind == "scalar") {
      f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;
    }
    f.delimited = (_d = field.delimited) !== null && _d !== void 0 ? _d : false;
    f.req = (_e = field.req) !== null && _e !== void 0 ? _e : false;
    f.opt = (_f = field.opt) !== null && _f !== void 0 ? _f : false;
    if (field.packed === void 0) {
      if (packedByDefault) {
        f.packed = field.kind == "enum" || field.kind == "scalar" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;
      } else {
        f.packed = false;
      }
    }
    if (field.oneof !== void 0) {
      const ooname = typeof field.oneof == "string" ? field.oneof : field.oneof.name;
      if (!o || o.name != ooname) {
        o = new InternalOneofInfo(ooname);
      }
      f.oneof = o;
      o.addField(f);
    }
    r.push(f);
  }
  return r;
}

// node_modules/@bufbuild/protobuf/dist/esm/proto3.js
var proto3 = makeProtoRuntime(
  "proto3",
  (fields) => {
    return new InternalFieldList(fields, (source) => normalizeFieldInfos(source, true));
  },
  // TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone
  (target) => {
    for (const member of target.getType().fields.byMember()) {
      if (member.opt) {
        continue;
      }
      const name = member.localName, t = target;
      if (member.repeated) {
        t[name] = [];
        continue;
      }
      switch (member.kind) {
        case "oneof":
          t[name] = { case: void 0 };
          break;
        case "enum":
          t[name] = 0;
          break;
        case "map":
          t[name] = {};
          break;
        case "scalar":
          t[name] = scalarZeroValue(member.T, member.L);
          break;
        case "message":
          break;
      }
    }
  }
);

// node_modules/@bufbuild/protobuf/dist/esm/proto2.js
var proto2 = makeProtoRuntime(
  "proto2",
  (fields) => {
    return new InternalFieldList(fields, (source) => normalizeFieldInfos(source, false));
  },
  // TODO merge with proto3 and initExtensionField, also see initPartial, equals, clone
  (target) => {
    for (const member of target.getType().fields.byMember()) {
      const name = member.localName, t = target;
      if (member.repeated) {
        t[name] = [];
        continue;
      }
      switch (member.kind) {
        case "oneof":
          t[name] = { case: void 0 };
          break;
        case "map":
          t[name] = {};
          break;
        case "scalar":
        case "enum":
        case "message":
          break;
      }
    }
  }
);

// node_modules/@bufbuild/protobuf/dist/esm/proto-double.js
var protoDouble = {
  NaN: Number.NaN,
  POSITIVE_INFINITY: Number.POSITIVE_INFINITY,
  NEGATIVE_INFINITY: Number.NEGATIVE_INFINITY
};

// node_modules/@bufbuild/protobuf/dist/esm/service-type.js
var MethodKind;
(function(MethodKind2) {
  MethodKind2[MethodKind2["Unary"] = 0] = "Unary";
  MethodKind2[MethodKind2["ServerStreaming"] = 1] = "ServerStreaming";
  MethodKind2[MethodKind2["ClientStreaming"] = 2] = "ClientStreaming";
  MethodKind2[MethodKind2["BiDiStreaming"] = 3] = "BiDiStreaming";
})(MethodKind || (MethodKind = {}));
var MethodIdempotency;
(function(MethodIdempotency2) {
  MethodIdempotency2[MethodIdempotency2["NoSideEffects"] = 1] = "NoSideEffects";
  MethodIdempotency2[MethodIdempotency2["Idempotent"] = 2] = "Idempotent";
})(MethodIdempotency || (MethodIdempotency = {}));

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/descriptor_pb.js
var Edition;
(function(Edition2) {
  Edition2[Edition2["EDITION_UNKNOWN"] = 0] = "EDITION_UNKNOWN";
  Edition2[Edition2["EDITION_LEGACY"] = 900] = "EDITION_LEGACY";
  Edition2[Edition2["EDITION_PROTO2"] = 998] = "EDITION_PROTO2";
  Edition2[Edition2["EDITION_PROTO3"] = 999] = "EDITION_PROTO3";
  Edition2[Edition2["EDITION_2023"] = 1e3] = "EDITION_2023";
  Edition2[Edition2["EDITION_2024"] = 1001] = "EDITION_2024";
  Edition2[Edition2["EDITION_1_TEST_ONLY"] = 1] = "EDITION_1_TEST_ONLY";
  Edition2[Edition2["EDITION_2_TEST_ONLY"] = 2] = "EDITION_2_TEST_ONLY";
  Edition2[Edition2["EDITION_99997_TEST_ONLY"] = 99997] = "EDITION_99997_TEST_ONLY";
  Edition2[Edition2["EDITION_99998_TEST_ONLY"] = 99998] = "EDITION_99998_TEST_ONLY";
  Edition2[Edition2["EDITION_99999_TEST_ONLY"] = 99999] = "EDITION_99999_TEST_ONLY";
  Edition2[Edition2["EDITION_MAX"] = 2147483647] = "EDITION_MAX";
})(Edition || (Edition = {}));
proto2.util.setEnumType(Edition, "google.protobuf.Edition", [
  { no: 0, name: "EDITION_UNKNOWN" },
  { no: 900, name: "EDITION_LEGACY" },
  { no: 998, name: "EDITION_PROTO2" },
  { no: 999, name: "EDITION_PROTO3" },
  { no: 1e3, name: "EDITION_2023" },
  { no: 1001, name: "EDITION_2024" },
  { no: 1, name: "EDITION_1_TEST_ONLY" },
  { no: 2, name: "EDITION_2_TEST_ONLY" },
  { no: 99997, name: "EDITION_99997_TEST_ONLY" },
  { no: 99998, name: "EDITION_99998_TEST_ONLY" },
  { no: 99999, name: "EDITION_99999_TEST_ONLY" },
  { no: 2147483647, name: "EDITION_MAX" }
]);
var FileDescriptorSet = class _FileDescriptorSet extends Message {
  constructor(data) {
    super();
    this.file = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FileDescriptorSet().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FileDescriptorSet().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FileDescriptorSet().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_FileDescriptorSet, a, b);
  }
};
FileDescriptorSet.runtime = proto2;
FileDescriptorSet.typeName = "google.protobuf.FileDescriptorSet";
FileDescriptorSet.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "file", kind: "message", T: FileDescriptorProto, repeated: true }
]);
var FileDescriptorProto = class _FileDescriptorProto extends Message {
  constructor(data) {
    super();
    this.dependency = [];
    this.publicDependency = [];
    this.weakDependency = [];
    this.messageType = [];
    this.enumType = [];
    this.service = [];
    this.extension = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FileDescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FileDescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FileDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_FileDescriptorProto, a, b);
  }
};
FileDescriptorProto.runtime = proto2;
FileDescriptorProto.typeName = "google.protobuf.FileDescriptorProto";
FileDescriptorProto.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "package", kind: "scalar", T: 9, opt: true },
  { no: 3, name: "dependency", kind: "scalar", T: 9, repeated: true },
  { no: 10, name: "public_dependency", kind: "scalar", T: 5, repeated: true },
  { no: 11, name: "weak_dependency", kind: "scalar", T: 5, repeated: true },
  { no: 4, name: "message_type", kind: "message", T: DescriptorProto, repeated: true },
  { no: 5, name: "enum_type", kind: "message", T: EnumDescriptorProto, repeated: true },
  { no: 6, name: "service", kind: "message", T: ServiceDescriptorProto, repeated: true },
  { no: 7, name: "extension", kind: "message", T: FieldDescriptorProto, repeated: true },
  { no: 8, name: "options", kind: "message", T: FileOptions, opt: true },
  { no: 9, name: "source_code_info", kind: "message", T: SourceCodeInfo, opt: true },
  { no: 12, name: "syntax", kind: "scalar", T: 9, opt: true },
  { no: 14, name: "edition", kind: "enum", T: proto2.getEnumType(Edition), opt: true }
]);
var DescriptorProto = class _DescriptorProto extends Message {
  constructor(data) {
    super();
    this.field = [];
    this.extension = [];
    this.nestedType = [];
    this.enumType = [];
    this.extensionRange = [];
    this.oneofDecl = [];
    this.reservedRange = [];
    this.reservedName = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _DescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _DescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _DescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_DescriptorProto, a, b);
  }
};
DescriptorProto.runtime = proto2;
DescriptorProto.typeName = "google.protobuf.DescriptorProto";
DescriptorProto.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "field", kind: "message", T: FieldDescriptorProto, repeated: true },
  { no: 6, name: "extension", kind: "message", T: FieldDescriptorProto, repeated: true },
  { no: 3, name: "nested_type", kind: "message", T: DescriptorProto, repeated: true },
  { no: 4, name: "enum_type", kind: "message", T: EnumDescriptorProto, repeated: true },
  { no: 5, name: "extension_range", kind: "message", T: DescriptorProto_ExtensionRange, repeated: true },
  { no: 8, name: "oneof_decl", kind: "message", T: OneofDescriptorProto, repeated: true },
  { no: 7, name: "options", kind: "message", T: MessageOptions, opt: true },
  { no: 9, name: "reserved_range", kind: "message", T: DescriptorProto_ReservedRange, repeated: true },
  { no: 10, name: "reserved_name", kind: "scalar", T: 9, repeated: true }
]);
var DescriptorProto_ExtensionRange = class _DescriptorProto_ExtensionRange extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _DescriptorProto_ExtensionRange().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _DescriptorProto_ExtensionRange().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _DescriptorProto_ExtensionRange().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_DescriptorProto_ExtensionRange, a, b);
  }
};
DescriptorProto_ExtensionRange.runtime = proto2;
DescriptorProto_ExtensionRange.typeName = "google.protobuf.DescriptorProto.ExtensionRange";
DescriptorProto_ExtensionRange.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "start", kind: "scalar", T: 5, opt: true },
  { no: 2, name: "end", kind: "scalar", T: 5, opt: true },
  { no: 3, name: "options", kind: "message", T: ExtensionRangeOptions, opt: true }
]);
var DescriptorProto_ReservedRange = class _DescriptorProto_ReservedRange extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _DescriptorProto_ReservedRange().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _DescriptorProto_ReservedRange().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _DescriptorProto_ReservedRange().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_DescriptorProto_ReservedRange, a, b);
  }
};
DescriptorProto_ReservedRange.runtime = proto2;
DescriptorProto_ReservedRange.typeName = "google.protobuf.DescriptorProto.ReservedRange";
DescriptorProto_ReservedRange.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "start", kind: "scalar", T: 5, opt: true },
  { no: 2, name: "end", kind: "scalar", T: 5, opt: true }
]);
var ExtensionRangeOptions = class _ExtensionRangeOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    this.declaration = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _ExtensionRangeOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _ExtensionRangeOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _ExtensionRangeOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_ExtensionRangeOptions, a, b);
  }
};
ExtensionRangeOptions.runtime = proto2;
ExtensionRangeOptions.typeName = "google.protobuf.ExtensionRangeOptions";
ExtensionRangeOptions.fields = proto2.util.newFieldList(() => [
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true },
  { no: 2, name: "declaration", kind: "message", T: ExtensionRangeOptions_Declaration, repeated: true },
  { no: 50, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 3, name: "verification", kind: "enum", T: proto2.getEnumType(ExtensionRangeOptions_VerificationState), opt: true, default: ExtensionRangeOptions_VerificationState.UNVERIFIED }
]);
var ExtensionRangeOptions_VerificationState;
(function(ExtensionRangeOptions_VerificationState2) {
  ExtensionRangeOptions_VerificationState2[ExtensionRangeOptions_VerificationState2["DECLARATION"] = 0] = "DECLARATION";
  ExtensionRangeOptions_VerificationState2[ExtensionRangeOptions_VerificationState2["UNVERIFIED"] = 1] = "UNVERIFIED";
})(ExtensionRangeOptions_VerificationState || (ExtensionRangeOptions_VerificationState = {}));
proto2.util.setEnumType(ExtensionRangeOptions_VerificationState, "google.protobuf.ExtensionRangeOptions.VerificationState", [
  { no: 0, name: "DECLARATION" },
  { no: 1, name: "UNVERIFIED" }
]);
var ExtensionRangeOptions_Declaration = class _ExtensionRangeOptions_Declaration extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _ExtensionRangeOptions_Declaration().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _ExtensionRangeOptions_Declaration().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _ExtensionRangeOptions_Declaration().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_ExtensionRangeOptions_Declaration, a, b);
  }
};
ExtensionRangeOptions_Declaration.runtime = proto2;
ExtensionRangeOptions_Declaration.typeName = "google.protobuf.ExtensionRangeOptions.Declaration";
ExtensionRangeOptions_Declaration.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "number", kind: "scalar", T: 5, opt: true },
  { no: 2, name: "full_name", kind: "scalar", T: 9, opt: true },
  { no: 3, name: "type", kind: "scalar", T: 9, opt: true },
  { no: 5, name: "reserved", kind: "scalar", T: 8, opt: true },
  { no: 6, name: "repeated", kind: "scalar", T: 8, opt: true }
]);
var FieldDescriptorProto = class _FieldDescriptorProto extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FieldDescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FieldDescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FieldDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_FieldDescriptorProto, a, b);
  }
};
FieldDescriptorProto.runtime = proto2;
FieldDescriptorProto.typeName = "google.protobuf.FieldDescriptorProto";
FieldDescriptorProto.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 3, name: "number", kind: "scalar", T: 5, opt: true },
  { no: 4, name: "label", kind: "enum", T: proto2.getEnumType(FieldDescriptorProto_Label), opt: true },
  { no: 5, name: "type", kind: "enum", T: proto2.getEnumType(FieldDescriptorProto_Type), opt: true },
  { no: 6, name: "type_name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "extendee", kind: "scalar", T: 9, opt: true },
  { no: 7, name: "default_value", kind: "scalar", T: 9, opt: true },
  { no: 9, name: "oneof_index", kind: "scalar", T: 5, opt: true },
  { no: 10, name: "json_name", kind: "scalar", T: 9, opt: true },
  { no: 8, name: "options", kind: "message", T: FieldOptions, opt: true },
  { no: 17, name: "proto3_optional", kind: "scalar", T: 8, opt: true }
]);
var FieldDescriptorProto_Type;
(function(FieldDescriptorProto_Type2) {
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["DOUBLE"] = 1] = "DOUBLE";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FLOAT"] = 2] = "FLOAT";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["INT64"] = 3] = "INT64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["UINT64"] = 4] = "UINT64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["INT32"] = 5] = "INT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FIXED64"] = 6] = "FIXED64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FIXED32"] = 7] = "FIXED32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["BOOL"] = 8] = "BOOL";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["STRING"] = 9] = "STRING";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["GROUP"] = 10] = "GROUP";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["MESSAGE"] = 11] = "MESSAGE";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["BYTES"] = 12] = "BYTES";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["UINT32"] = 13] = "UINT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["ENUM"] = 14] = "ENUM";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SFIXED32"] = 15] = "SFIXED32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SFIXED64"] = 16] = "SFIXED64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SINT32"] = 17] = "SINT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SINT64"] = 18] = "SINT64";
})(FieldDescriptorProto_Type || (FieldDescriptorProto_Type = {}));
proto2.util.setEnumType(FieldDescriptorProto_Type, "google.protobuf.FieldDescriptorProto.Type", [
  { no: 1, name: "TYPE_DOUBLE" },
  { no: 2, name: "TYPE_FLOAT" },
  { no: 3, name: "TYPE_INT64" },
  { no: 4, name: "TYPE_UINT64" },
  { no: 5, name: "TYPE_INT32" },
  { no: 6, name: "TYPE_FIXED64" },
  { no: 7, name: "TYPE_FIXED32" },
  { no: 8, name: "TYPE_BOOL" },
  { no: 9, name: "TYPE_STRING" },
  { no: 10, name: "TYPE_GROUP" },
  { no: 11, name: "TYPE_MESSAGE" },
  { no: 12, name: "TYPE_BYTES" },
  { no: 13, name: "TYPE_UINT32" },
  { no: 14, name: "TYPE_ENUM" },
  { no: 15, name: "TYPE_SFIXED32" },
  { no: 16, name: "TYPE_SFIXED64" },
  { no: 17, name: "TYPE_SINT32" },
  { no: 18, name: "TYPE_SINT64" }
]);
var FieldDescriptorProto_Label;
(function(FieldDescriptorProto_Label2) {
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["OPTIONAL"] = 1] = "OPTIONAL";
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["REPEATED"] = 3] = "REPEATED";
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["REQUIRED"] = 2] = "REQUIRED";
})(FieldDescriptorProto_Label || (FieldDescriptorProto_Label = {}));
proto2.util.setEnumType(FieldDescriptorProto_Label, "google.protobuf.FieldDescriptorProto.Label", [
  { no: 1, name: "LABEL_OPTIONAL" },
  { no: 3, name: "LABEL_REPEATED" },
  { no: 2, name: "LABEL_REQUIRED" }
]);
var OneofDescriptorProto = class _OneofDescriptorProto extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _OneofDescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _OneofDescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _OneofDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_OneofDescriptorProto, a, b);
  }
};
OneofDescriptorProto.runtime = proto2;
OneofDescriptorProto.typeName = "google.protobuf.OneofDescriptorProto";
OneofDescriptorProto.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "options", kind: "message", T: OneofOptions, opt: true }
]);
var EnumDescriptorProto = class _EnumDescriptorProto extends Message {
  constructor(data) {
    super();
    this.value = [];
    this.reservedRange = [];
    this.reservedName = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _EnumDescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _EnumDescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _EnumDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_EnumDescriptorProto, a, b);
  }
};
EnumDescriptorProto.runtime = proto2;
EnumDescriptorProto.typeName = "google.protobuf.EnumDescriptorProto";
EnumDescriptorProto.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "value", kind: "message", T: EnumValueDescriptorProto, repeated: true },
  { no: 3, name: "options", kind: "message", T: EnumOptions, opt: true },
  { no: 4, name: "reserved_range", kind: "message", T: EnumDescriptorProto_EnumReservedRange, repeated: true },
  { no: 5, name: "reserved_name", kind: "scalar", T: 9, repeated: true }
]);
var EnumDescriptorProto_EnumReservedRange = class _EnumDescriptorProto_EnumReservedRange extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _EnumDescriptorProto_EnumReservedRange().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _EnumDescriptorProto_EnumReservedRange().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _EnumDescriptorProto_EnumReservedRange().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_EnumDescriptorProto_EnumReservedRange, a, b);
  }
};
EnumDescriptorProto_EnumReservedRange.runtime = proto2;
EnumDescriptorProto_EnumReservedRange.typeName = "google.protobuf.EnumDescriptorProto.EnumReservedRange";
EnumDescriptorProto_EnumReservedRange.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "start", kind: "scalar", T: 5, opt: true },
  { no: 2, name: "end", kind: "scalar", T: 5, opt: true }
]);
var EnumValueDescriptorProto = class _EnumValueDescriptorProto extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _EnumValueDescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _EnumValueDescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _EnumValueDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_EnumValueDescriptorProto, a, b);
  }
};
EnumValueDescriptorProto.runtime = proto2;
EnumValueDescriptorProto.typeName = "google.protobuf.EnumValueDescriptorProto";
EnumValueDescriptorProto.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "number", kind: "scalar", T: 5, opt: true },
  { no: 3, name: "options", kind: "message", T: EnumValueOptions, opt: true }
]);
var ServiceDescriptorProto = class _ServiceDescriptorProto extends Message {
  constructor(data) {
    super();
    this.method = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _ServiceDescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _ServiceDescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _ServiceDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_ServiceDescriptorProto, a, b);
  }
};
ServiceDescriptorProto.runtime = proto2;
ServiceDescriptorProto.typeName = "google.protobuf.ServiceDescriptorProto";
ServiceDescriptorProto.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "method", kind: "message", T: MethodDescriptorProto, repeated: true },
  { no: 3, name: "options", kind: "message", T: ServiceOptions, opt: true }
]);
var MethodDescriptorProto = class _MethodDescriptorProto extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _MethodDescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _MethodDescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _MethodDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_MethodDescriptorProto, a, b);
  }
};
MethodDescriptorProto.runtime = proto2;
MethodDescriptorProto.typeName = "google.protobuf.MethodDescriptorProto";
MethodDescriptorProto.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "input_type", kind: "scalar", T: 9, opt: true },
  { no: 3, name: "output_type", kind: "scalar", T: 9, opt: true },
  { no: 4, name: "options", kind: "message", T: MethodOptions, opt: true },
  { no: 5, name: "client_streaming", kind: "scalar", T: 8, opt: true, default: false },
  { no: 6, name: "server_streaming", kind: "scalar", T: 8, opt: true, default: false }
]);
var FileOptions = class _FileOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FileOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FileOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FileOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_FileOptions, a, b);
  }
};
FileOptions.runtime = proto2;
FileOptions.typeName = "google.protobuf.FileOptions";
FileOptions.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "java_package", kind: "scalar", T: 9, opt: true },
  { no: 8, name: "java_outer_classname", kind: "scalar", T: 9, opt: true },
  { no: 10, name: "java_multiple_files", kind: "scalar", T: 8, opt: true, default: false },
  { no: 20, name: "java_generate_equals_and_hash", kind: "scalar", T: 8, opt: true },
  { no: 27, name: "java_string_check_utf8", kind: "scalar", T: 8, opt: true, default: false },
  { no: 9, name: "optimize_for", kind: "enum", T: proto2.getEnumType(FileOptions_OptimizeMode), opt: true, default: FileOptions_OptimizeMode.SPEED },
  { no: 11, name: "go_package", kind: "scalar", T: 9, opt: true },
  { no: 16, name: "cc_generic_services", kind: "scalar", T: 8, opt: true, default: false },
  { no: 17, name: "java_generic_services", kind: "scalar", T: 8, opt: true, default: false },
  { no: 18, name: "py_generic_services", kind: "scalar", T: 8, opt: true, default: false },
  { no: 23, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 31, name: "cc_enable_arenas", kind: "scalar", T: 8, opt: true, default: true },
  { no: 36, name: "objc_class_prefix", kind: "scalar", T: 9, opt: true },
  { no: 37, name: "csharp_namespace", kind: "scalar", T: 9, opt: true },
  { no: 39, name: "swift_prefix", kind: "scalar", T: 9, opt: true },
  { no: 40, name: "php_class_prefix", kind: "scalar", T: 9, opt: true },
  { no: 41, name: "php_namespace", kind: "scalar", T: 9, opt: true },
  { no: 44, name: "php_metadata_namespace", kind: "scalar", T: 9, opt: true },
  { no: 45, name: "ruby_package", kind: "scalar", T: 9, opt: true },
  { no: 50, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var FileOptions_OptimizeMode;
(function(FileOptions_OptimizeMode2) {
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["SPEED"] = 1] = "SPEED";
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["CODE_SIZE"] = 2] = "CODE_SIZE";
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["LITE_RUNTIME"] = 3] = "LITE_RUNTIME";
})(FileOptions_OptimizeMode || (FileOptions_OptimizeMode = {}));
proto2.util.setEnumType(FileOptions_OptimizeMode, "google.protobuf.FileOptions.OptimizeMode", [
  { no: 1, name: "SPEED" },
  { no: 2, name: "CODE_SIZE" },
  { no: 3, name: "LITE_RUNTIME" }
]);
var MessageOptions = class _MessageOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _MessageOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _MessageOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _MessageOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_MessageOptions, a, b);
  }
};
MessageOptions.runtime = proto2;
MessageOptions.typeName = "google.protobuf.MessageOptions";
MessageOptions.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "message_set_wire_format", kind: "scalar", T: 8, opt: true, default: false },
  { no: 2, name: "no_standard_descriptor_accessor", kind: "scalar", T: 8, opt: true, default: false },
  { no: 3, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 7, name: "map_entry", kind: "scalar", T: 8, opt: true },
  { no: 11, name: "deprecated_legacy_json_field_conflicts", kind: "scalar", T: 8, opt: true },
  { no: 12, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var FieldOptions = class _FieldOptions extends Message {
  constructor(data) {
    super();
    this.targets = [];
    this.editionDefaults = [];
    this.uninterpretedOption = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FieldOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FieldOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FieldOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_FieldOptions, a, b);
  }
};
FieldOptions.runtime = proto2;
FieldOptions.typeName = "google.protobuf.FieldOptions";
FieldOptions.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "ctype", kind: "enum", T: proto2.getEnumType(FieldOptions_CType), opt: true, default: FieldOptions_CType.STRING },
  { no: 2, name: "packed", kind: "scalar", T: 8, opt: true },
  { no: 6, name: "jstype", kind: "enum", T: proto2.getEnumType(FieldOptions_JSType), opt: true, default: FieldOptions_JSType.JS_NORMAL },
  { no: 5, name: "lazy", kind: "scalar", T: 8, opt: true, default: false },
  { no: 15, name: "unverified_lazy", kind: "scalar", T: 8, opt: true, default: false },
  { no: 3, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 10, name: "weak", kind: "scalar", T: 8, opt: true, default: false },
  { no: 16, name: "debug_redact", kind: "scalar", T: 8, opt: true, default: false },
  { no: 17, name: "retention", kind: "enum", T: proto2.getEnumType(FieldOptions_OptionRetention), opt: true },
  { no: 19, name: "targets", kind: "enum", T: proto2.getEnumType(FieldOptions_OptionTargetType), repeated: true },
  { no: 20, name: "edition_defaults", kind: "message", T: FieldOptions_EditionDefault, repeated: true },
  { no: 21, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 22, name: "feature_support", kind: "message", T: FieldOptions_FeatureSupport, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var FieldOptions_CType;
(function(FieldOptions_CType2) {
  FieldOptions_CType2[FieldOptions_CType2["STRING"] = 0] = "STRING";
  FieldOptions_CType2[FieldOptions_CType2["CORD"] = 1] = "CORD";
  FieldOptions_CType2[FieldOptions_CType2["STRING_PIECE"] = 2] = "STRING_PIECE";
})(FieldOptions_CType || (FieldOptions_CType = {}));
proto2.util.setEnumType(FieldOptions_CType, "google.protobuf.FieldOptions.CType", [
  { no: 0, name: "STRING" },
  { no: 1, name: "CORD" },
  { no: 2, name: "STRING_PIECE" }
]);
var FieldOptions_JSType;
(function(FieldOptions_JSType2) {
  FieldOptions_JSType2[FieldOptions_JSType2["JS_NORMAL"] = 0] = "JS_NORMAL";
  FieldOptions_JSType2[FieldOptions_JSType2["JS_STRING"] = 1] = "JS_STRING";
  FieldOptions_JSType2[FieldOptions_JSType2["JS_NUMBER"] = 2] = "JS_NUMBER";
})(FieldOptions_JSType || (FieldOptions_JSType = {}));
proto2.util.setEnumType(FieldOptions_JSType, "google.protobuf.FieldOptions.JSType", [
  { no: 0, name: "JS_NORMAL" },
  { no: 1, name: "JS_STRING" },
  { no: 2, name: "JS_NUMBER" }
]);
var FieldOptions_OptionRetention;
(function(FieldOptions_OptionRetention2) {
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_UNKNOWN"] = 0] = "RETENTION_UNKNOWN";
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_RUNTIME"] = 1] = "RETENTION_RUNTIME";
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_SOURCE"] = 2] = "RETENTION_SOURCE";
})(FieldOptions_OptionRetention || (FieldOptions_OptionRetention = {}));
proto2.util.setEnumType(FieldOptions_OptionRetention, "google.protobuf.FieldOptions.OptionRetention", [
  { no: 0, name: "RETENTION_UNKNOWN" },
  { no: 1, name: "RETENTION_RUNTIME" },
  { no: 2, name: "RETENTION_SOURCE" }
]);
var FieldOptions_OptionTargetType;
(function(FieldOptions_OptionTargetType2) {
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_UNKNOWN"] = 0] = "TARGET_TYPE_UNKNOWN";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_FILE"] = 1] = "TARGET_TYPE_FILE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_EXTENSION_RANGE"] = 2] = "TARGET_TYPE_EXTENSION_RANGE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_MESSAGE"] = 3] = "TARGET_TYPE_MESSAGE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_FIELD"] = 4] = "TARGET_TYPE_FIELD";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ONEOF"] = 5] = "TARGET_TYPE_ONEOF";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ENUM"] = 6] = "TARGET_TYPE_ENUM";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ENUM_ENTRY"] = 7] = "TARGET_TYPE_ENUM_ENTRY";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_SERVICE"] = 8] = "TARGET_TYPE_SERVICE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_METHOD"] = 9] = "TARGET_TYPE_METHOD";
})(FieldOptions_OptionTargetType || (FieldOptions_OptionTargetType = {}));
proto2.util.setEnumType(FieldOptions_OptionTargetType, "google.protobuf.FieldOptions.OptionTargetType", [
  { no: 0, name: "TARGET_TYPE_UNKNOWN" },
  { no: 1, name: "TARGET_TYPE_FILE" },
  { no: 2, name: "TARGET_TYPE_EXTENSION_RANGE" },
  { no: 3, name: "TARGET_TYPE_MESSAGE" },
  { no: 4, name: "TARGET_TYPE_FIELD" },
  { no: 5, name: "TARGET_TYPE_ONEOF" },
  { no: 6, name: "TARGET_TYPE_ENUM" },
  { no: 7, name: "TARGET_TYPE_ENUM_ENTRY" },
  { no: 8, name: "TARGET_TYPE_SERVICE" },
  { no: 9, name: "TARGET_TYPE_METHOD" }
]);
var FieldOptions_EditionDefault = class _FieldOptions_EditionDefault extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FieldOptions_EditionDefault().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FieldOptions_EditionDefault().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FieldOptions_EditionDefault().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_FieldOptions_EditionDefault, a, b);
  }
};
FieldOptions_EditionDefault.runtime = proto2;
FieldOptions_EditionDefault.typeName = "google.protobuf.FieldOptions.EditionDefault";
FieldOptions_EditionDefault.fields = proto2.util.newFieldList(() => [
  { no: 3, name: "edition", kind: "enum", T: proto2.getEnumType(Edition), opt: true },
  { no: 2, name: "value", kind: "scalar", T: 9, opt: true }
]);
var FieldOptions_FeatureSupport = class _FieldOptions_FeatureSupport extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FieldOptions_FeatureSupport().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FieldOptions_FeatureSupport().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FieldOptions_FeatureSupport().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_FieldOptions_FeatureSupport, a, b);
  }
};
FieldOptions_FeatureSupport.runtime = proto2;
FieldOptions_FeatureSupport.typeName = "google.protobuf.FieldOptions.FeatureSupport";
FieldOptions_FeatureSupport.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "edition_introduced", kind: "enum", T: proto2.getEnumType(Edition), opt: true },
  { no: 2, name: "edition_deprecated", kind: "enum", T: proto2.getEnumType(Edition), opt: true },
  { no: 3, name: "deprecation_warning", kind: "scalar", T: 9, opt: true },
  { no: 4, name: "edition_removed", kind: "enum", T: proto2.getEnumType(Edition), opt: true }
]);
var OneofOptions = class _OneofOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _OneofOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _OneofOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _OneofOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_OneofOptions, a, b);
  }
};
OneofOptions.runtime = proto2;
OneofOptions.typeName = "google.protobuf.OneofOptions";
OneofOptions.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var EnumOptions = class _EnumOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _EnumOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _EnumOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _EnumOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_EnumOptions, a, b);
  }
};
EnumOptions.runtime = proto2;
EnumOptions.typeName = "google.protobuf.EnumOptions";
EnumOptions.fields = proto2.util.newFieldList(() => [
  { no: 2, name: "allow_alias", kind: "scalar", T: 8, opt: true },
  { no: 3, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 6, name: "deprecated_legacy_json_field_conflicts", kind: "scalar", T: 8, opt: true },
  { no: 7, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var EnumValueOptions = class _EnumValueOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _EnumValueOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _EnumValueOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _EnumValueOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_EnumValueOptions, a, b);
  }
};
EnumValueOptions.runtime = proto2;
EnumValueOptions.typeName = "google.protobuf.EnumValueOptions";
EnumValueOptions.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 2, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 3, name: "debug_redact", kind: "scalar", T: 8, opt: true, default: false },
  { no: 4, name: "feature_support", kind: "message", T: FieldOptions_FeatureSupport, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var ServiceOptions = class _ServiceOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _ServiceOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _ServiceOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _ServiceOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_ServiceOptions, a, b);
  }
};
ServiceOptions.runtime = proto2;
ServiceOptions.typeName = "google.protobuf.ServiceOptions";
ServiceOptions.fields = proto2.util.newFieldList(() => [
  { no: 34, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 33, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var MethodOptions = class _MethodOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _MethodOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _MethodOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _MethodOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_MethodOptions, a, b);
  }
};
MethodOptions.runtime = proto2;
MethodOptions.typeName = "google.protobuf.MethodOptions";
MethodOptions.fields = proto2.util.newFieldList(() => [
  { no: 33, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 34, name: "idempotency_level", kind: "enum", T: proto2.getEnumType(MethodOptions_IdempotencyLevel), opt: true, default: MethodOptions_IdempotencyLevel.IDEMPOTENCY_UNKNOWN },
  { no: 35, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var MethodOptions_IdempotencyLevel;
(function(MethodOptions_IdempotencyLevel2) {
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENCY_UNKNOWN"] = 0] = "IDEMPOTENCY_UNKNOWN";
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["NO_SIDE_EFFECTS"] = 1] = "NO_SIDE_EFFECTS";
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENT"] = 2] = "IDEMPOTENT";
})(MethodOptions_IdempotencyLevel || (MethodOptions_IdempotencyLevel = {}));
proto2.util.setEnumType(MethodOptions_IdempotencyLevel, "google.protobuf.MethodOptions.IdempotencyLevel", [
  { no: 0, name: "IDEMPOTENCY_UNKNOWN" },
  { no: 1, name: "NO_SIDE_EFFECTS" },
  { no: 2, name: "IDEMPOTENT" }
]);
var UninterpretedOption = class _UninterpretedOption extends Message {
  constructor(data) {
    super();
    this.name = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _UninterpretedOption().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _UninterpretedOption().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _UninterpretedOption().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_UninterpretedOption, a, b);
  }
};
UninterpretedOption.runtime = proto2;
UninterpretedOption.typeName = "google.protobuf.UninterpretedOption";
UninterpretedOption.fields = proto2.util.newFieldList(() => [
  { no: 2, name: "name", kind: "message", T: UninterpretedOption_NamePart, repeated: true },
  { no: 3, name: "identifier_value", kind: "scalar", T: 9, opt: true },
  { no: 4, name: "positive_int_value", kind: "scalar", T: 4, opt: true },
  { no: 5, name: "negative_int_value", kind: "scalar", T: 3, opt: true },
  { no: 6, name: "double_value", kind: "scalar", T: 1, opt: true },
  { no: 7, name: "string_value", kind: "scalar", T: 12, opt: true },
  { no: 8, name: "aggregate_value", kind: "scalar", T: 9, opt: true }
]);
var UninterpretedOption_NamePart = class _UninterpretedOption_NamePart extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _UninterpretedOption_NamePart().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _UninterpretedOption_NamePart().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _UninterpretedOption_NamePart().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_UninterpretedOption_NamePart, a, b);
  }
};
UninterpretedOption_NamePart.runtime = proto2;
UninterpretedOption_NamePart.typeName = "google.protobuf.UninterpretedOption.NamePart";
UninterpretedOption_NamePart.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "name_part", kind: "scalar", T: 9, req: true },
  { no: 2, name: "is_extension", kind: "scalar", T: 8, req: true }
]);
var FeatureSet = class _FeatureSet extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FeatureSet().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FeatureSet().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FeatureSet().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_FeatureSet, a, b);
  }
};
FeatureSet.runtime = proto2;
FeatureSet.typeName = "google.protobuf.FeatureSet";
FeatureSet.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "field_presence", kind: "enum", T: proto2.getEnumType(FeatureSet_FieldPresence), opt: true },
  { no: 2, name: "enum_type", kind: "enum", T: proto2.getEnumType(FeatureSet_EnumType), opt: true },
  { no: 3, name: "repeated_field_encoding", kind: "enum", T: proto2.getEnumType(FeatureSet_RepeatedFieldEncoding), opt: true },
  { no: 4, name: "utf8_validation", kind: "enum", T: proto2.getEnumType(FeatureSet_Utf8Validation), opt: true },
  { no: 5, name: "message_encoding", kind: "enum", T: proto2.getEnumType(FeatureSet_MessageEncoding), opt: true },
  { no: 6, name: "json_format", kind: "enum", T: proto2.getEnumType(FeatureSet_JsonFormat), opt: true }
]);
var FeatureSet_FieldPresence;
(function(FeatureSet_FieldPresence2) {
  FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["FIELD_PRESENCE_UNKNOWN"] = 0] = "FIELD_PRESENCE_UNKNOWN";
  FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["EXPLICIT"] = 1] = "EXPLICIT";
  FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["IMPLICIT"] = 2] = "IMPLICIT";
  FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["LEGACY_REQUIRED"] = 3] = "LEGACY_REQUIRED";
})(FeatureSet_FieldPresence || (FeatureSet_FieldPresence = {}));
proto2.util.setEnumType(FeatureSet_FieldPresence, "google.protobuf.FeatureSet.FieldPresence", [
  { no: 0, name: "FIELD_PRESENCE_UNKNOWN" },
  { no: 1, name: "EXPLICIT" },
  { no: 2, name: "IMPLICIT" },
  { no: 3, name: "LEGACY_REQUIRED" }
]);
var FeatureSet_EnumType;
(function(FeatureSet_EnumType2) {
  FeatureSet_EnumType2[FeatureSet_EnumType2["ENUM_TYPE_UNKNOWN"] = 0] = "ENUM_TYPE_UNKNOWN";
  FeatureSet_EnumType2[FeatureSet_EnumType2["OPEN"] = 1] = "OPEN";
  FeatureSet_EnumType2[FeatureSet_EnumType2["CLOSED"] = 2] = "CLOSED";
})(FeatureSet_EnumType || (FeatureSet_EnumType = {}));
proto2.util.setEnumType(FeatureSet_EnumType, "google.protobuf.FeatureSet.EnumType", [
  { no: 0, name: "ENUM_TYPE_UNKNOWN" },
  { no: 1, name: "OPEN" },
  { no: 2, name: "CLOSED" }
]);
var FeatureSet_RepeatedFieldEncoding;
(function(FeatureSet_RepeatedFieldEncoding2) {
  FeatureSet_RepeatedFieldEncoding2[FeatureSet_RepeatedFieldEncoding2["REPEATED_FIELD_ENCODING_UNKNOWN"] = 0] = "REPEATED_FIELD_ENCODING_UNKNOWN";
  FeatureSet_RepeatedFieldEncoding2[FeatureSet_RepeatedFieldEncoding2["PACKED"] = 1] = "PACKED";
  FeatureSet_RepeatedFieldEncoding2[FeatureSet_RepeatedFieldEncoding2["EXPANDED"] = 2] = "EXPANDED";
})(FeatureSet_RepeatedFieldEncoding || (FeatureSet_RepeatedFieldEncoding = {}));
proto2.util.setEnumType(FeatureSet_RepeatedFieldEncoding, "google.protobuf.FeatureSet.RepeatedFieldEncoding", [
  { no: 0, name: "REPEATED_FIELD_ENCODING_UNKNOWN" },
  { no: 1, name: "PACKED" },
  { no: 2, name: "EXPANDED" }
]);
var FeatureSet_Utf8Validation;
(function(FeatureSet_Utf8Validation2) {
  FeatureSet_Utf8Validation2[FeatureSet_Utf8Validation2["UTF8_VALIDATION_UNKNOWN"] = 0] = "UTF8_VALIDATION_UNKNOWN";
  FeatureSet_Utf8Validation2[FeatureSet_Utf8Validation2["VERIFY"] = 2] = "VERIFY";
  FeatureSet_Utf8Validation2[FeatureSet_Utf8Validation2["NONE"] = 3] = "NONE";
})(FeatureSet_Utf8Validation || (FeatureSet_Utf8Validation = {}));
proto2.util.setEnumType(FeatureSet_Utf8Validation, "google.protobuf.FeatureSet.Utf8Validation", [
  { no: 0, name: "UTF8_VALIDATION_UNKNOWN" },
  { no: 2, name: "VERIFY" },
  { no: 3, name: "NONE" }
]);
var FeatureSet_MessageEncoding;
(function(FeatureSet_MessageEncoding2) {
  FeatureSet_MessageEncoding2[FeatureSet_MessageEncoding2["MESSAGE_ENCODING_UNKNOWN"] = 0] = "MESSAGE_ENCODING_UNKNOWN";
  FeatureSet_MessageEncoding2[FeatureSet_MessageEncoding2["LENGTH_PREFIXED"] = 1] = "LENGTH_PREFIXED";
  FeatureSet_MessageEncoding2[FeatureSet_MessageEncoding2["DELIMITED"] = 2] = "DELIMITED";
})(FeatureSet_MessageEncoding || (FeatureSet_MessageEncoding = {}));
proto2.util.setEnumType(FeatureSet_MessageEncoding, "google.protobuf.FeatureSet.MessageEncoding", [
  { no: 0, name: "MESSAGE_ENCODING_UNKNOWN" },
  { no: 1, name: "LENGTH_PREFIXED" },
  { no: 2, name: "DELIMITED" }
]);
var FeatureSet_JsonFormat;
(function(FeatureSet_JsonFormat2) {
  FeatureSet_JsonFormat2[FeatureSet_JsonFormat2["JSON_FORMAT_UNKNOWN"] = 0] = "JSON_FORMAT_UNKNOWN";
  FeatureSet_JsonFormat2[FeatureSet_JsonFormat2["ALLOW"] = 1] = "ALLOW";
  FeatureSet_JsonFormat2[FeatureSet_JsonFormat2["LEGACY_BEST_EFFORT"] = 2] = "LEGACY_BEST_EFFORT";
})(FeatureSet_JsonFormat || (FeatureSet_JsonFormat = {}));
proto2.util.setEnumType(FeatureSet_JsonFormat, "google.protobuf.FeatureSet.JsonFormat", [
  { no: 0, name: "JSON_FORMAT_UNKNOWN" },
  { no: 1, name: "ALLOW" },
  { no: 2, name: "LEGACY_BEST_EFFORT" }
]);
var FeatureSetDefaults = class _FeatureSetDefaults extends Message {
  constructor(data) {
    super();
    this.defaults = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FeatureSetDefaults().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FeatureSetDefaults().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FeatureSetDefaults().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_FeatureSetDefaults, a, b);
  }
};
FeatureSetDefaults.runtime = proto2;
FeatureSetDefaults.typeName = "google.protobuf.FeatureSetDefaults";
FeatureSetDefaults.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "defaults", kind: "message", T: FeatureSetDefaults_FeatureSetEditionDefault, repeated: true },
  { no: 4, name: "minimum_edition", kind: "enum", T: proto2.getEnumType(Edition), opt: true },
  { no: 5, name: "maximum_edition", kind: "enum", T: proto2.getEnumType(Edition), opt: true }
]);
var FeatureSetDefaults_FeatureSetEditionDefault = class _FeatureSetDefaults_FeatureSetEditionDefault extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FeatureSetDefaults_FeatureSetEditionDefault().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FeatureSetDefaults_FeatureSetEditionDefault().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FeatureSetDefaults_FeatureSetEditionDefault().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_FeatureSetDefaults_FeatureSetEditionDefault, a, b);
  }
};
FeatureSetDefaults_FeatureSetEditionDefault.runtime = proto2;
FeatureSetDefaults_FeatureSetEditionDefault.typeName = "google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault";
FeatureSetDefaults_FeatureSetEditionDefault.fields = proto2.util.newFieldList(() => [
  { no: 3, name: "edition", kind: "enum", T: proto2.getEnumType(Edition), opt: true },
  { no: 4, name: "overridable_features", kind: "message", T: FeatureSet, opt: true },
  { no: 5, name: "fixed_features", kind: "message", T: FeatureSet, opt: true }
]);
var SourceCodeInfo = class _SourceCodeInfo extends Message {
  constructor(data) {
    super();
    this.location = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _SourceCodeInfo().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _SourceCodeInfo().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _SourceCodeInfo().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_SourceCodeInfo, a, b);
  }
};
SourceCodeInfo.runtime = proto2;
SourceCodeInfo.typeName = "google.protobuf.SourceCodeInfo";
SourceCodeInfo.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "location", kind: "message", T: SourceCodeInfo_Location, repeated: true }
]);
var SourceCodeInfo_Location = class _SourceCodeInfo_Location extends Message {
  constructor(data) {
    super();
    this.path = [];
    this.span = [];
    this.leadingDetachedComments = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _SourceCodeInfo_Location().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _SourceCodeInfo_Location().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _SourceCodeInfo_Location().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_SourceCodeInfo_Location, a, b);
  }
};
SourceCodeInfo_Location.runtime = proto2;
SourceCodeInfo_Location.typeName = "google.protobuf.SourceCodeInfo.Location";
SourceCodeInfo_Location.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "path", kind: "scalar", T: 5, repeated: true, packed: true },
  { no: 2, name: "span", kind: "scalar", T: 5, repeated: true, packed: true },
  { no: 3, name: "leading_comments", kind: "scalar", T: 9, opt: true },
  { no: 4, name: "trailing_comments", kind: "scalar", T: 9, opt: true },
  { no: 6, name: "leading_detached_comments", kind: "scalar", T: 9, repeated: true }
]);
var GeneratedCodeInfo = class _GeneratedCodeInfo extends Message {
  constructor(data) {
    super();
    this.annotation = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _GeneratedCodeInfo().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _GeneratedCodeInfo().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _GeneratedCodeInfo().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_GeneratedCodeInfo, a, b);
  }
};
GeneratedCodeInfo.runtime = proto2;
GeneratedCodeInfo.typeName = "google.protobuf.GeneratedCodeInfo";
GeneratedCodeInfo.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "annotation", kind: "message", T: GeneratedCodeInfo_Annotation, repeated: true }
]);
var GeneratedCodeInfo_Annotation = class _GeneratedCodeInfo_Annotation extends Message {
  constructor(data) {
    super();
    this.path = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _GeneratedCodeInfo_Annotation().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _GeneratedCodeInfo_Annotation().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _GeneratedCodeInfo_Annotation().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_GeneratedCodeInfo_Annotation, a, b);
  }
};
GeneratedCodeInfo_Annotation.runtime = proto2;
GeneratedCodeInfo_Annotation.typeName = "google.protobuf.GeneratedCodeInfo.Annotation";
GeneratedCodeInfo_Annotation.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "path", kind: "scalar", T: 5, repeated: true, packed: true },
  { no: 2, name: "source_file", kind: "scalar", T: 9, opt: true },
  { no: 3, name: "begin", kind: "scalar", T: 5, opt: true },
  { no: 4, name: "end", kind: "scalar", T: 5, opt: true },
  { no: 5, name: "semantic", kind: "enum", T: proto2.getEnumType(GeneratedCodeInfo_Annotation_Semantic), opt: true }
]);
var GeneratedCodeInfo_Annotation_Semantic;
(function(GeneratedCodeInfo_Annotation_Semantic2) {
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["NONE"] = 0] = "NONE";
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["SET"] = 1] = "SET";
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["ALIAS"] = 2] = "ALIAS";
})(GeneratedCodeInfo_Annotation_Semantic || (GeneratedCodeInfo_Annotation_Semantic = {}));
proto2.util.setEnumType(GeneratedCodeInfo_Annotation_Semantic, "google.protobuf.GeneratedCodeInfo.Annotation.Semantic", [
  { no: 0, name: "NONE" },
  { no: 1, name: "SET" },
  { no: 2, name: "ALIAS" }
]);

// node_modules/@bufbuild/protobuf/dist/esm/create-descriptor-set.js
var fieldTypeToScalarType = {
  [FieldDescriptorProto_Type.DOUBLE]: ScalarType.DOUBLE,
  [FieldDescriptorProto_Type.FLOAT]: ScalarType.FLOAT,
  [FieldDescriptorProto_Type.INT64]: ScalarType.INT64,
  [FieldDescriptorProto_Type.UINT64]: ScalarType.UINT64,
  [FieldDescriptorProto_Type.INT32]: ScalarType.INT32,
  [FieldDescriptorProto_Type.FIXED64]: ScalarType.FIXED64,
  [FieldDescriptorProto_Type.FIXED32]: ScalarType.FIXED32,
  [FieldDescriptorProto_Type.BOOL]: ScalarType.BOOL,
  [FieldDescriptorProto_Type.STRING]: ScalarType.STRING,
  [FieldDescriptorProto_Type.GROUP]: void 0,
  [FieldDescriptorProto_Type.MESSAGE]: void 0,
  [FieldDescriptorProto_Type.BYTES]: ScalarType.BYTES,
  [FieldDescriptorProto_Type.UINT32]: ScalarType.UINT32,
  [FieldDescriptorProto_Type.ENUM]: void 0,
  [FieldDescriptorProto_Type.SFIXED32]: ScalarType.SFIXED32,
  [FieldDescriptorProto_Type.SFIXED64]: ScalarType.SFIXED64,
  [FieldDescriptorProto_Type.SINT32]: ScalarType.SINT32,
  [FieldDescriptorProto_Type.SINT64]: ScalarType.SINT64
};
var FieldNumber;
(function(FieldNumber2) {
  FieldNumber2[FieldNumber2["FileDescriptorProto_Package"] = 2] = "FileDescriptorProto_Package";
  FieldNumber2[FieldNumber2["FileDescriptorProto_MessageType"] = 4] = "FileDescriptorProto_MessageType";
  FieldNumber2[FieldNumber2["FileDescriptorProto_EnumType"] = 5] = "FileDescriptorProto_EnumType";
  FieldNumber2[FieldNumber2["FileDescriptorProto_Service"] = 6] = "FileDescriptorProto_Service";
  FieldNumber2[FieldNumber2["FileDescriptorProto_Extension"] = 7] = "FileDescriptorProto_Extension";
  FieldNumber2[FieldNumber2["FileDescriptorProto_Syntax"] = 12] = "FileDescriptorProto_Syntax";
  FieldNumber2[FieldNumber2["DescriptorProto_Field"] = 2] = "DescriptorProto_Field";
  FieldNumber2[FieldNumber2["DescriptorProto_NestedType"] = 3] = "DescriptorProto_NestedType";
  FieldNumber2[FieldNumber2["DescriptorProto_EnumType"] = 4] = "DescriptorProto_EnumType";
  FieldNumber2[FieldNumber2["DescriptorProto_Extension"] = 6] = "DescriptorProto_Extension";
  FieldNumber2[FieldNumber2["DescriptorProto_OneofDecl"] = 8] = "DescriptorProto_OneofDecl";
  FieldNumber2[FieldNumber2["EnumDescriptorProto_Value"] = 2] = "EnumDescriptorProto_Value";
  FieldNumber2[FieldNumber2["ServiceDescriptorProto_Method"] = 2] = "ServiceDescriptorProto_Method";
})(FieldNumber || (FieldNumber = {}));

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/timestamp_pb.js
var Timestamp = class _Timestamp extends Message {
  constructor(data) {
    super();
    this.seconds = protoInt64.zero;
    this.nanos = 0;
    proto3.util.initPartial(data, this);
  }
  fromJson(json, options) {
    if (typeof json !== "string") {
      throw new Error(`cannot decode google.protobuf.Timestamp from JSON: ${proto3.json.debug(json)}`);
    }
    const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
    if (!matches) {
      throw new Error(`cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string`);
    }
    const ms = Date.parse(matches[1] + "-" + matches[2] + "-" + matches[3] + "T" + matches[4] + ":" + matches[5] + ":" + matches[6] + (matches[8] ? matches[8] : "Z"));
    if (Number.isNaN(ms)) {
      throw new Error(`cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string`);
    }
    if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
      throw new Error(`cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
    }
    this.seconds = protoInt64.parse(ms / 1e3);
    this.nanos = 0;
    if (matches[7]) {
      this.nanos = parseInt("1" + matches[7] + "0".repeat(9 - matches[7].length)) - 1e9;
    }
    return this;
  }
  toJson(options) {
    const ms = Number(this.seconds) * 1e3;
    if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
      throw new Error(`cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
    }
    if (this.nanos < 0) {
      throw new Error(`cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative`);
    }
    let z = "Z";
    if (this.nanos > 0) {
      const nanosStr = (this.nanos + 1e9).toString().substring(1);
      if (nanosStr.substring(3) === "000000") {
        z = "." + nanosStr.substring(0, 3) + "Z";
      } else if (nanosStr.substring(6) === "000") {
        z = "." + nanosStr.substring(0, 6) + "Z";
      } else {
        z = "." + nanosStr + "Z";
      }
    }
    return new Date(ms).toISOString().replace(".000Z", z);
  }
  toDate() {
    return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));
  }
  static now() {
    return _Timestamp.fromDate(/* @__PURE__ */ new Date());
  }
  static fromDate(date) {
    const ms = date.getTime();
    return new _Timestamp({
      seconds: protoInt64.parse(Math.floor(ms / 1e3)),
      nanos: ms % 1e3 * 1e6
    });
  }
  static fromBinary(bytes, options) {
    return new _Timestamp().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Timestamp().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Timestamp().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Timestamp, a, b);
  }
};
Timestamp.runtime = proto3;
Timestamp.typeName = "google.protobuf.Timestamp";
Timestamp.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "seconds",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  },
  {
    no: 2,
    name: "nanos",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/duration_pb.js
var Duration = class _Duration extends Message {
  constructor(data) {
    super();
    this.seconds = protoInt64.zero;
    this.nanos = 0;
    proto3.util.initPartial(data, this);
  }
  fromJson(json, options) {
    if (typeof json !== "string") {
      throw new Error(`cannot decode google.protobuf.Duration from JSON: ${proto3.json.debug(json)}`);
    }
    const match = json.match(/^(-?[0-9]+)(?:\.([0-9]+))?s/);
    if (match === null) {
      throw new Error(`cannot decode google.protobuf.Duration from JSON: ${proto3.json.debug(json)}`);
    }
    const longSeconds = Number(match[1]);
    if (longSeconds > 315576e6 || longSeconds < -315576e6) {
      throw new Error(`cannot decode google.protobuf.Duration from JSON: ${proto3.json.debug(json)}`);
    }
    this.seconds = protoInt64.parse(longSeconds);
    if (typeof match[2] == "string") {
      const nanosStr = match[2] + "0".repeat(9 - match[2].length);
      this.nanos = parseInt(nanosStr);
      if (longSeconds < 0 || Object.is(longSeconds, -0)) {
        this.nanos = -this.nanos;
      }
    }
    return this;
  }
  toJson(options) {
    if (Number(this.seconds) > 315576e6 || Number(this.seconds) < -315576e6) {
      throw new Error(`cannot encode google.protobuf.Duration to JSON: value out of range`);
    }
    let text = this.seconds.toString();
    if (this.nanos !== 0) {
      let nanosStr = Math.abs(this.nanos).toString();
      nanosStr = "0".repeat(9 - nanosStr.length) + nanosStr;
      if (nanosStr.substring(3) === "000000") {
        nanosStr = nanosStr.substring(0, 3);
      } else if (nanosStr.substring(6) === "000") {
        nanosStr = nanosStr.substring(0, 6);
      }
      text += "." + nanosStr;
      if (this.nanos < 0 && Number(this.seconds) == 0) {
        text = "-" + text;
      }
    }
    return text + "s";
  }
  static fromBinary(bytes, options) {
    return new _Duration().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Duration().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Duration().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Duration, a, b);
  }
};
Duration.runtime = proto3;
Duration.typeName = "google.protobuf.Duration";
Duration.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "seconds",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  },
  {
    no: 2,
    name: "nanos",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/any_pb.js
var Any = class _Any extends Message {
  constructor(data) {
    super();
    this.typeUrl = "";
    this.value = new Uint8Array(0);
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    var _a2;
    if (this.typeUrl === "") {
      return {};
    }
    const typeName = this.typeUrlToName(this.typeUrl);
    const messageType = (_a2 = options === null || options === void 0 ? void 0 : options.typeRegistry) === null || _a2 === void 0 ? void 0 : _a2.findMessage(typeName);
    if (!messageType) {
      throw new Error(`cannot encode message google.protobuf.Any to JSON: "${this.typeUrl}" is not in the type registry`);
    }
    const message2 = messageType.fromBinary(this.value);
    let json = message2.toJson(options);
    if (typeName.startsWith("google.protobuf.") || (json === null || Array.isArray(json) || typeof json !== "object")) {
      json = { value: json };
    }
    json["@type"] = this.typeUrl;
    return json;
  }
  fromJson(json, options) {
    var _a2;
    if (json === null || Array.isArray(json) || typeof json != "object") {
      throw new Error(`cannot decode message google.protobuf.Any from JSON: expected object but got ${json === null ? "null" : Array.isArray(json) ? "array" : typeof json}`);
    }
    if (Object.keys(json).length == 0) {
      return this;
    }
    const typeUrl = json["@type"];
    if (typeof typeUrl != "string" || typeUrl == "") {
      throw new Error(`cannot decode message google.protobuf.Any from JSON: "@type" is empty`);
    }
    const typeName = this.typeUrlToName(typeUrl), messageType = (_a2 = options === null || options === void 0 ? void 0 : options.typeRegistry) === null || _a2 === void 0 ? void 0 : _a2.findMessage(typeName);
    if (!messageType) {
      throw new Error(`cannot decode message google.protobuf.Any from JSON: ${typeUrl} is not in the type registry`);
    }
    let message2;
    if (typeName.startsWith("google.protobuf.") && Object.prototype.hasOwnProperty.call(json, "value")) {
      message2 = messageType.fromJson(json["value"], options);
    } else {
      const copy = Object.assign({}, json);
      delete copy["@type"];
      message2 = messageType.fromJson(copy, options);
    }
    this.packFrom(message2);
    return this;
  }
  packFrom(message2) {
    this.value = message2.toBinary();
    this.typeUrl = this.typeNameToUrl(message2.getType().typeName);
  }
  unpackTo(target) {
    if (!this.is(target.getType())) {
      return false;
    }
    target.fromBinary(this.value);
    return true;
  }
  unpack(registry) {
    if (this.typeUrl === "") {
      return void 0;
    }
    const messageType = registry.findMessage(this.typeUrlToName(this.typeUrl));
    if (!messageType) {
      return void 0;
    }
    return messageType.fromBinary(this.value);
  }
  is(type) {
    if (this.typeUrl === "") {
      return false;
    }
    const name = this.typeUrlToName(this.typeUrl);
    let typeName = "";
    if (typeof type === "string") {
      typeName = type;
    } else {
      typeName = type.typeName;
    }
    return name === typeName;
  }
  typeNameToUrl(name) {
    return `type.googleapis.com/${name}`;
  }
  typeUrlToName(url) {
    if (!url.length) {
      throw new Error(`invalid type url: ${url}`);
    }
    const slash = url.lastIndexOf("/");
    const name = slash >= 0 ? url.substring(slash + 1) : url;
    if (!name.length) {
      throw new Error(`invalid type url: ${url}`);
    }
    return name;
  }
  static pack(message2) {
    const any = new _Any();
    any.packFrom(message2);
    return any;
  }
  static fromBinary(bytes, options) {
    return new _Any().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Any().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Any().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Any, a, b);
  }
};
Any.runtime = proto3;
Any.typeName = "google.protobuf.Any";
Any.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "type_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "value",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/empty_pb.js
var Empty = class _Empty extends Message {
  constructor(data) {
    super();
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Empty().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Empty().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Empty().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Empty, a, b);
  }
};
Empty.runtime = proto3;
Empty.typeName = "google.protobuf.Empty";
Empty.fields = proto3.util.newFieldList(() => []);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/field_mask_pb.js
var FieldMask = class _FieldMask extends Message {
  constructor(data) {
    super();
    this.paths = [];
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    function protoCamelCase2(snakeCase) {
      let capNext = false;
      const b = [];
      for (let i = 0; i < snakeCase.length; i++) {
        let c = snakeCase.charAt(i);
        switch (c) {
          case "_":
            capNext = true;
            break;
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            b.push(c);
            capNext = false;
            break;
          default:
            if (capNext) {
              capNext = false;
              c = c.toUpperCase();
            }
            b.push(c);
            break;
        }
      }
      return b.join("");
    }
    return this.paths.map((p) => {
      if (p.match(/_[0-9]?_/g) || p.match(/[A-Z]/g)) {
        throw new Error('cannot encode google.protobuf.FieldMask to JSON: lowerCamelCase of path name "' + p + '" is irreversible');
      }
      return protoCamelCase2(p);
    }).join(",");
  }
  fromJson(json, options) {
    if (typeof json !== "string") {
      throw new Error("cannot decode google.protobuf.FieldMask from JSON: " + proto3.json.debug(json));
    }
    if (json === "") {
      return this;
    }
    function camelToSnake(str) {
      if (str.includes("_")) {
        throw new Error("cannot decode google.protobuf.FieldMask from JSON: path names must be lowerCamelCase");
      }
      const sc = str.replace(/[A-Z]/g, (letter) => "_" + letter.toLowerCase());
      return sc[0] === "_" ? sc.substring(1) : sc;
    }
    this.paths = json.split(",").map(camelToSnake);
    return this;
  }
  static fromBinary(bytes, options) {
    return new _FieldMask().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FieldMask().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FieldMask().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_FieldMask, a, b);
  }
};
FieldMask.runtime = proto3;
FieldMask.typeName = "google.protobuf.FieldMask";
FieldMask.fields = proto3.util.newFieldList(() => [
  { no: 1, name: "paths", kind: "scalar", T: 9, repeated: true }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/struct_pb.js
var NullValue;
(function(NullValue2) {
  NullValue2[NullValue2["NULL_VALUE"] = 0] = "NULL_VALUE";
})(NullValue || (NullValue = {}));
proto3.util.setEnumType(NullValue, "google.protobuf.NullValue", [
  { no: 0, name: "NULL_VALUE" }
]);
var Struct = class _Struct extends Message {
  constructor(data) {
    super();
    this.fields = {};
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    const json = {};
    for (const [k, v] of Object.entries(this.fields)) {
      json[k] = v.toJson(options);
    }
    return json;
  }
  fromJson(json, options) {
    if (typeof json != "object" || json == null || Array.isArray(json)) {
      throw new Error("cannot decode google.protobuf.Struct from JSON " + proto3.json.debug(json));
    }
    for (const [k, v] of Object.entries(json)) {
      this.fields[k] = Value.fromJson(v);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _Struct().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Struct().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Struct().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Struct, a, b);
  }
};
Struct.runtime = proto3;
Struct.typeName = "google.protobuf.Struct";
Struct.fields = proto3.util.newFieldList(() => [
  { no: 1, name: "fields", kind: "map", K: 9, V: { kind: "message", T: Value } }
]);
var Value = class _Value extends Message {
  constructor(data) {
    super();
    this.kind = { case: void 0 };
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    switch (this.kind.case) {
      case "nullValue":
        return null;
      case "numberValue":
        if (!Number.isFinite(this.kind.value)) {
          throw new Error("google.protobuf.Value cannot be NaN or Infinity");
        }
        return this.kind.value;
      case "boolValue":
        return this.kind.value;
      case "stringValue":
        return this.kind.value;
      case "structValue":
      case "listValue":
        return this.kind.value.toJson(Object.assign(Object.assign({}, options), { emitDefaultValues: true }));
    }
    throw new Error("google.protobuf.Value must have a value");
  }
  fromJson(json, options) {
    switch (typeof json) {
      case "number":
        this.kind = { case: "numberValue", value: json };
        break;
      case "string":
        this.kind = { case: "stringValue", value: json };
        break;
      case "boolean":
        this.kind = { case: "boolValue", value: json };
        break;
      case "object":
        if (json === null) {
          this.kind = { case: "nullValue", value: NullValue.NULL_VALUE };
        } else if (Array.isArray(json)) {
          this.kind = { case: "listValue", value: ListValue.fromJson(json) };
        } else {
          this.kind = { case: "structValue", value: Struct.fromJson(json) };
        }
        break;
      default:
        throw new Error("cannot decode google.protobuf.Value from JSON " + proto3.json.debug(json));
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _Value().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Value().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Value().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Value, a, b);
  }
};
Value.runtime = proto3;
Value.typeName = "google.protobuf.Value";
Value.fields = proto3.util.newFieldList(() => [
  { no: 1, name: "null_value", kind: "enum", T: proto3.getEnumType(NullValue), oneof: "kind" },
  { no: 2, name: "number_value", kind: "scalar", T: 1, oneof: "kind" },
  { no: 3, name: "string_value", kind: "scalar", T: 9, oneof: "kind" },
  { no: 4, name: "bool_value", kind: "scalar", T: 8, oneof: "kind" },
  { no: 5, name: "struct_value", kind: "message", T: Struct, oneof: "kind" },
  { no: 6, name: "list_value", kind: "message", T: ListValue, oneof: "kind" }
]);
var ListValue = class _ListValue extends Message {
  constructor(data) {
    super();
    this.values = [];
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return this.values.map((v) => v.toJson());
  }
  fromJson(json, options) {
    if (!Array.isArray(json)) {
      throw new Error("cannot decode google.protobuf.ListValue from JSON " + proto3.json.debug(json));
    }
    for (let e of json) {
      this.values.push(Value.fromJson(e));
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _ListValue().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _ListValue().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _ListValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_ListValue, a, b);
  }
};
ListValue.runtime = proto3;
ListValue.typeName = "google.protobuf.ListValue";
ListValue.fields = proto3.util.newFieldList(() => [
  { no: 1, name: "values", kind: "message", T: Value, repeated: true }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/wrappers_pb.js
var DoubleValue = class _DoubleValue extends Message {
  constructor(data) {
    super();
    this.value = 0;
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3.json.writeScalar(ScalarType.DOUBLE, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3.json.readScalar(ScalarType.DOUBLE, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.DoubleValue from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _DoubleValue().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _DoubleValue().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _DoubleValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_DoubleValue, a, b);
  }
};
DoubleValue.runtime = proto3;
DoubleValue.typeName = "google.protobuf.DoubleValue";
DoubleValue.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 1
    /* ScalarType.DOUBLE */
  }
]);
DoubleValue.fieldWrapper = {
  wrapField(value) {
    return new DoubleValue({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
var FloatValue = class _FloatValue extends Message {
  constructor(data) {
    super();
    this.value = 0;
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3.json.writeScalar(ScalarType.FLOAT, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3.json.readScalar(ScalarType.FLOAT, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.FloatValue from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _FloatValue().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FloatValue().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FloatValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_FloatValue, a, b);
  }
};
FloatValue.runtime = proto3;
FloatValue.typeName = "google.protobuf.FloatValue";
FloatValue.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 2
    /* ScalarType.FLOAT */
  }
]);
FloatValue.fieldWrapper = {
  wrapField(value) {
    return new FloatValue({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
var Int64Value = class _Int64Value extends Message {
  constructor(data) {
    super();
    this.value = protoInt64.zero;
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3.json.writeScalar(ScalarType.INT64, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3.json.readScalar(ScalarType.INT64, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.Int64Value from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _Int64Value().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Int64Value().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Int64Value().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Int64Value, a, b);
  }
};
Int64Value.runtime = proto3;
Int64Value.typeName = "google.protobuf.Int64Value";
Int64Value.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }
]);
Int64Value.fieldWrapper = {
  wrapField(value) {
    return new Int64Value({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
var UInt64Value = class _UInt64Value extends Message {
  constructor(data) {
    super();
    this.value = protoInt64.zero;
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3.json.writeScalar(ScalarType.UINT64, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3.json.readScalar(ScalarType.UINT64, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.UInt64Value from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _UInt64Value().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _UInt64Value().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _UInt64Value().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_UInt64Value, a, b);
  }
};
UInt64Value.runtime = proto3;
UInt64Value.typeName = "google.protobuf.UInt64Value";
UInt64Value.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }
]);
UInt64Value.fieldWrapper = {
  wrapField(value) {
    return new UInt64Value({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
var Int32Value = class _Int32Value extends Message {
  constructor(data) {
    super();
    this.value = 0;
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3.json.writeScalar(ScalarType.INT32, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3.json.readScalar(ScalarType.INT32, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.Int32Value from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _Int32Value().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Int32Value().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Int32Value().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Int32Value, a, b);
  }
};
Int32Value.runtime = proto3;
Int32Value.typeName = "google.protobuf.Int32Value";
Int32Value.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }
]);
Int32Value.fieldWrapper = {
  wrapField(value) {
    return new Int32Value({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
var UInt32Value = class _UInt32Value extends Message {
  constructor(data) {
    super();
    this.value = 0;
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3.json.writeScalar(ScalarType.UINT32, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3.json.readScalar(ScalarType.UINT32, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.UInt32Value from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _UInt32Value().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _UInt32Value().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _UInt32Value().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_UInt32Value, a, b);
  }
};
UInt32Value.runtime = proto3;
UInt32Value.typeName = "google.protobuf.UInt32Value";
UInt32Value.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }
]);
UInt32Value.fieldWrapper = {
  wrapField(value) {
    return new UInt32Value({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
var BoolValue = class _BoolValue extends Message {
  constructor(data) {
    super();
    this.value = false;
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3.json.writeScalar(ScalarType.BOOL, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3.json.readScalar(ScalarType.BOOL, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.BoolValue from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _BoolValue().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _BoolValue().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _BoolValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_BoolValue, a, b);
  }
};
BoolValue.runtime = proto3;
BoolValue.typeName = "google.protobuf.BoolValue";
BoolValue.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }
]);
BoolValue.fieldWrapper = {
  wrapField(value) {
    return new BoolValue({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
var StringValue = class _StringValue extends Message {
  constructor(data) {
    super();
    this.value = "";
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3.json.writeScalar(ScalarType.STRING, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3.json.readScalar(ScalarType.STRING, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.StringValue from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _StringValue().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _StringValue().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _StringValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_StringValue, a, b);
  }
};
StringValue.runtime = proto3;
StringValue.typeName = "google.protobuf.StringValue";
StringValue.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
StringValue.fieldWrapper = {
  wrapField(value) {
    return new StringValue({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
var BytesValue = class _BytesValue extends Message {
  constructor(data) {
    super();
    this.value = new Uint8Array(0);
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3.json.writeScalar(ScalarType.BYTES, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3.json.readScalar(ScalarType.BYTES, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.BytesValue from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _BytesValue().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _BytesValue().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _BytesValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_BytesValue, a, b);
  }
};
BytesValue.runtime = proto3;
BytesValue.typeName = "google.protobuf.BytesValue";
BytesValue.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }
]);
BytesValue.fieldWrapper = {
  wrapField(value) {
    return new BytesValue({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/create-registry-from-desc.js
var wkEnums = [getEnumType(NullValue)];

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/compiler/plugin_pb.js
var Version = class _Version extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Version().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Version().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Version().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_Version, a, b);
  }
};
Version.runtime = proto2;
Version.typeName = "google.protobuf.compiler.Version";
Version.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "major", kind: "scalar", T: 5, opt: true },
  { no: 2, name: "minor", kind: "scalar", T: 5, opt: true },
  { no: 3, name: "patch", kind: "scalar", T: 5, opt: true },
  { no: 4, name: "suffix", kind: "scalar", T: 9, opt: true }
]);
var CodeGeneratorRequest = class _CodeGeneratorRequest extends Message {
  constructor(data) {
    super();
    this.fileToGenerate = [];
    this.protoFile = [];
    this.sourceFileDescriptors = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _CodeGeneratorRequest().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _CodeGeneratorRequest().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _CodeGeneratorRequest().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_CodeGeneratorRequest, a, b);
  }
};
CodeGeneratorRequest.runtime = proto2;
CodeGeneratorRequest.typeName = "google.protobuf.compiler.CodeGeneratorRequest";
CodeGeneratorRequest.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "file_to_generate", kind: "scalar", T: 9, repeated: true },
  { no: 2, name: "parameter", kind: "scalar", T: 9, opt: true },
  { no: 15, name: "proto_file", kind: "message", T: FileDescriptorProto, repeated: true },
  { no: 17, name: "source_file_descriptors", kind: "message", T: FileDescriptorProto, repeated: true },
  { no: 3, name: "compiler_version", kind: "message", T: Version, opt: true }
]);
var CodeGeneratorResponse = class _CodeGeneratorResponse extends Message {
  constructor(data) {
    super();
    this.file = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _CodeGeneratorResponse().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _CodeGeneratorResponse().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _CodeGeneratorResponse().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_CodeGeneratorResponse, a, b);
  }
};
CodeGeneratorResponse.runtime = proto2;
CodeGeneratorResponse.typeName = "google.protobuf.compiler.CodeGeneratorResponse";
CodeGeneratorResponse.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "error", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "supported_features", kind: "scalar", T: 4, opt: true },
  { no: 3, name: "minimum_edition", kind: "scalar", T: 5, opt: true },
  { no: 4, name: "maximum_edition", kind: "scalar", T: 5, opt: true },
  { no: 15, name: "file", kind: "message", T: CodeGeneratorResponse_File, repeated: true }
]);
var CodeGeneratorResponse_Feature;
(function(CodeGeneratorResponse_Feature2) {
  CodeGeneratorResponse_Feature2[CodeGeneratorResponse_Feature2["NONE"] = 0] = "NONE";
  CodeGeneratorResponse_Feature2[CodeGeneratorResponse_Feature2["PROTO3_OPTIONAL"] = 1] = "PROTO3_OPTIONAL";
  CodeGeneratorResponse_Feature2[CodeGeneratorResponse_Feature2["SUPPORTS_EDITIONS"] = 2] = "SUPPORTS_EDITIONS";
})(CodeGeneratorResponse_Feature || (CodeGeneratorResponse_Feature = {}));
proto2.util.setEnumType(CodeGeneratorResponse_Feature, "google.protobuf.compiler.CodeGeneratorResponse.Feature", [
  { no: 0, name: "FEATURE_NONE" },
  { no: 1, name: "FEATURE_PROTO3_OPTIONAL" },
  { no: 2, name: "FEATURE_SUPPORTS_EDITIONS" }
]);
var CodeGeneratorResponse_File = class _CodeGeneratorResponse_File extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _CodeGeneratorResponse_File().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _CodeGeneratorResponse_File().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _CodeGeneratorResponse_File().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_CodeGeneratorResponse_File, a, b);
  }
};
CodeGeneratorResponse_File.runtime = proto2;
CodeGeneratorResponse_File.typeName = "google.protobuf.compiler.CodeGeneratorResponse.File";
CodeGeneratorResponse_File.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "insertion_point", kind: "scalar", T: 9, opt: true },
  { no: 15, name: "content", kind: "scalar", T: 9, opt: true },
  { no: 16, name: "generated_code_info", kind: "message", T: GeneratedCodeInfo, opt: true }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/source_context_pb.js
var SourceContext = class _SourceContext extends Message {
  constructor(data) {
    super();
    this.fileName = "";
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _SourceContext().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _SourceContext().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _SourceContext().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_SourceContext, a, b);
  }
};
SourceContext.runtime = proto3;
SourceContext.typeName = "google.protobuf.SourceContext";
SourceContext.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "file_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/type_pb.js
var Syntax;
(function(Syntax2) {
  Syntax2[Syntax2["PROTO2"] = 0] = "PROTO2";
  Syntax2[Syntax2["PROTO3"] = 1] = "PROTO3";
  Syntax2[Syntax2["EDITIONS"] = 2] = "EDITIONS";
})(Syntax || (Syntax = {}));
proto3.util.setEnumType(Syntax, "google.protobuf.Syntax", [
  { no: 0, name: "SYNTAX_PROTO2" },
  { no: 1, name: "SYNTAX_PROTO3" },
  { no: 2, name: "SYNTAX_EDITIONS" }
]);
var Type = class _Type extends Message {
  constructor(data) {
    super();
    this.name = "";
    this.fields = [];
    this.oneofs = [];
    this.options = [];
    this.syntax = Syntax.PROTO2;
    this.edition = "";
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Type().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Type().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Type().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Type, a, b);
  }
};
Type.runtime = proto3;
Type.typeName = "google.protobuf.Type";
Type.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "fields", kind: "message", T: Field, repeated: true },
  { no: 3, name: "oneofs", kind: "scalar", T: 9, repeated: true },
  { no: 4, name: "options", kind: "message", T: Option, repeated: true },
  { no: 5, name: "source_context", kind: "message", T: SourceContext },
  { no: 6, name: "syntax", kind: "enum", T: proto3.getEnumType(Syntax) },
  {
    no: 7,
    name: "edition",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
var Field = class _Field extends Message {
  constructor(data) {
    super();
    this.kind = Field_Kind.TYPE_UNKNOWN;
    this.cardinality = Field_Cardinality.UNKNOWN;
    this.number = 0;
    this.name = "";
    this.typeUrl = "";
    this.oneofIndex = 0;
    this.packed = false;
    this.options = [];
    this.jsonName = "";
    this.defaultValue = "";
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Field().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Field().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Field().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Field, a, b);
  }
};
Field.runtime = proto3;
Field.typeName = "google.protobuf.Field";
Field.fields = proto3.util.newFieldList(() => [
  { no: 1, name: "kind", kind: "enum", T: proto3.getEnumType(Field_Kind) },
  { no: 2, name: "cardinality", kind: "enum", T: proto3.getEnumType(Field_Cardinality) },
  {
    no: 3,
    name: "number",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 4,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 6,
    name: "type_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 7,
    name: "oneof_index",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 8,
    name: "packed",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  { no: 9, name: "options", kind: "message", T: Option, repeated: true },
  {
    no: 10,
    name: "json_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 11,
    name: "default_value",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
var Field_Kind;
(function(Field_Kind2) {
  Field_Kind2[Field_Kind2["TYPE_UNKNOWN"] = 0] = "TYPE_UNKNOWN";
  Field_Kind2[Field_Kind2["TYPE_DOUBLE"] = 1] = "TYPE_DOUBLE";
  Field_Kind2[Field_Kind2["TYPE_FLOAT"] = 2] = "TYPE_FLOAT";
  Field_Kind2[Field_Kind2["TYPE_INT64"] = 3] = "TYPE_INT64";
  Field_Kind2[Field_Kind2["TYPE_UINT64"] = 4] = "TYPE_UINT64";
  Field_Kind2[Field_Kind2["TYPE_INT32"] = 5] = "TYPE_INT32";
  Field_Kind2[Field_Kind2["TYPE_FIXED64"] = 6] = "TYPE_FIXED64";
  Field_Kind2[Field_Kind2["TYPE_FIXED32"] = 7] = "TYPE_FIXED32";
  Field_Kind2[Field_Kind2["TYPE_BOOL"] = 8] = "TYPE_BOOL";
  Field_Kind2[Field_Kind2["TYPE_STRING"] = 9] = "TYPE_STRING";
  Field_Kind2[Field_Kind2["TYPE_GROUP"] = 10] = "TYPE_GROUP";
  Field_Kind2[Field_Kind2["TYPE_MESSAGE"] = 11] = "TYPE_MESSAGE";
  Field_Kind2[Field_Kind2["TYPE_BYTES"] = 12] = "TYPE_BYTES";
  Field_Kind2[Field_Kind2["TYPE_UINT32"] = 13] = "TYPE_UINT32";
  Field_Kind2[Field_Kind2["TYPE_ENUM"] = 14] = "TYPE_ENUM";
  Field_Kind2[Field_Kind2["TYPE_SFIXED32"] = 15] = "TYPE_SFIXED32";
  Field_Kind2[Field_Kind2["TYPE_SFIXED64"] = 16] = "TYPE_SFIXED64";
  Field_Kind2[Field_Kind2["TYPE_SINT32"] = 17] = "TYPE_SINT32";
  Field_Kind2[Field_Kind2["TYPE_SINT64"] = 18] = "TYPE_SINT64";
})(Field_Kind || (Field_Kind = {}));
proto3.util.setEnumType(Field_Kind, "google.protobuf.Field.Kind", [
  { no: 0, name: "TYPE_UNKNOWN" },
  { no: 1, name: "TYPE_DOUBLE" },
  { no: 2, name: "TYPE_FLOAT" },
  { no: 3, name: "TYPE_INT64" },
  { no: 4, name: "TYPE_UINT64" },
  { no: 5, name: "TYPE_INT32" },
  { no: 6, name: "TYPE_FIXED64" },
  { no: 7, name: "TYPE_FIXED32" },
  { no: 8, name: "TYPE_BOOL" },
  { no: 9, name: "TYPE_STRING" },
  { no: 10, name: "TYPE_GROUP" },
  { no: 11, name: "TYPE_MESSAGE" },
  { no: 12, name: "TYPE_BYTES" },
  { no: 13, name: "TYPE_UINT32" },
  { no: 14, name: "TYPE_ENUM" },
  { no: 15, name: "TYPE_SFIXED32" },
  { no: 16, name: "TYPE_SFIXED64" },
  { no: 17, name: "TYPE_SINT32" },
  { no: 18, name: "TYPE_SINT64" }
]);
var Field_Cardinality;
(function(Field_Cardinality2) {
  Field_Cardinality2[Field_Cardinality2["UNKNOWN"] = 0] = "UNKNOWN";
  Field_Cardinality2[Field_Cardinality2["OPTIONAL"] = 1] = "OPTIONAL";
  Field_Cardinality2[Field_Cardinality2["REQUIRED"] = 2] = "REQUIRED";
  Field_Cardinality2[Field_Cardinality2["REPEATED"] = 3] = "REPEATED";
})(Field_Cardinality || (Field_Cardinality = {}));
proto3.util.setEnumType(Field_Cardinality, "google.protobuf.Field.Cardinality", [
  { no: 0, name: "CARDINALITY_UNKNOWN" },
  { no: 1, name: "CARDINALITY_OPTIONAL" },
  { no: 2, name: "CARDINALITY_REQUIRED" },
  { no: 3, name: "CARDINALITY_REPEATED" }
]);
var Enum = class _Enum extends Message {
  constructor(data) {
    super();
    this.name = "";
    this.enumvalue = [];
    this.options = [];
    this.syntax = Syntax.PROTO2;
    this.edition = "";
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Enum().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Enum().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Enum().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Enum, a, b);
  }
};
Enum.runtime = proto3;
Enum.typeName = "google.protobuf.Enum";
Enum.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "enumvalue", kind: "message", T: EnumValue, repeated: true },
  { no: 3, name: "options", kind: "message", T: Option, repeated: true },
  { no: 4, name: "source_context", kind: "message", T: SourceContext },
  { no: 5, name: "syntax", kind: "enum", T: proto3.getEnumType(Syntax) },
  {
    no: 6,
    name: "edition",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
var EnumValue = class _EnumValue extends Message {
  constructor(data) {
    super();
    this.name = "";
    this.number = 0;
    this.options = [];
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _EnumValue().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _EnumValue().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _EnumValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_EnumValue, a, b);
  }
};
EnumValue.runtime = proto3;
EnumValue.typeName = "google.protobuf.EnumValue";
EnumValue.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "number",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  { no: 3, name: "options", kind: "message", T: Option, repeated: true }
]);
var Option = class _Option extends Message {
  constructor(data) {
    super();
    this.name = "";
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Option().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Option().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Option().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Option, a, b);
  }
};
Option.runtime = proto3;
Option.typeName = "google.protobuf.Option";
Option.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "value", kind: "message", T: Any }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/api_pb.js
var Api = class _Api extends Message {
  constructor(data) {
    super();
    this.name = "";
    this.methods = [];
    this.options = [];
    this.version = "";
    this.mixins = [];
    this.syntax = Syntax.PROTO2;
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Api().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Api().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Api().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Api, a, b);
  }
};
Api.runtime = proto3;
Api.typeName = "google.protobuf.Api";
Api.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "methods", kind: "message", T: Method, repeated: true },
  { no: 3, name: "options", kind: "message", T: Option, repeated: true },
  {
    no: 4,
    name: "version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 5, name: "source_context", kind: "message", T: SourceContext },
  { no: 6, name: "mixins", kind: "message", T: Mixin, repeated: true },
  { no: 7, name: "syntax", kind: "enum", T: proto3.getEnumType(Syntax) }
]);
var Method = class _Method extends Message {
  constructor(data) {
    super();
    this.name = "";
    this.requestTypeUrl = "";
    this.requestStreaming = false;
    this.responseTypeUrl = "";
    this.responseStreaming = false;
    this.options = [];
    this.syntax = Syntax.PROTO2;
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Method().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Method().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Method().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Method, a, b);
  }
};
Method.runtime = proto3;
Method.typeName = "google.protobuf.Method";
Method.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "request_type_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 3,
    name: "request_streaming",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  {
    no: 4,
    name: "response_type_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 5,
    name: "response_streaming",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  { no: 6, name: "options", kind: "message", T: Option, repeated: true },
  { no: 7, name: "syntax", kind: "enum", T: proto3.getEnumType(Syntax) }
]);
var Mixin = class _Mixin extends Message {
  constructor(data) {
    super();
    this.name = "";
    this.root = "";
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Mixin().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Mixin().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Mixin().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Mixin, a, b);
  }
};
Mixin.runtime = proto3;
Mixin.typeName = "google.protobuf.Mixin";
Mixin.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "root",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);

// node_modules/@livekit/protocol/dist/index.mjs
var MetricLabel = proto3.makeEnum(
  "livekit.MetricLabel",
  [
    { no: 0, name: "AGENTS_LLM_TTFT" },
    { no: 1, name: "AGENTS_STT_TTFT" },
    { no: 2, name: "AGENTS_TTS_TTFB" },
    { no: 3, name: "CLIENT_VIDEO_SUBSCRIBER_FREEZE_COUNT" },
    { no: 4, name: "CLIENT_VIDEO_SUBSCRIBER_TOTAL_FREEZE_DURATION" },
    { no: 5, name: "CLIENT_VIDEO_SUBSCRIBER_PAUSE_COUNT" },
    { no: 6, name: "CLIENT_VIDEO_SUBSCRIBER_TOTAL_PAUSES_DURATION" },
    { no: 7, name: "CLIENT_AUDIO_SUBSCRIBER_CONCEALED_SAMPLES" },
    { no: 8, name: "CLIENT_AUDIO_SUBSCRIBER_SILENT_CONCEALED_SAMPLES" },
    { no: 9, name: "CLIENT_AUDIO_SUBSCRIBER_CONCEALMENT_EVENTS" },
    { no: 10, name: "CLIENT_AUDIO_SUBSCRIBER_INTERRUPTION_COUNT" },
    { no: 11, name: "CLIENT_AUDIO_SUBSCRIBER_TOTAL_INTERRUPTION_DURATION" },
    { no: 12, name: "CLIENT_SUBSCRIBER_JITTER_BUFFER_DELAY" },
    { no: 13, name: "CLIENT_SUBSCRIBER_JITTER_BUFFER_EMITTED_COUNT" },
    { no: 14, name: "CLIENT_VIDEO_PUBLISHER_QUALITY_LIMITATION_DURATION_BANDWIDTH" },
    { no: 15, name: "CLIENT_VIDEO_PUBLISHER_QUALITY_LIMITATION_DURATION_CPU" },
    { no: 16, name: "CLIENT_VIDEO_PUBLISHER_QUALITY_LIMITATION_DURATION_OTHER" },
    { no: 17, name: "PUBLISHER_RTT" },
    { no: 18, name: "SERVER_MESH_RTT" },
    { no: 19, name: "SUBSCRIBER_RTT" },
    { no: 4096, name: "METRIC_LABEL_PREDEFINED_MAX_VALUE" }
  ]
);
var MetricsBatch = proto3.makeMessageType(
  "livekit.MetricsBatch",
  () => [
    {
      no: 1,
      name: "timestamp_ms",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    { no: 2, name: "normalized_timestamp", kind: "message", T: Timestamp },
    { no: 3, name: "str_data", kind: "scalar", T: 9, repeated: true },
    { no: 4, name: "time_series", kind: "message", T: TimeSeriesMetric, repeated: true },
    { no: 5, name: "events", kind: "message", T: EventMetric, repeated: true }
  ]
);
var TimeSeriesMetric = proto3.makeMessageType(
  "livekit.TimeSeriesMetric",
  () => [
    {
      no: 1,
      name: "label",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 2,
      name: "participant_identity",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 3,
      name: "track_sid",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    { no: 4, name: "samples", kind: "message", T: MetricSample, repeated: true },
    {
      no: 5,
      name: "rid",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    }
  ]
);
var MetricSample = proto3.makeMessageType(
  "livekit.MetricSample",
  () => [
    {
      no: 1,
      name: "timestamp_ms",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    { no: 2, name: "normalized_timestamp", kind: "message", T: Timestamp },
    {
      no: 3,
      name: "value",
      kind: "scalar",
      T: 2
      /* ScalarType.FLOAT */
    }
  ]
);
var EventMetric = proto3.makeMessageType(
  "livekit.EventMetric",
  () => [
    {
      no: 1,
      name: "label",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 2,
      name: "participant_identity",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 3,
      name: "track_sid",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 4,
      name: "start_timestamp_ms",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    { no: 5, name: "end_timestamp_ms", kind: "scalar", T: 3, opt: true },
    { no: 6, name: "normalized_start_timestamp", kind: "message", T: Timestamp },
    { no: 7, name: "normalized_end_timestamp", kind: "message", T: Timestamp, opt: true },
    {
      no: 8,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 9,
      name: "rid",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    }
  ]
);
var AudioCodec = proto3.makeEnum(
  "livekit.AudioCodec",
  [
    { no: 0, name: "DEFAULT_AC" },
    { no: 1, name: "OPUS" },
    { no: 2, name: "AAC" }
  ]
);
var VideoCodec = proto3.makeEnum(
  "livekit.VideoCodec",
  [
    { no: 0, name: "DEFAULT_VC" },
    { no: 1, name: "H264_BASELINE" },
    { no: 2, name: "H264_MAIN" },
    { no: 3, name: "H264_HIGH" },
    { no: 4, name: "VP8" }
  ]
);
var ImageCodec = proto3.makeEnum(
  "livekit.ImageCodec",
  [
    { no: 0, name: "IC_DEFAULT" },
    { no: 1, name: "IC_JPEG" }
  ]
);
var BackupCodecPolicy = proto3.makeEnum(
  "livekit.BackupCodecPolicy",
  [
    { no: 0, name: "PREFER_REGRESSION" },
    { no: 1, name: "SIMULCAST" },
    { no: 2, name: "REGRESSION" }
  ]
);
var TrackType = proto3.makeEnum(
  "livekit.TrackType",
  [
    { no: 0, name: "AUDIO" },
    { no: 1, name: "VIDEO" },
    { no: 2, name: "DATA" }
  ]
);
var TrackSource = proto3.makeEnum(
  "livekit.TrackSource",
  [
    { no: 0, name: "UNKNOWN" },
    { no: 1, name: "CAMERA" },
    { no: 2, name: "MICROPHONE" },
    { no: 3, name: "SCREEN_SHARE" },
    { no: 4, name: "SCREEN_SHARE_AUDIO" }
  ]
);
var VideoQuality = proto3.makeEnum(
  "livekit.VideoQuality",
  [
    { no: 0, name: "LOW" },
    { no: 1, name: "MEDIUM" },
    { no: 2, name: "HIGH" },
    { no: 3, name: "OFF" }
  ]
);
var ConnectionQuality = proto3.makeEnum(
  "livekit.ConnectionQuality",
  [
    { no: 0, name: "POOR" },
    { no: 1, name: "GOOD" },
    { no: 2, name: "EXCELLENT" },
    { no: 3, name: "LOST" }
  ]
);
var ClientConfigSetting = proto3.makeEnum(
  "livekit.ClientConfigSetting",
  [
    { no: 0, name: "UNSET" },
    { no: 1, name: "DISABLED" },
    { no: 2, name: "ENABLED" }
  ]
);
var DisconnectReason = proto3.makeEnum(
  "livekit.DisconnectReason",
  [
    { no: 0, name: "UNKNOWN_REASON" },
    { no: 1, name: "CLIENT_INITIATED" },
    { no: 2, name: "DUPLICATE_IDENTITY" },
    { no: 3, name: "SERVER_SHUTDOWN" },
    { no: 4, name: "PARTICIPANT_REMOVED" },
    { no: 5, name: "ROOM_DELETED" },
    { no: 6, name: "STATE_MISMATCH" },
    { no: 7, name: "JOIN_FAILURE" },
    { no: 8, name: "MIGRATION" },
    { no: 9, name: "SIGNAL_CLOSE" },
    { no: 10, name: "ROOM_CLOSED" },
    { no: 11, name: "USER_UNAVAILABLE" },
    { no: 12, name: "USER_REJECTED" },
    { no: 13, name: "SIP_TRUNK_FAILURE" }
  ]
);
var ReconnectReason = proto3.makeEnum(
  "livekit.ReconnectReason",
  [
    { no: 0, name: "RR_UNKNOWN" },
    { no: 1, name: "RR_SIGNAL_DISCONNECTED" },
    { no: 2, name: "RR_PUBLISHER_FAILED" },
    { no: 3, name: "RR_SUBSCRIBER_FAILED" },
    { no: 4, name: "RR_SWITCH_CANDIDATE" }
  ]
);
var SubscriptionError = proto3.makeEnum(
  "livekit.SubscriptionError",
  [
    { no: 0, name: "SE_UNKNOWN" },
    { no: 1, name: "SE_CODEC_UNSUPPORTED" },
    { no: 2, name: "SE_TRACK_NOTFOUND" }
  ]
);
var AudioTrackFeature = proto3.makeEnum(
  "livekit.AudioTrackFeature",
  [
    { no: 0, name: "TF_STEREO" },
    { no: 1, name: "TF_NO_DTX" },
    { no: 2, name: "TF_AUTO_GAIN_CONTROL" },
    { no: 3, name: "TF_ECHO_CANCELLATION" },
    { no: 4, name: "TF_NOISE_SUPPRESSION" },
    { no: 5, name: "TF_ENHANCED_NOISE_CANCELLATION" }
  ]
);
var Pagination = proto3.makeMessageType(
  "livekit.Pagination",
  () => [
    {
      no: 1,
      name: "after_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "limit",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]
);
var ListUpdate = proto3.makeMessageType(
  "livekit.ListUpdate",
  () => [
    { no: 1, name: "set", kind: "scalar", T: 9, repeated: true }
  ]
);
var Room = proto3.makeMessageType(
  "livekit.Room",
  () => [
    {
      no: 1,
      name: "sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "empty_timeout",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 14,
      name: "departure_timeout",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 4,
      name: "max_participants",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 5,
      name: "creation_time",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 15,
      name: "creation_time_ms",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 6,
      name: "turn_password",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 7, name: "enabled_codecs", kind: "message", T: Codec, repeated: true },
    {
      no: 8,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 9,
      name: "num_participants",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 11,
      name: "num_publishers",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 10,
      name: "active_recording",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 13, name: "version", kind: "message", T: TimedVersion }
  ]
);
var Codec = proto3.makeMessageType(
  "livekit.Codec",
  () => [
    {
      no: 1,
      name: "mime",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "fmtp_line",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var PlayoutDelay = proto3.makeMessageType(
  "livekit.PlayoutDelay",
  () => [
    {
      no: 1,
      name: "enabled",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 2,
      name: "min",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 3,
      name: "max",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    }
  ]
);
var ParticipantPermission = proto3.makeMessageType(
  "livekit.ParticipantPermission",
  () => [
    {
      no: 1,
      name: "can_subscribe",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 2,
      name: "can_publish",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 3,
      name: "can_publish_data",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 9, name: "can_publish_sources", kind: "enum", T: proto3.getEnumType(TrackSource), repeated: true },
    {
      no: 7,
      name: "hidden",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 8,
      name: "recorder",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 10,
      name: "can_update_metadata",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 11,
      name: "agent",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 12,
      name: "can_subscribe_metrics",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]
);
var ParticipantInfo = proto3.makeMessageType(
  "livekit.ParticipantInfo",
  () => [
    {
      no: 1,
      name: "sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "identity",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "state", kind: "enum", T: proto3.getEnumType(ParticipantInfo_State) },
    { no: 4, name: "tracks", kind: "message", T: TrackInfo, repeated: true },
    {
      no: 5,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "joined_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 17,
      name: "joined_at_ms",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 9,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 10,
      name: "version",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    { no: 11, name: "permission", kind: "message", T: ParticipantPermission },
    {
      no: 12,
      name: "region",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 13,
      name: "is_publisher",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 14, name: "kind", kind: "enum", T: proto3.getEnumType(ParticipantInfo_Kind) },
    { no: 15, name: "attributes", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } },
    { no: 16, name: "disconnect_reason", kind: "enum", T: proto3.getEnumType(DisconnectReason) },
    { no: 18, name: "kind_details", kind: "enum", T: proto3.getEnumType(ParticipantInfo_KindDetail), repeated: true }
  ]
);
var ParticipantInfo_State = proto3.makeEnum(
  "livekit.ParticipantInfo.State",
  [
    { no: 0, name: "JOINING" },
    { no: 1, name: "JOINED" },
    { no: 2, name: "ACTIVE" },
    { no: 3, name: "DISCONNECTED" }
  ]
);
var ParticipantInfo_Kind = proto3.makeEnum(
  "livekit.ParticipantInfo.Kind",
  [
    { no: 0, name: "STANDARD" },
    { no: 1, name: "INGRESS" },
    { no: 2, name: "EGRESS" },
    { no: 3, name: "SIP" },
    { no: 4, name: "AGENT" }
  ]
);
var ParticipantInfo_KindDetail = proto3.makeEnum(
  "livekit.ParticipantInfo.KindDetail",
  [
    { no: 0, name: "CLOUD_AGENT" },
    { no: 1, name: "FORWARDED" }
  ]
);
var Encryption = proto3.makeMessageType(
  "livekit.Encryption",
  []
);
var Encryption_Type = proto3.makeEnum(
  "livekit.Encryption.Type",
  [
    { no: 0, name: "NONE" },
    { no: 1, name: "GCM" },
    { no: 2, name: "CUSTOM" }
  ]
);
var SimulcastCodecInfo = proto3.makeMessageType(
  "livekit.SimulcastCodecInfo",
  () => [
    {
      no: 1,
      name: "mime_type",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "mid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "cid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 4, name: "layers", kind: "message", T: VideoLayer, repeated: true }
  ]
);
var TrackInfo = proto3.makeMessageType(
  "livekit.TrackInfo",
  () => [
    {
      no: 1,
      name: "sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(TrackType) },
    {
      no: 3,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "muted",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 5,
      name: "width",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 6,
      name: "height",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 7,
      name: "simulcast",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 8,
      name: "disable_dtx",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 9, name: "source", kind: "enum", T: proto3.getEnumType(TrackSource) },
    { no: 10, name: "layers", kind: "message", T: VideoLayer, repeated: true },
    {
      no: 11,
      name: "mime_type",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 12,
      name: "mid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 13, name: "codecs", kind: "message", T: SimulcastCodecInfo, repeated: true },
    {
      no: 14,
      name: "stereo",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 15,
      name: "disable_red",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 16, name: "encryption", kind: "enum", T: proto3.getEnumType(Encryption_Type) },
    {
      no: 17,
      name: "stream",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 18, name: "version", kind: "message", T: TimedVersion },
    { no: 19, name: "audio_features", kind: "enum", T: proto3.getEnumType(AudioTrackFeature), repeated: true },
    { no: 20, name: "backup_codec_policy", kind: "enum", T: proto3.getEnumType(BackupCodecPolicy) }
  ]
);
var VideoLayer = proto3.makeMessageType(
  "livekit.VideoLayer",
  () => [
    { no: 1, name: "quality", kind: "enum", T: proto3.getEnumType(VideoQuality) },
    {
      no: 2,
      name: "width",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 3,
      name: "height",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 4,
      name: "bitrate",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 5,
      name: "ssrc",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    }
  ]
);
var DataPacket = proto3.makeMessageType(
  "livekit.DataPacket",
  () => [
    { no: 1, name: "kind", kind: "enum", T: proto3.getEnumType(DataPacket_Kind) },
    {
      no: 4,
      name: "participant_identity",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 5, name: "destination_identities", kind: "scalar", T: 9, repeated: true },
    { no: 2, name: "user", kind: "message", T: UserPacket, oneof: "value" },
    { no: 3, name: "speaker", kind: "message", T: ActiveSpeakerUpdate, oneof: "value" },
    { no: 6, name: "sip_dtmf", kind: "message", T: SipDTMF, oneof: "value" },
    { no: 7, name: "transcription", kind: "message", T: Transcription, oneof: "value" },
    { no: 8, name: "metrics", kind: "message", T: MetricsBatch, oneof: "value" },
    { no: 9, name: "chat_message", kind: "message", T: ChatMessage, oneof: "value" },
    { no: 10, name: "rpc_request", kind: "message", T: RpcRequest, oneof: "value" },
    { no: 11, name: "rpc_ack", kind: "message", T: RpcAck, oneof: "value" },
    { no: 12, name: "rpc_response", kind: "message", T: RpcResponse, oneof: "value" },
    { no: 13, name: "stream_header", kind: "message", T: DataStream_Header, oneof: "value" },
    { no: 14, name: "stream_chunk", kind: "message", T: DataStream_Chunk, oneof: "value" },
    { no: 15, name: "stream_trailer", kind: "message", T: DataStream_Trailer, oneof: "value" }
  ]
);
var DataPacket_Kind = proto3.makeEnum(
  "livekit.DataPacket.Kind",
  [
    { no: 0, name: "RELIABLE" },
    { no: 1, name: "LOSSY" }
  ]
);
var ActiveSpeakerUpdate = proto3.makeMessageType(
  "livekit.ActiveSpeakerUpdate",
  () => [
    { no: 1, name: "speakers", kind: "message", T: SpeakerInfo, repeated: true }
  ]
);
var SpeakerInfo = proto3.makeMessageType(
  "livekit.SpeakerInfo",
  () => [
    {
      no: 1,
      name: "sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "level",
      kind: "scalar",
      T: 2
      /* ScalarType.FLOAT */
    },
    {
      no: 3,
      name: "active",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]
);
var UserPacket = proto3.makeMessageType(
  "livekit.UserPacket",
  () => [
    {
      no: 1,
      name: "participant_sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "participant_identity",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "payload",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 3, name: "destination_sids", kind: "scalar", T: 9, repeated: true },
    { no: 6, name: "destination_identities", kind: "scalar", T: 9, repeated: true },
    { no: 4, name: "topic", kind: "scalar", T: 9, opt: true },
    { no: 8, name: "id", kind: "scalar", T: 9, opt: true },
    { no: 9, name: "start_time", kind: "scalar", T: 4, opt: true },
    { no: 10, name: "end_time", kind: "scalar", T: 4, opt: true },
    {
      no: 11,
      name: "nonce",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]
);
var SipDTMF = proto3.makeMessageType(
  "livekit.SipDTMF",
  () => [
    {
      no: 3,
      name: "code",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 4,
      name: "digit",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var Transcription = proto3.makeMessageType(
  "livekit.Transcription",
  () => [
    {
      no: 2,
      name: "transcribed_participant_identity",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "track_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 4, name: "segments", kind: "message", T: TranscriptionSegment, repeated: true }
  ]
);
var TranscriptionSegment = proto3.makeMessageType(
  "livekit.TranscriptionSegment",
  () => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "text",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "start_time",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 4,
      name: "end_time",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 5,
      name: "final",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 6,
      name: "language",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var ChatMessage = proto3.makeMessageType(
  "livekit.ChatMessage",
  () => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "timestamp",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    { no: 3, name: "edit_timestamp", kind: "scalar", T: 3, opt: true },
    {
      no: 4,
      name: "message",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "deleted",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 6,
      name: "generated",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]
);
var RpcRequest = proto3.makeMessageType(
  "livekit.RpcRequest",
  () => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "method",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "payload",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "response_timeout_ms",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 5,
      name: "version",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    }
  ]
);
var RpcAck = proto3.makeMessageType(
  "livekit.RpcAck",
  () => [
    {
      no: 1,
      name: "request_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var RpcResponse = proto3.makeMessageType(
  "livekit.RpcResponse",
  () => [
    {
      no: 1,
      name: "request_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "payload", kind: "scalar", T: 9, oneof: "value" },
    { no: 3, name: "error", kind: "message", T: RpcError, oneof: "value" }
  ]
);
var RpcError = proto3.makeMessageType(
  "livekit.RpcError",
  () => [
    {
      no: 1,
      name: "code",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 2,
      name: "message",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "data",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var ParticipantTracks = proto3.makeMessageType(
  "livekit.ParticipantTracks",
  () => [
    {
      no: 1,
      name: "participant_sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "track_sids", kind: "scalar", T: 9, repeated: true }
  ]
);
var ServerInfo = proto3.makeMessageType(
  "livekit.ServerInfo",
  () => [
    { no: 1, name: "edition", kind: "enum", T: proto3.getEnumType(ServerInfo_Edition) },
    {
      no: 2,
      name: "version",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "protocol",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 4,
      name: "region",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "node_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "debug_info",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: "agent_protocol",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]
);
var ServerInfo_Edition = proto3.makeEnum(
  "livekit.ServerInfo.Edition",
  [
    { no: 0, name: "Standard" },
    { no: 1, name: "Cloud" }
  ]
);
var ClientInfo = proto3.makeMessageType(
  "livekit.ClientInfo",
  () => [
    { no: 1, name: "sdk", kind: "enum", T: proto3.getEnumType(ClientInfo_SDK) },
    {
      no: 2,
      name: "version",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "protocol",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 4,
      name: "os",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "os_version",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "device_model",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: "browser",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 8,
      name: "browser_version",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 9,
      name: "address",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 10,
      name: "network",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 11,
      name: "other_sdks",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var ClientInfo_SDK = proto3.makeEnum(
  "livekit.ClientInfo.SDK",
  [
    { no: 0, name: "UNKNOWN" },
    { no: 1, name: "JS" },
    { no: 2, name: "SWIFT" },
    { no: 3, name: "ANDROID" },
    { no: 4, name: "FLUTTER" },
    { no: 5, name: "GO" },
    { no: 6, name: "UNITY" },
    { no: 7, name: "REACT_NATIVE" },
    { no: 8, name: "RUST" },
    { no: 9, name: "PYTHON" },
    { no: 10, name: "CPP" },
    { no: 11, name: "UNITY_WEB" },
    { no: 12, name: "NODE" }
  ]
);
var ClientConfiguration = proto3.makeMessageType(
  "livekit.ClientConfiguration",
  () => [
    { no: 1, name: "video", kind: "message", T: VideoConfiguration },
    { no: 2, name: "screen", kind: "message", T: VideoConfiguration },
    { no: 3, name: "resume_connection", kind: "enum", T: proto3.getEnumType(ClientConfigSetting) },
    { no: 4, name: "disabled_codecs", kind: "message", T: DisabledCodecs },
    { no: 5, name: "force_relay", kind: "enum", T: proto3.getEnumType(ClientConfigSetting) }
  ]
);
var VideoConfiguration = proto3.makeMessageType(
  "livekit.VideoConfiguration",
  () => [
    { no: 1, name: "hardware_encoder", kind: "enum", T: proto3.getEnumType(ClientConfigSetting) }
  ]
);
var DisabledCodecs = proto3.makeMessageType(
  "livekit.DisabledCodecs",
  () => [
    { no: 1, name: "codecs", kind: "message", T: Codec, repeated: true },
    { no: 2, name: "publish", kind: "message", T: Codec, repeated: true }
  ]
);
var RTPDrift = proto3.makeMessageType(
  "livekit.RTPDrift",
  () => [
    { no: 1, name: "start_time", kind: "message", T: Timestamp },
    { no: 2, name: "end_time", kind: "message", T: Timestamp },
    {
      no: 3,
      name: "duration",
      kind: "scalar",
      T: 1
      /* ScalarType.DOUBLE */
    },
    {
      no: 4,
      name: "start_timestamp",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 5,
      name: "end_timestamp",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 6,
      name: "rtp_clock_ticks",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 7,
      name: "drift_samples",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 8,
      name: "drift_ms",
      kind: "scalar",
      T: 1
      /* ScalarType.DOUBLE */
    },
    {
      no: 9,
      name: "clock_rate",
      kind: "scalar",
      T: 1
      /* ScalarType.DOUBLE */
    }
  ]
);
var RTPStats = proto3.makeMessageType(
  "livekit.RTPStats",
  () => [
    { no: 1, name: "start_time", kind: "message", T: Timestamp },
    { no: 2, name: "end_time", kind: "message", T: Timestamp },
    {
      no: 3,
      name: "duration",
      kind: "scalar",
      T: 1
      /* ScalarType.DOUBLE */
    },
    {
      no: 4,
      name: "packets",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 5,
      name: "packet_rate",
      kind: "scalar",
      T: 1
      /* ScalarType.DOUBLE */
    },
    {
      no: 6,
      name: "bytes",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 39,
      name: "header_bytes",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 7,
      name: "bitrate",
      kind: "scalar",
      T: 1
      /* ScalarType.DOUBLE */
    },
    {
      no: 8,
      name: "packets_lost",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 9,
      name: "packet_loss_rate",
      kind: "scalar",
      T: 1
      /* ScalarType.DOUBLE */
    },
    {
      no: 10,
      name: "packet_loss_percentage",
      kind: "scalar",
      T: 2
      /* ScalarType.FLOAT */
    },
    {
      no: 11,
      name: "packets_duplicate",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 12,
      name: "packet_duplicate_rate",
      kind: "scalar",
      T: 1
      /* ScalarType.DOUBLE */
    },
    {
      no: 13,
      name: "bytes_duplicate",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 40,
      name: "header_bytes_duplicate",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 14,
      name: "bitrate_duplicate",
      kind: "scalar",
      T: 1
      /* ScalarType.DOUBLE */
    },
    {
      no: 15,
      name: "packets_padding",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 16,
      name: "packet_padding_rate",
      kind: "scalar",
      T: 1
      /* ScalarType.DOUBLE */
    },
    {
      no: 17,
      name: "bytes_padding",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 41,
      name: "header_bytes_padding",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 18,
      name: "bitrate_padding",
      kind: "scalar",
      T: 1
      /* ScalarType.DOUBLE */
    },
    {
      no: 19,
      name: "packets_out_of_order",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 20,
      name: "frames",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 21,
      name: "frame_rate",
      kind: "scalar",
      T: 1
      /* ScalarType.DOUBLE */
    },
    {
      no: 22,
      name: "jitter_current",
      kind: "scalar",
      T: 1
      /* ScalarType.DOUBLE */
    },
    {
      no: 23,
      name: "jitter_max",
      kind: "scalar",
      T: 1
      /* ScalarType.DOUBLE */
    },
    { no: 24, name: "gap_histogram", kind: "map", K: 5, V: {
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    } },
    {
      no: 25,
      name: "nacks",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 37,
      name: "nack_acks",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 26,
      name: "nack_misses",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 38,
      name: "nack_repeated",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 27,
      name: "plis",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    { no: 28, name: "last_pli", kind: "message", T: Timestamp },
    {
      no: 29,
      name: "firs",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    { no: 30, name: "last_fir", kind: "message", T: Timestamp },
    {
      no: 31,
      name: "rtt_current",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 32,
      name: "rtt_max",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 33,
      name: "key_frames",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    { no: 34, name: "last_key_frame", kind: "message", T: Timestamp },
    {
      no: 35,
      name: "layer_lock_plis",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    { no: 36, name: "last_layer_lock_pli", kind: "message", T: Timestamp },
    { no: 44, name: "packet_drift", kind: "message", T: RTPDrift },
    { no: 45, name: "ntp_report_drift", kind: "message", T: RTPDrift },
    { no: 46, name: "rebased_report_drift", kind: "message", T: RTPDrift },
    { no: 47, name: "received_report_drift", kind: "message", T: RTPDrift }
  ]
);
var RTCPSenderReportState = proto3.makeMessageType(
  "livekit.RTCPSenderReportState",
  () => [
    {
      no: 1,
      name: "rtp_timestamp",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 2,
      name: "rtp_timestamp_ext",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 3,
      name: "ntp_timestamp",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 4,
      name: "at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 5,
      name: "at_adjusted",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 6,
      name: "packets",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 7,
      name: "octets",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    }
  ]
);
var RTPForwarderState = proto3.makeMessageType(
  "livekit.RTPForwarderState",
  () => [
    {
      no: 1,
      name: "started",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 2,
      name: "reference_layer_spatial",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 3,
      name: "pre_start_time",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 4,
      name: "ext_first_timestamp",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 5,
      name: "dummy_start_timestamp_offset",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    { no: 6, name: "rtp_munger", kind: "message", T: RTPMungerState },
    { no: 7, name: "vp8_munger", kind: "message", T: VP8MungerState, oneof: "codec_munger" },
    { no: 8, name: "sender_report_state", kind: "message", T: RTCPSenderReportState, repeated: true }
  ]
);
var RTPMungerState = proto3.makeMessageType(
  "livekit.RTPMungerState",
  () => [
    {
      no: 1,
      name: "ext_last_sequence_number",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 2,
      name: "ext_second_last_sequence_number",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 3,
      name: "ext_last_timestamp",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 4,
      name: "ext_second_last_timestamp",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 5,
      name: "last_marker",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 6,
      name: "second_last_marker",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]
);
var VP8MungerState = proto3.makeMessageType(
  "livekit.VP8MungerState",
  () => [
    {
      no: 1,
      name: "ext_last_picture_id",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 2,
      name: "picture_id_used",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 3,
      name: "last_tl0_pic_idx",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 4,
      name: "tl0_pic_idx_used",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 5,
      name: "tid_used",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 6,
      name: "last_key_idx",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 7,
      name: "key_idx_used",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]
);
var TimedVersion = proto3.makeMessageType(
  "livekit.TimedVersion",
  () => [
    {
      no: 1,
      name: "unix_micro",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 2,
      name: "ticks",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]
);
var DataStream = proto3.makeMessageType(
  "livekit.DataStream",
  []
);
var DataStream_OperationType = proto3.makeEnum(
  "livekit.DataStream.OperationType",
  [
    { no: 0, name: "CREATE" },
    { no: 1, name: "UPDATE" },
    { no: 2, name: "DELETE" },
    { no: 3, name: "REACTION" }
  ]
);
var DataStream_TextHeader = proto3.makeMessageType(
  "livekit.DataStream.TextHeader",
  () => [
    { no: 1, name: "operation_type", kind: "enum", T: proto3.getEnumType(DataStream_OperationType) },
    {
      no: 2,
      name: "version",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 3,
      name: "reply_to_stream_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 4, name: "attached_stream_ids", kind: "scalar", T: 9, repeated: true },
    {
      no: 5,
      name: "generated",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ],
  { localName: "DataStream_TextHeader" }
);
var DataStream_ByteHeader = proto3.makeMessageType(
  "livekit.DataStream.ByteHeader",
  () => [
    {
      no: 1,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ],
  { localName: "DataStream_ByteHeader" }
);
var DataStream_Header = proto3.makeMessageType(
  "livekit.DataStream.Header",
  () => [
    {
      no: 1,
      name: "stream_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "timestamp",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 3,
      name: "topic",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "mime_type",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 5, name: "total_length", kind: "scalar", T: 4, opt: true },
    { no: 7, name: "encryption_type", kind: "enum", T: proto3.getEnumType(Encryption_Type) },
    { no: 8, name: "attributes", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } },
    { no: 9, name: "text_header", kind: "message", T: DataStream_TextHeader, oneof: "content_header" },
    { no: 10, name: "byte_header", kind: "message", T: DataStream_ByteHeader, oneof: "content_header" }
  ],
  { localName: "DataStream_Header" }
);
var DataStream_Chunk = proto3.makeMessageType(
  "livekit.DataStream.Chunk",
  () => [
    {
      no: 1,
      name: "stream_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "chunk_index",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 3,
      name: "content",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "version",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    { no: 5, name: "iv", kind: "scalar", T: 12, opt: true }
  ],
  { localName: "DataStream_Chunk" }
);
var DataStream_Trailer = proto3.makeMessageType(
  "livekit.DataStream.Trailer",
  () => [
    {
      no: 1,
      name: "stream_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "reason",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "attributes", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } }
  ],
  { localName: "DataStream_Trailer" }
);
var JobType = proto3.makeEnum(
  "livekit.JobType",
  [
    { no: 0, name: "JT_ROOM" },
    { no: 1, name: "JT_PUBLISHER" },
    { no: 2, name: "JT_PARTICIPANT" }
  ]
);
var WorkerStatus = proto3.makeEnum(
  "livekit.WorkerStatus",
  [
    { no: 0, name: "WS_AVAILABLE" },
    { no: 1, name: "WS_FULL" }
  ]
);
var JobStatus = proto3.makeEnum(
  "livekit.JobStatus",
  [
    { no: 0, name: "JS_PENDING" },
    { no: 1, name: "JS_RUNNING" },
    { no: 2, name: "JS_SUCCESS" },
    { no: 3, name: "JS_FAILED" }
  ]
);
var Job = proto3.makeMessageType(
  "livekit.Job",
  () => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 9,
      name: "dispatch_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(JobType) },
    { no: 3, name: "room", kind: "message", T: Room },
    { no: 4, name: "participant", kind: "message", T: ParticipantInfo, opt: true },
    {
      no: 5,
      name: "namespace",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: "agent_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 8, name: "state", kind: "message", T: JobState }
  ]
);
var JobState = proto3.makeMessageType(
  "livekit.JobState",
  () => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(JobStatus) },
    {
      no: 2,
      name: "error",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "started_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 4,
      name: "ended_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 5,
      name: "updated_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 6,
      name: "participant_identity",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var WorkerMessage = proto3.makeMessageType(
  "livekit.WorkerMessage",
  () => [
    { no: 1, name: "register", kind: "message", T: RegisterWorkerRequest, oneof: "message" },
    { no: 2, name: "availability", kind: "message", T: AvailabilityResponse, oneof: "message" },
    { no: 3, name: "update_worker", kind: "message", T: UpdateWorkerStatus, oneof: "message" },
    { no: 4, name: "update_job", kind: "message", T: UpdateJobStatus, oneof: "message" },
    { no: 5, name: "ping", kind: "message", T: WorkerPing, oneof: "message" },
    { no: 6, name: "simulate_job", kind: "message", T: SimulateJobRequest, oneof: "message" },
    { no: 7, name: "migrate_job", kind: "message", T: MigrateJobRequest, oneof: "message" }
  ]
);
var ServerMessage = proto3.makeMessageType(
  "livekit.ServerMessage",
  () => [
    { no: 1, name: "register", kind: "message", T: RegisterWorkerResponse, oneof: "message" },
    { no: 2, name: "availability", kind: "message", T: AvailabilityRequest, oneof: "message" },
    { no: 3, name: "assignment", kind: "message", T: JobAssignment, oneof: "message" },
    { no: 5, name: "termination", kind: "message", T: JobTermination, oneof: "message" },
    { no: 4, name: "pong", kind: "message", T: WorkerPong, oneof: "message" }
  ]
);
var SimulateJobRequest = proto3.makeMessageType(
  "livekit.SimulateJobRequest",
  () => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(JobType) },
    { no: 2, name: "room", kind: "message", T: Room },
    { no: 3, name: "participant", kind: "message", T: ParticipantInfo }
  ]
);
var WorkerPing = proto3.makeMessageType(
  "livekit.WorkerPing",
  () => [
    {
      no: 1,
      name: "timestamp",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    }
  ]
);
var WorkerPong = proto3.makeMessageType(
  "livekit.WorkerPong",
  () => [
    {
      no: 1,
      name: "last_timestamp",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 2,
      name: "timestamp",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    }
  ]
);
var RegisterWorkerRequest = proto3.makeMessageType(
  "livekit.RegisterWorkerRequest",
  () => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(JobType) },
    {
      no: 8,
      name: "agent_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "version",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "ping_interval",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    { no: 6, name: "namespace", kind: "scalar", T: 9, opt: true },
    { no: 7, name: "allowed_permissions", kind: "message", T: ParticipantPermission }
  ]
);
var RegisterWorkerResponse = proto3.makeMessageType(
  "livekit.RegisterWorkerResponse",
  () => [
    {
      no: 1,
      name: "worker_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "server_info", kind: "message", T: ServerInfo }
  ]
);
var MigrateJobRequest = proto3.makeMessageType(
  "livekit.MigrateJobRequest",
  () => [
    { no: 2, name: "job_ids", kind: "scalar", T: 9, repeated: true }
  ]
);
var AvailabilityRequest = proto3.makeMessageType(
  "livekit.AvailabilityRequest",
  () => [
    { no: 1, name: "job", kind: "message", T: Job },
    {
      no: 2,
      name: "resuming",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]
);
var AvailabilityResponse = proto3.makeMessageType(
  "livekit.AvailabilityResponse",
  () => [
    {
      no: 1,
      name: "job_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "available",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 3,
      name: "supports_resume",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 4,
      name: "participant_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "participant_identity",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "participant_metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 7, name: "participant_attributes", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } }
  ]
);
var UpdateJobStatus = proto3.makeMessageType(
  "livekit.UpdateJobStatus",
  () => [
    {
      no: 1,
      name: "job_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "status", kind: "enum", T: proto3.getEnumType(JobStatus) },
    {
      no: 3,
      name: "error",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var UpdateWorkerStatus = proto3.makeMessageType(
  "livekit.UpdateWorkerStatus",
  () => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(WorkerStatus), opt: true },
    {
      no: 3,
      name: "load",
      kind: "scalar",
      T: 2
      /* ScalarType.FLOAT */
    },
    {
      no: 4,
      name: "job_count",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    }
  ]
);
var JobAssignment = proto3.makeMessageType(
  "livekit.JobAssignment",
  () => [
    { no: 1, name: "job", kind: "message", T: Job },
    { no: 2, name: "url", kind: "scalar", T: 9, opt: true },
    {
      no: 3,
      name: "token",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var JobTermination = proto3.makeMessageType(
  "livekit.JobTermination",
  () => [
    {
      no: 1,
      name: "job_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var CreateAgentDispatchRequest = proto3.makeMessageType(
  "livekit.CreateAgentDispatchRequest",
  () => [
    {
      no: 1,
      name: "agent_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "room",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var RoomAgentDispatch = proto3.makeMessageType(
  "livekit.RoomAgentDispatch",
  () => [
    {
      no: 1,
      name: "agent_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var DeleteAgentDispatchRequest = proto3.makeMessageType(
  "livekit.DeleteAgentDispatchRequest",
  () => [
    {
      no: 1,
      name: "dispatch_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "room",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var ListAgentDispatchRequest = proto3.makeMessageType(
  "livekit.ListAgentDispatchRequest",
  () => [
    {
      no: 1,
      name: "dispatch_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "room",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var ListAgentDispatchResponse = proto3.makeMessageType(
  "livekit.ListAgentDispatchResponse",
  () => [
    { no: 1, name: "agent_dispatches", kind: "message", T: AgentDispatch, repeated: true }
  ]
);
var AgentDispatch = proto3.makeMessageType(
  "livekit.AgentDispatch",
  () => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "agent_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "room",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 5, name: "state", kind: "message", T: AgentDispatchState }
  ]
);
var AgentDispatchState = proto3.makeMessageType(
  "livekit.AgentDispatchState",
  () => [
    { no: 1, name: "jobs", kind: "message", T: Job, repeated: true },
    {
      no: 2,
      name: "created_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 3,
      name: "deleted_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    }
  ]
);
var EncodedFileType = proto3.makeEnum(
  "livekit.EncodedFileType",
  [
    { no: 0, name: "DEFAULT_FILETYPE" },
    { no: 1, name: "MP4" },
    { no: 2, name: "OGG" }
  ]
);
var SegmentedFileProtocol = proto3.makeEnum(
  "livekit.SegmentedFileProtocol",
  [
    { no: 0, name: "DEFAULT_SEGMENTED_FILE_PROTOCOL" },
    { no: 1, name: "HLS_PROTOCOL" }
  ]
);
var SegmentedFileSuffix = proto3.makeEnum(
  "livekit.SegmentedFileSuffix",
  [
    { no: 0, name: "INDEX" },
    { no: 1, name: "TIMESTAMP" }
  ]
);
var ImageFileSuffix = proto3.makeEnum(
  "livekit.ImageFileSuffix",
  [
    { no: 0, name: "IMAGE_SUFFIX_INDEX" },
    { no: 1, name: "IMAGE_SUFFIX_TIMESTAMP" }
  ]
);
var StreamProtocol = proto3.makeEnum(
  "livekit.StreamProtocol",
  [
    { no: 0, name: "DEFAULT_PROTOCOL" },
    { no: 1, name: "RTMP" },
    { no: 2, name: "SRT" }
  ]
);
var AudioMixing = proto3.makeEnum(
  "livekit.AudioMixing",
  [
    { no: 0, name: "DEFAULT_MIXING" },
    { no: 1, name: "DUAL_CHANNEL_AGENT" },
    { no: 2, name: "DUAL_CHANNEL_ALTERNATE" }
  ]
);
var EncodingOptionsPreset = proto3.makeEnum(
  "livekit.EncodingOptionsPreset",
  [
    { no: 0, name: "H264_720P_30" },
    { no: 1, name: "H264_720P_60" },
    { no: 2, name: "H264_1080P_30" },
    { no: 3, name: "H264_1080P_60" },
    { no: 4, name: "PORTRAIT_H264_720P_30" },
    { no: 5, name: "PORTRAIT_H264_720P_60" },
    { no: 6, name: "PORTRAIT_H264_1080P_30" },
    { no: 7, name: "PORTRAIT_H264_1080P_60" }
  ]
);
var EgressStatus = proto3.makeEnum(
  "livekit.EgressStatus",
  [
    { no: 0, name: "EGRESS_STARTING" },
    { no: 1, name: "EGRESS_ACTIVE" },
    { no: 2, name: "EGRESS_ENDING" },
    { no: 3, name: "EGRESS_COMPLETE" },
    { no: 4, name: "EGRESS_FAILED" },
    { no: 5, name: "EGRESS_ABORTED" },
    { no: 6, name: "EGRESS_LIMIT_REACHED" }
  ]
);
var EgressSourceType = proto3.makeEnum(
  "livekit.EgressSourceType",
  [
    { no: 0, name: "EGRESS_SOURCE_TYPE_WEB", localName: "WEB" },
    { no: 1, name: "EGRESS_SOURCE_TYPE_SDK", localName: "SDK" }
  ]
);
var RoomCompositeEgressRequest = proto3.makeMessageType(
  "livekit.RoomCompositeEgressRequest",
  () => [
    {
      no: 1,
      name: "room_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "layout",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "audio_only",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 15, name: "audio_mixing", kind: "enum", T: proto3.getEnumType(AudioMixing) },
    {
      no: 4,
      name: "video_only",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 5,
      name: "custom_base_url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 6, name: "file", kind: "message", T: EncodedFileOutput, oneof: "output" },
    { no: 7, name: "stream", kind: "message", T: StreamOutput, oneof: "output" },
    { no: 10, name: "segments", kind: "message", T: SegmentedFileOutput, oneof: "output" },
    { no: 8, name: "preset", kind: "enum", T: proto3.getEnumType(EncodingOptionsPreset), oneof: "options" },
    { no: 9, name: "advanced", kind: "message", T: EncodingOptions, oneof: "options" },
    { no: 11, name: "file_outputs", kind: "message", T: EncodedFileOutput, repeated: true },
    { no: 12, name: "stream_outputs", kind: "message", T: StreamOutput, repeated: true },
    { no: 13, name: "segment_outputs", kind: "message", T: SegmentedFileOutput, repeated: true },
    { no: 14, name: "image_outputs", kind: "message", T: ImageOutput, repeated: true }
  ]
);
var WebEgressRequest = proto3.makeMessageType(
  "livekit.WebEgressRequest",
  () => [
    {
      no: 1,
      name: "url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "audio_only",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 3,
      name: "video_only",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 12,
      name: "await_start_signal",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 4, name: "file", kind: "message", T: EncodedFileOutput, oneof: "output" },
    { no: 5, name: "stream", kind: "message", T: StreamOutput, oneof: "output" },
    { no: 6, name: "segments", kind: "message", T: SegmentedFileOutput, oneof: "output" },
    { no: 7, name: "preset", kind: "enum", T: proto3.getEnumType(EncodingOptionsPreset), oneof: "options" },
    { no: 8, name: "advanced", kind: "message", T: EncodingOptions, oneof: "options" },
    { no: 9, name: "file_outputs", kind: "message", T: EncodedFileOutput, repeated: true },
    { no: 10, name: "stream_outputs", kind: "message", T: StreamOutput, repeated: true },
    { no: 11, name: "segment_outputs", kind: "message", T: SegmentedFileOutput, repeated: true },
    { no: 13, name: "image_outputs", kind: "message", T: ImageOutput, repeated: true }
  ]
);
var ParticipantEgressRequest = proto3.makeMessageType(
  "livekit.ParticipantEgressRequest",
  () => [
    {
      no: 1,
      name: "room_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "identity",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "screen_share",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 4, name: "preset", kind: "enum", T: proto3.getEnumType(EncodingOptionsPreset), oneof: "options" },
    { no: 5, name: "advanced", kind: "message", T: EncodingOptions, oneof: "options" },
    { no: 6, name: "file_outputs", kind: "message", T: EncodedFileOutput, repeated: true },
    { no: 7, name: "stream_outputs", kind: "message", T: StreamOutput, repeated: true },
    { no: 8, name: "segment_outputs", kind: "message", T: SegmentedFileOutput, repeated: true },
    { no: 9, name: "image_outputs", kind: "message", T: ImageOutput, repeated: true }
  ]
);
var TrackCompositeEgressRequest = proto3.makeMessageType(
  "livekit.TrackCompositeEgressRequest",
  () => [
    {
      no: 1,
      name: "room_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "audio_track_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "video_track_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 4, name: "file", kind: "message", T: EncodedFileOutput, oneof: "output" },
    { no: 5, name: "stream", kind: "message", T: StreamOutput, oneof: "output" },
    { no: 8, name: "segments", kind: "message", T: SegmentedFileOutput, oneof: "output" },
    { no: 6, name: "preset", kind: "enum", T: proto3.getEnumType(EncodingOptionsPreset), oneof: "options" },
    { no: 7, name: "advanced", kind: "message", T: EncodingOptions, oneof: "options" },
    { no: 11, name: "file_outputs", kind: "message", T: EncodedFileOutput, repeated: true },
    { no: 12, name: "stream_outputs", kind: "message", T: StreamOutput, repeated: true },
    { no: 13, name: "segment_outputs", kind: "message", T: SegmentedFileOutput, repeated: true },
    { no: 14, name: "image_outputs", kind: "message", T: ImageOutput, repeated: true }
  ]
);
var TrackEgressRequest = proto3.makeMessageType(
  "livekit.TrackEgressRequest",
  () => [
    {
      no: 1,
      name: "room_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "track_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "file", kind: "message", T: DirectFileOutput, oneof: "output" },
    { no: 4, name: "websocket_url", kind: "scalar", T: 9, oneof: "output" }
  ]
);
var EncodedFileOutput = proto3.makeMessageType(
  "livekit.EncodedFileOutput",
  () => [
    { no: 1, name: "file_type", kind: "enum", T: proto3.getEnumType(EncodedFileType) },
    {
      no: 2,
      name: "filepath",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "disable_manifest",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 3, name: "s3", kind: "message", T: S3Upload, oneof: "output" },
    { no: 4, name: "gcp", kind: "message", T: GCPUpload, oneof: "output" },
    { no: 5, name: "azure", kind: "message", T: AzureBlobUpload, oneof: "output" },
    { no: 7, name: "aliOSS", kind: "message", T: AliOSSUpload, oneof: "output" }
  ]
);
var SegmentedFileOutput = proto3.makeMessageType(
  "livekit.SegmentedFileOutput",
  () => [
    { no: 1, name: "protocol", kind: "enum", T: proto3.getEnumType(SegmentedFileProtocol) },
    {
      no: 2,
      name: "filename_prefix",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "playlist_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 11,
      name: "live_playlist_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "segment_duration",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    { no: 10, name: "filename_suffix", kind: "enum", T: proto3.getEnumType(SegmentedFileSuffix) },
    {
      no: 8,
      name: "disable_manifest",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 5, name: "s3", kind: "message", T: S3Upload, oneof: "output" },
    { no: 6, name: "gcp", kind: "message", T: GCPUpload, oneof: "output" },
    { no: 7, name: "azure", kind: "message", T: AzureBlobUpload, oneof: "output" },
    { no: 9, name: "aliOSS", kind: "message", T: AliOSSUpload, oneof: "output" }
  ]
);
var DirectFileOutput = proto3.makeMessageType(
  "livekit.DirectFileOutput",
  () => [
    {
      no: 1,
      name: "filepath",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "disable_manifest",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 2, name: "s3", kind: "message", T: S3Upload, oneof: "output" },
    { no: 3, name: "gcp", kind: "message", T: GCPUpload, oneof: "output" },
    { no: 4, name: "azure", kind: "message", T: AzureBlobUpload, oneof: "output" },
    { no: 6, name: "aliOSS", kind: "message", T: AliOSSUpload, oneof: "output" }
  ]
);
var ImageOutput = proto3.makeMessageType(
  "livekit.ImageOutput",
  () => [
    {
      no: 1,
      name: "capture_interval",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 2,
      name: "width",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 3,
      name: "height",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 4,
      name: "filename_prefix",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 5, name: "filename_suffix", kind: "enum", T: proto3.getEnumType(ImageFileSuffix) },
    { no: 6, name: "image_codec", kind: "enum", T: proto3.getEnumType(ImageCodec) },
    {
      no: 7,
      name: "disable_manifest",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 8, name: "s3", kind: "message", T: S3Upload, oneof: "output" },
    { no: 9, name: "gcp", kind: "message", T: GCPUpload, oneof: "output" },
    { no: 10, name: "azure", kind: "message", T: AzureBlobUpload, oneof: "output" },
    { no: 11, name: "aliOSS", kind: "message", T: AliOSSUpload, oneof: "output" }
  ]
);
var S3Upload = proto3.makeMessageType(
  "livekit.S3Upload",
  () => [
    {
      no: 1,
      name: "access_key",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "secret",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 11,
      name: "session_token",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "region",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "endpoint",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "bucket",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "force_path_style",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 7, name: "metadata", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } },
    {
      no: 8,
      name: "tagging",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 9,
      name: "content_disposition",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 10, name: "proxy", kind: "message", T: ProxyConfig }
  ]
);
var GCPUpload = proto3.makeMessageType(
  "livekit.GCPUpload",
  () => [
    {
      no: 1,
      name: "credentials",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "bucket",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "proxy", kind: "message", T: ProxyConfig }
  ]
);
var AzureBlobUpload = proto3.makeMessageType(
  "livekit.AzureBlobUpload",
  () => [
    {
      no: 1,
      name: "account_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "account_key",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "container_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var AliOSSUpload = proto3.makeMessageType(
  "livekit.AliOSSUpload",
  () => [
    {
      no: 1,
      name: "access_key",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "secret",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "region",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "endpoint",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "bucket",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var ProxyConfig = proto3.makeMessageType(
  "livekit.ProxyConfig",
  () => [
    {
      no: 1,
      name: "url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "username",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "password",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var StreamOutput = proto3.makeMessageType(
  "livekit.StreamOutput",
  () => [
    { no: 1, name: "protocol", kind: "enum", T: proto3.getEnumType(StreamProtocol) },
    { no: 2, name: "urls", kind: "scalar", T: 9, repeated: true }
  ]
);
var EncodingOptions = proto3.makeMessageType(
  "livekit.EncodingOptions",
  () => [
    {
      no: 1,
      name: "width",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 2,
      name: "height",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 3,
      name: "depth",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 4,
      name: "framerate",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    { no: 5, name: "audio_codec", kind: "enum", T: proto3.getEnumType(AudioCodec) },
    {
      no: 6,
      name: "audio_bitrate",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 11,
      name: "audio_quality",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 7,
      name: "audio_frequency",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    { no: 8, name: "video_codec", kind: "enum", T: proto3.getEnumType(VideoCodec) },
    {
      no: 9,
      name: "video_bitrate",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 12,
      name: "video_quality",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 10,
      name: "key_frame_interval",
      kind: "scalar",
      T: 1
      /* ScalarType.DOUBLE */
    }
  ]
);
var UpdateLayoutRequest = proto3.makeMessageType(
  "livekit.UpdateLayoutRequest",
  () => [
    {
      no: 1,
      name: "egress_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "layout",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var UpdateStreamRequest = proto3.makeMessageType(
  "livekit.UpdateStreamRequest",
  () => [
    {
      no: 1,
      name: "egress_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "add_output_urls", kind: "scalar", T: 9, repeated: true },
    { no: 3, name: "remove_output_urls", kind: "scalar", T: 9, repeated: true }
  ]
);
var ListEgressRequest = proto3.makeMessageType(
  "livekit.ListEgressRequest",
  () => [
    {
      no: 1,
      name: "room_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "egress_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "active",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]
);
var ListEgressResponse = proto3.makeMessageType(
  "livekit.ListEgressResponse",
  () => [
    { no: 1, name: "items", kind: "message", T: EgressInfo, repeated: true }
  ]
);
var StopEgressRequest = proto3.makeMessageType(
  "livekit.StopEgressRequest",
  () => [
    {
      no: 1,
      name: "egress_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var EgressInfo = proto3.makeMessageType(
  "livekit.EgressInfo",
  () => [
    {
      no: 1,
      name: "egress_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "room_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 13,
      name: "room_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 26, name: "source_type", kind: "enum", T: proto3.getEnumType(EgressSourceType) },
    { no: 3, name: "status", kind: "enum", T: proto3.getEnumType(EgressStatus) },
    {
      no: 10,
      name: "started_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 11,
      name: "ended_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 18,
      name: "updated_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 21,
      name: "details",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 9,
      name: "error",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 22,
      name: "error_code",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    { no: 4, name: "room_composite", kind: "message", T: RoomCompositeEgressRequest, oneof: "request" },
    { no: 14, name: "web", kind: "message", T: WebEgressRequest, oneof: "request" },
    { no: 19, name: "participant", kind: "message", T: ParticipantEgressRequest, oneof: "request" },
    { no: 5, name: "track_composite", kind: "message", T: TrackCompositeEgressRequest, oneof: "request" },
    { no: 6, name: "track", kind: "message", T: TrackEgressRequest, oneof: "request" },
    { no: 7, name: "stream", kind: "message", T: StreamInfoList, oneof: "result" },
    { no: 8, name: "file", kind: "message", T: FileInfo, oneof: "result" },
    { no: 12, name: "segments", kind: "message", T: SegmentsInfo, oneof: "result" },
    { no: 15, name: "stream_results", kind: "message", T: StreamInfo, repeated: true },
    { no: 16, name: "file_results", kind: "message", T: FileInfo, repeated: true },
    { no: 17, name: "segment_results", kind: "message", T: SegmentsInfo, repeated: true },
    { no: 20, name: "image_results", kind: "message", T: ImagesInfo, repeated: true },
    {
      no: 23,
      name: "manifest_location",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 25,
      name: "backup_storage_used",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]
);
var StreamInfoList = proto3.makeMessageType(
  "livekit.StreamInfoList",
  () => [
    { no: 1, name: "info", kind: "message", T: StreamInfo, repeated: true }
  ]
);
var StreamInfo = proto3.makeMessageType(
  "livekit.StreamInfo",
  () => [
    {
      no: 1,
      name: "url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "started_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 3,
      name: "ended_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 4,
      name: "duration",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    { no: 5, name: "status", kind: "enum", T: proto3.getEnumType(StreamInfo_Status) },
    {
      no: 6,
      name: "error",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var StreamInfo_Status = proto3.makeEnum(
  "livekit.StreamInfo.Status",
  [
    { no: 0, name: "ACTIVE" },
    { no: 1, name: "FINISHED" },
    { no: 2, name: "FAILED" }
  ]
);
var FileInfo = proto3.makeMessageType(
  "livekit.FileInfo",
  () => [
    {
      no: 1,
      name: "filename",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "started_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 3,
      name: "ended_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 6,
      name: "duration",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 4,
      name: "size",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 5,
      name: "location",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var SegmentsInfo = proto3.makeMessageType(
  "livekit.SegmentsInfo",
  () => [
    {
      no: 1,
      name: "playlist_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 8,
      name: "live_playlist_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "duration",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 3,
      name: "size",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 4,
      name: "playlist_location",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 9,
      name: "live_playlist_location",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "segment_count",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 6,
      name: "started_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 7,
      name: "ended_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    }
  ]
);
var ImagesInfo = proto3.makeMessageType(
  "livekit.ImagesInfo",
  () => [
    {
      no: 4,
      name: "filename_prefix",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 1,
      name: "image_count",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 2,
      name: "started_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 3,
      name: "ended_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    }
  ]
);
var AutoParticipantEgress = proto3.makeMessageType(
  "livekit.AutoParticipantEgress",
  () => [
    { no: 1, name: "preset", kind: "enum", T: proto3.getEnumType(EncodingOptionsPreset), oneof: "options" },
    { no: 2, name: "advanced", kind: "message", T: EncodingOptions, oneof: "options" },
    { no: 3, name: "file_outputs", kind: "message", T: EncodedFileOutput, repeated: true },
    { no: 4, name: "segment_outputs", kind: "message", T: SegmentedFileOutput, repeated: true }
  ]
);
var AutoTrackEgress = proto3.makeMessageType(
  "livekit.AutoTrackEgress",
  () => [
    {
      no: 1,
      name: "filepath",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "disable_manifest",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 2, name: "s3", kind: "message", T: S3Upload, oneof: "output" },
    { no: 3, name: "gcp", kind: "message", T: GCPUpload, oneof: "output" },
    { no: 4, name: "azure", kind: "message", T: AzureBlobUpload, oneof: "output" },
    { no: 6, name: "aliOSS", kind: "message", T: AliOSSUpload, oneof: "output" }
  ]
);
var IngressInput = proto3.makeEnum(
  "livekit.IngressInput",
  [
    { no: 0, name: "RTMP_INPUT" },
    { no: 1, name: "WHIP_INPUT" },
    { no: 2, name: "URL_INPUT" }
  ]
);
var IngressAudioEncodingPreset = proto3.makeEnum(
  "livekit.IngressAudioEncodingPreset",
  [
    { no: 0, name: "OPUS_STEREO_96KBPS" },
    { no: 1, name: "OPUS_MONO_64KBS" }
  ]
);
var IngressVideoEncodingPreset = proto3.makeEnum(
  "livekit.IngressVideoEncodingPreset",
  [
    { no: 0, name: "H264_720P_30FPS_3_LAYERS" },
    { no: 1, name: "H264_1080P_30FPS_3_LAYERS" },
    { no: 2, name: "H264_540P_25FPS_2_LAYERS" },
    { no: 3, name: "H264_720P_30FPS_1_LAYER" },
    { no: 4, name: "H264_1080P_30FPS_1_LAYER" },
    { no: 5, name: "H264_720P_30FPS_3_LAYERS_HIGH_MOTION" },
    { no: 6, name: "H264_1080P_30FPS_3_LAYERS_HIGH_MOTION" },
    { no: 7, name: "H264_540P_25FPS_2_LAYERS_HIGH_MOTION" },
    { no: 8, name: "H264_720P_30FPS_1_LAYER_HIGH_MOTION" },
    { no: 9, name: "H264_1080P_30FPS_1_LAYER_HIGH_MOTION" }
  ]
);
var CreateIngressRequest = proto3.makeMessageType(
  "livekit.CreateIngressRequest",
  () => [
    { no: 1, name: "input_type", kind: "enum", T: proto3.getEnumType(IngressInput) },
    {
      no: 9,
      name: "url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "room_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "participant_identity",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "participant_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 10,
      name: "participant_metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 8,
      name: "bypass_transcoding",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 11, name: "enable_transcoding", kind: "scalar", T: 8, opt: true },
    { no: 6, name: "audio", kind: "message", T: IngressAudioOptions },
    { no: 7, name: "video", kind: "message", T: IngressVideoOptions },
    { no: 12, name: "enabled", kind: "scalar", T: 8, opt: true }
  ]
);
var IngressAudioOptions = proto3.makeMessageType(
  "livekit.IngressAudioOptions",
  () => [
    {
      no: 1,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "source", kind: "enum", T: proto3.getEnumType(TrackSource) },
    { no: 3, name: "preset", kind: "enum", T: proto3.getEnumType(IngressAudioEncodingPreset), oneof: "encoding_options" },
    { no: 4, name: "options", kind: "message", T: IngressAudioEncodingOptions, oneof: "encoding_options" }
  ]
);
var IngressVideoOptions = proto3.makeMessageType(
  "livekit.IngressVideoOptions",
  () => [
    {
      no: 1,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "source", kind: "enum", T: proto3.getEnumType(TrackSource) },
    { no: 3, name: "preset", kind: "enum", T: proto3.getEnumType(IngressVideoEncodingPreset), oneof: "encoding_options" },
    { no: 4, name: "options", kind: "message", T: IngressVideoEncodingOptions, oneof: "encoding_options" }
  ]
);
var IngressAudioEncodingOptions = proto3.makeMessageType(
  "livekit.IngressAudioEncodingOptions",
  () => [
    { no: 1, name: "audio_codec", kind: "enum", T: proto3.getEnumType(AudioCodec) },
    {
      no: 2,
      name: "bitrate",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 3,
      name: "disable_dtx",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 4,
      name: "channels",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    }
  ]
);
var IngressVideoEncodingOptions = proto3.makeMessageType(
  "livekit.IngressVideoEncodingOptions",
  () => [
    { no: 1, name: "video_codec", kind: "enum", T: proto3.getEnumType(VideoCodec) },
    {
      no: 2,
      name: "frame_rate",
      kind: "scalar",
      T: 1
      /* ScalarType.DOUBLE */
    },
    { no: 3, name: "layers", kind: "message", T: VideoLayer, repeated: true }
  ]
);
var IngressInfo = proto3.makeMessageType(
  "livekit.IngressInfo",
  () => [
    {
      no: 1,
      name: "ingress_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "stream_key",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 5, name: "input_type", kind: "enum", T: proto3.getEnumType(IngressInput) },
    {
      no: 13,
      name: "bypass_transcoding",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 15, name: "enable_transcoding", kind: "scalar", T: 8, opt: true },
    { no: 6, name: "audio", kind: "message", T: IngressAudioOptions },
    { no: 7, name: "video", kind: "message", T: IngressVideoOptions },
    {
      no: 8,
      name: "room_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 9,
      name: "participant_identity",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 10,
      name: "participant_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 14,
      name: "participant_metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 11,
      name: "reusable",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 12, name: "state", kind: "message", T: IngressState },
    { no: 16, name: "enabled", kind: "scalar", T: 8, opt: true }
  ]
);
var IngressState = proto3.makeMessageType(
  "livekit.IngressState",
  () => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(IngressState_Status) },
    {
      no: 2,
      name: "error",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "video", kind: "message", T: InputVideoState },
    { no: 4, name: "audio", kind: "message", T: InputAudioState },
    {
      no: 5,
      name: "room_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: "started_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 8,
      name: "ended_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 10,
      name: "updated_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 9,
      name: "resource_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 6, name: "tracks", kind: "message", T: TrackInfo, repeated: true }
  ]
);
var IngressState_Status = proto3.makeEnum(
  "livekit.IngressState.Status",
  [
    { no: 0, name: "ENDPOINT_INACTIVE" },
    { no: 1, name: "ENDPOINT_BUFFERING" },
    { no: 2, name: "ENDPOINT_PUBLISHING" },
    { no: 3, name: "ENDPOINT_ERROR" },
    { no: 4, name: "ENDPOINT_COMPLETE" }
  ]
);
var InputVideoState = proto3.makeMessageType(
  "livekit.InputVideoState",
  () => [
    {
      no: 1,
      name: "mime_type",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "average_bitrate",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 3,
      name: "width",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 4,
      name: "height",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 5,
      name: "framerate",
      kind: "scalar",
      T: 1
      /* ScalarType.DOUBLE */
    }
  ]
);
var InputAudioState = proto3.makeMessageType(
  "livekit.InputAudioState",
  () => [
    {
      no: 1,
      name: "mime_type",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "average_bitrate",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 3,
      name: "channels",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 4,
      name: "sample_rate",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    }
  ]
);
var UpdateIngressRequest = proto3.makeMessageType(
  "livekit.UpdateIngressRequest",
  () => [
    {
      no: 1,
      name: "ingress_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "room_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "participant_identity",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "participant_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 9,
      name: "participant_metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 8, name: "bypass_transcoding", kind: "scalar", T: 8, opt: true },
    { no: 10, name: "enable_transcoding", kind: "scalar", T: 8, opt: true },
    { no: 6, name: "audio", kind: "message", T: IngressAudioOptions },
    { no: 7, name: "video", kind: "message", T: IngressVideoOptions },
    { no: 11, name: "enabled", kind: "scalar", T: 8, opt: true }
  ]
);
var ListIngressRequest = proto3.makeMessageType(
  "livekit.ListIngressRequest",
  () => [
    {
      no: 1,
      name: "room_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "ingress_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var ListIngressResponse = proto3.makeMessageType(
  "livekit.ListIngressResponse",
  () => [
    { no: 1, name: "items", kind: "message", T: IngressInfo, repeated: true }
  ]
);
var DeleteIngressRequest = proto3.makeMessageType(
  "livekit.DeleteIngressRequest",
  () => [
    {
      no: 1,
      name: "ingress_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var CreateRoomRequest = proto3.makeMessageType(
  "livekit.CreateRoomRequest",
  () => [
    {
      no: 1,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 12,
      name: "room_preset",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "empty_timeout",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 10,
      name: "departure_timeout",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 3,
      name: "max_participants",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 4,
      name: "node_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 6, name: "egress", kind: "message", T: RoomEgress },
    {
      no: 7,
      name: "min_playout_delay",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 8,
      name: "max_playout_delay",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 9,
      name: "sync_streams",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 13,
      name: "replay_enabled",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 14, name: "agents", kind: "message", T: RoomAgentDispatch, repeated: true }
  ]
);
var RoomEgress = proto3.makeMessageType(
  "livekit.RoomEgress",
  () => [
    { no: 1, name: "room", kind: "message", T: RoomCompositeEgressRequest },
    { no: 3, name: "participant", kind: "message", T: AutoParticipantEgress },
    { no: 2, name: "tracks", kind: "message", T: AutoTrackEgress }
  ]
);
var RoomAgent = proto3.makeMessageType(
  "livekit.RoomAgent",
  () => [
    { no: 1, name: "dispatches", kind: "message", T: RoomAgentDispatch, repeated: true }
  ]
);
var ListRoomsRequest = proto3.makeMessageType(
  "livekit.ListRoomsRequest",
  () => [
    { no: 1, name: "names", kind: "scalar", T: 9, repeated: true }
  ]
);
var ListRoomsResponse = proto3.makeMessageType(
  "livekit.ListRoomsResponse",
  () => [
    { no: 1, name: "rooms", kind: "message", T: Room, repeated: true }
  ]
);
var DeleteRoomRequest = proto3.makeMessageType(
  "livekit.DeleteRoomRequest",
  () => [
    {
      no: 1,
      name: "room",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var DeleteRoomResponse = proto3.makeMessageType(
  "livekit.DeleteRoomResponse",
  []
);
var ListParticipantsRequest = proto3.makeMessageType(
  "livekit.ListParticipantsRequest",
  () => [
    {
      no: 1,
      name: "room",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var ListParticipantsResponse = proto3.makeMessageType(
  "livekit.ListParticipantsResponse",
  () => [
    { no: 1, name: "participants", kind: "message", T: ParticipantInfo, repeated: true }
  ]
);
var RoomParticipantIdentity = proto3.makeMessageType(
  "livekit.RoomParticipantIdentity",
  () => [
    {
      no: 1,
      name: "room",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "identity",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var RemoveParticipantResponse = proto3.makeMessageType(
  "livekit.RemoveParticipantResponse",
  []
);
var MuteRoomTrackRequest = proto3.makeMessageType(
  "livekit.MuteRoomTrackRequest",
  () => [
    {
      no: 1,
      name: "room",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "identity",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "track_sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "muted",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]
);
var MuteRoomTrackResponse = proto3.makeMessageType(
  "livekit.MuteRoomTrackResponse",
  () => [
    { no: 1, name: "track", kind: "message", T: TrackInfo }
  ]
);
var UpdateParticipantRequest = proto3.makeMessageType(
  "livekit.UpdateParticipantRequest",
  () => [
    {
      no: 1,
      name: "room",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "identity",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 4, name: "permission", kind: "message", T: ParticipantPermission },
    {
      no: 5,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 6, name: "attributes", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } }
  ]
);
var UpdateSubscriptionsRequest = proto3.makeMessageType(
  "livekit.UpdateSubscriptionsRequest",
  () => [
    {
      no: 1,
      name: "room",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "identity",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "track_sids", kind: "scalar", T: 9, repeated: true },
    {
      no: 4,
      name: "subscribe",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 5, name: "participant_tracks", kind: "message", T: ParticipantTracks, repeated: true }
  ]
);
var UpdateSubscriptionsResponse = proto3.makeMessageType(
  "livekit.UpdateSubscriptionsResponse",
  []
);
var SendDataRequest = proto3.makeMessageType(
  "livekit.SendDataRequest",
  () => [
    {
      no: 1,
      name: "room",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 3, name: "kind", kind: "enum", T: proto3.getEnumType(DataPacket_Kind) },
    { no: 4, name: "destination_sids", kind: "scalar", T: 9, repeated: true },
    { no: 6, name: "destination_identities", kind: "scalar", T: 9, repeated: true },
    { no: 5, name: "topic", kind: "scalar", T: 9, opt: true },
    {
      no: 7,
      name: "nonce",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]
);
var SendDataResponse = proto3.makeMessageType(
  "livekit.SendDataResponse",
  []
);
var UpdateRoomMetadataRequest = proto3.makeMessageType(
  "livekit.UpdateRoomMetadataRequest",
  () => [
    {
      no: 1,
      name: "room",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var RoomConfiguration = proto3.makeMessageType(
  "livekit.RoomConfiguration",
  () => [
    {
      no: 1,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "empty_timeout",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 3,
      name: "departure_timeout",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 4,
      name: "max_participants",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    { no: 5, name: "egress", kind: "message", T: RoomEgress },
    {
      no: 7,
      name: "min_playout_delay",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 8,
      name: "max_playout_delay",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 9,
      name: "sync_streams",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 10, name: "agents", kind: "message", T: RoomAgentDispatch, repeated: true }
  ]
);
var ForwardParticipantRequest = proto3.makeMessageType(
  "livekit.ForwardParticipantRequest",
  () => [
    {
      no: 1,
      name: "room",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "identity",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "destination_room",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var ForwardParticipantResponse = proto3.makeMessageType(
  "livekit.ForwardParticipantResponse",
  []
);
var SignalTarget = proto3.makeEnum(
  "livekit.SignalTarget",
  [
    { no: 0, name: "PUBLISHER" },
    { no: 1, name: "SUBSCRIBER" }
  ]
);
var StreamState = proto3.makeEnum(
  "livekit.StreamState",
  [
    { no: 0, name: "ACTIVE" },
    { no: 1, name: "PAUSED" }
  ]
);
var CandidateProtocol = proto3.makeEnum(
  "livekit.CandidateProtocol",
  [
    { no: 0, name: "UDP" },
    { no: 1, name: "TCP" },
    { no: 2, name: "TLS" }
  ]
);
var SignalRequest = proto3.makeMessageType(
  "livekit.SignalRequest",
  () => [
    { no: 1, name: "offer", kind: "message", T: SessionDescription, oneof: "message" },
    { no: 2, name: "answer", kind: "message", T: SessionDescription, oneof: "message" },
    { no: 3, name: "trickle", kind: "message", T: TrickleRequest, oneof: "message" },
    { no: 4, name: "add_track", kind: "message", T: AddTrackRequest, oneof: "message" },
    { no: 5, name: "mute", kind: "message", T: MuteTrackRequest, oneof: "message" },
    { no: 6, name: "subscription", kind: "message", T: UpdateSubscription, oneof: "message" },
    { no: 7, name: "track_setting", kind: "message", T: UpdateTrackSettings, oneof: "message" },
    { no: 8, name: "leave", kind: "message", T: LeaveRequest, oneof: "message" },
    { no: 10, name: "update_layers", kind: "message", T: UpdateVideoLayers, oneof: "message" },
    { no: 11, name: "subscription_permission", kind: "message", T: SubscriptionPermission, oneof: "message" },
    { no: 12, name: "sync_state", kind: "message", T: SyncState, oneof: "message" },
    { no: 13, name: "simulate", kind: "message", T: SimulateScenario, oneof: "message" },
    { no: 14, name: "ping", kind: "scalar", T: 3, oneof: "message" },
    { no: 15, name: "update_metadata", kind: "message", T: UpdateParticipantMetadata, oneof: "message" },
    { no: 16, name: "ping_req", kind: "message", T: Ping, oneof: "message" },
    { no: 17, name: "update_audio_track", kind: "message", T: UpdateLocalAudioTrack, oneof: "message" },
    { no: 18, name: "update_video_track", kind: "message", T: UpdateLocalVideoTrack, oneof: "message" }
  ]
);
var SignalResponse = proto3.makeMessageType(
  "livekit.SignalResponse",
  () => [
    { no: 1, name: "join", kind: "message", T: JoinResponse, oneof: "message" },
    { no: 2, name: "answer", kind: "message", T: SessionDescription, oneof: "message" },
    { no: 3, name: "offer", kind: "message", T: SessionDescription, oneof: "message" },
    { no: 4, name: "trickle", kind: "message", T: TrickleRequest, oneof: "message" },
    { no: 5, name: "update", kind: "message", T: ParticipantUpdate, oneof: "message" },
    { no: 6, name: "track_published", kind: "message", T: TrackPublishedResponse, oneof: "message" },
    { no: 8, name: "leave", kind: "message", T: LeaveRequest, oneof: "message" },
    { no: 9, name: "mute", kind: "message", T: MuteTrackRequest, oneof: "message" },
    { no: 10, name: "speakers_changed", kind: "message", T: SpeakersChanged, oneof: "message" },
    { no: 11, name: "room_update", kind: "message", T: RoomUpdate, oneof: "message" },
    { no: 12, name: "connection_quality", kind: "message", T: ConnectionQualityUpdate, oneof: "message" },
    { no: 13, name: "stream_state_update", kind: "message", T: StreamStateUpdate, oneof: "message" },
    { no: 14, name: "subscribed_quality_update", kind: "message", T: SubscribedQualityUpdate, oneof: "message" },
    { no: 15, name: "subscription_permission_update", kind: "message", T: SubscriptionPermissionUpdate, oneof: "message" },
    { no: 16, name: "refresh_token", kind: "scalar", T: 9, oneof: "message" },
    { no: 17, name: "track_unpublished", kind: "message", T: TrackUnpublishedResponse, oneof: "message" },
    { no: 18, name: "pong", kind: "scalar", T: 3, oneof: "message" },
    { no: 19, name: "reconnect", kind: "message", T: ReconnectResponse, oneof: "message" },
    { no: 20, name: "pong_resp", kind: "message", T: Pong, oneof: "message" },
    { no: 21, name: "subscription_response", kind: "message", T: SubscriptionResponse, oneof: "message" },
    { no: 22, name: "request_response", kind: "message", T: RequestResponse, oneof: "message" },
    { no: 23, name: "track_subscribed", kind: "message", T: TrackSubscribed, oneof: "message" }
  ]
);
var SimulcastCodec = proto3.makeMessageType(
  "livekit.SimulcastCodec",
  () => [
    {
      no: 1,
      name: "codec",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "cid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var AddTrackRequest = proto3.makeMessageType(
  "livekit.AddTrackRequest",
  () => [
    {
      no: 1,
      name: "cid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "type", kind: "enum", T: proto3.getEnumType(TrackType) },
    {
      no: 4,
      name: "width",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 5,
      name: "height",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 6,
      name: "muted",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 7,
      name: "disable_dtx",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 8, name: "source", kind: "enum", T: proto3.getEnumType(TrackSource) },
    { no: 9, name: "layers", kind: "message", T: VideoLayer, repeated: true },
    { no: 10, name: "simulcast_codecs", kind: "message", T: SimulcastCodec, repeated: true },
    {
      no: 11,
      name: "sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 12,
      name: "stereo",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 13,
      name: "disable_red",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 14, name: "encryption", kind: "enum", T: proto3.getEnumType(Encryption_Type) },
    {
      no: 15,
      name: "stream",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 16, name: "backup_codec_policy", kind: "enum", T: proto3.getEnumType(BackupCodecPolicy) }
  ]
);
var TrickleRequest = proto3.makeMessageType(
  "livekit.TrickleRequest",
  () => [
    {
      no: 1,
      name: "candidateInit",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "target", kind: "enum", T: proto3.getEnumType(SignalTarget) },
    {
      no: 3,
      name: "final",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]
);
var MuteTrackRequest = proto3.makeMessageType(
  "livekit.MuteTrackRequest",
  () => [
    {
      no: 1,
      name: "sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "muted",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]
);
var JoinResponse = proto3.makeMessageType(
  "livekit.JoinResponse",
  () => [
    { no: 1, name: "room", kind: "message", T: Room },
    { no: 2, name: "participant", kind: "message", T: ParticipantInfo },
    { no: 3, name: "other_participants", kind: "message", T: ParticipantInfo, repeated: true },
    {
      no: 4,
      name: "server_version",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 5, name: "ice_servers", kind: "message", T: ICEServer, repeated: true },
    {
      no: 6,
      name: "subscriber_primary",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 7,
      name: "alternative_url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 8, name: "client_configuration", kind: "message", T: ClientConfiguration },
    {
      no: 9,
      name: "server_region",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 10,
      name: "ping_timeout",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 11,
      name: "ping_interval",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    { no: 12, name: "server_info", kind: "message", T: ServerInfo },
    {
      no: 13,
      name: "sif_trailer",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 14, name: "enabled_publish_codecs", kind: "message", T: Codec, repeated: true },
    {
      no: 15,
      name: "fast_publish",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]
);
var ReconnectResponse = proto3.makeMessageType(
  "livekit.ReconnectResponse",
  () => [
    { no: 1, name: "ice_servers", kind: "message", T: ICEServer, repeated: true },
    { no: 2, name: "client_configuration", kind: "message", T: ClientConfiguration }
  ]
);
var TrackPublishedResponse = proto3.makeMessageType(
  "livekit.TrackPublishedResponse",
  () => [
    {
      no: 1,
      name: "cid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "track", kind: "message", T: TrackInfo }
  ]
);
var TrackUnpublishedResponse = proto3.makeMessageType(
  "livekit.TrackUnpublishedResponse",
  () => [
    {
      no: 1,
      name: "track_sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var SessionDescription = proto3.makeMessageType(
  "livekit.SessionDescription",
  () => [
    {
      no: 1,
      name: "type",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "sdp",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var ParticipantUpdate = proto3.makeMessageType(
  "livekit.ParticipantUpdate",
  () => [
    { no: 1, name: "participants", kind: "message", T: ParticipantInfo, repeated: true }
  ]
);
var UpdateSubscription = proto3.makeMessageType(
  "livekit.UpdateSubscription",
  () => [
    { no: 1, name: "track_sids", kind: "scalar", T: 9, repeated: true },
    {
      no: 2,
      name: "subscribe",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 3, name: "participant_tracks", kind: "message", T: ParticipantTracks, repeated: true }
  ]
);
var UpdateTrackSettings = proto3.makeMessageType(
  "livekit.UpdateTrackSettings",
  () => [
    { no: 1, name: "track_sids", kind: "scalar", T: 9, repeated: true },
    {
      no: 3,
      name: "disabled",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 4, name: "quality", kind: "enum", T: proto3.getEnumType(VideoQuality) },
    {
      no: 5,
      name: "width",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 6,
      name: "height",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 7,
      name: "fps",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 8,
      name: "priority",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    }
  ]
);
var UpdateLocalAudioTrack = proto3.makeMessageType(
  "livekit.UpdateLocalAudioTrack",
  () => [
    {
      no: 1,
      name: "track_sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "features", kind: "enum", T: proto3.getEnumType(AudioTrackFeature), repeated: true }
  ]
);
var UpdateLocalVideoTrack = proto3.makeMessageType(
  "livekit.UpdateLocalVideoTrack",
  () => [
    {
      no: 1,
      name: "track_sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "width",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 3,
      name: "height",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    }
  ]
);
var LeaveRequest = proto3.makeMessageType(
  "livekit.LeaveRequest",
  () => [
    {
      no: 1,
      name: "can_reconnect",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 2, name: "reason", kind: "enum", T: proto3.getEnumType(DisconnectReason) },
    { no: 3, name: "action", kind: "enum", T: proto3.getEnumType(LeaveRequest_Action) },
    { no: 4, name: "regions", kind: "message", T: RegionSettings }
  ]
);
var LeaveRequest_Action = proto3.makeEnum(
  "livekit.LeaveRequest.Action",
  [
    { no: 0, name: "DISCONNECT" },
    { no: 1, name: "RESUME" },
    { no: 2, name: "RECONNECT" }
  ]
);
var UpdateVideoLayers = proto3.makeMessageType(
  "livekit.UpdateVideoLayers",
  () => [
    {
      no: 1,
      name: "track_sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "layers", kind: "message", T: VideoLayer, repeated: true }
  ]
);
var UpdateParticipantMetadata = proto3.makeMessageType(
  "livekit.UpdateParticipantMetadata",
  () => [
    {
      no: 1,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "attributes", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } },
    {
      no: 4,
      name: "request_id",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    }
  ]
);
var ICEServer = proto3.makeMessageType(
  "livekit.ICEServer",
  () => [
    { no: 1, name: "urls", kind: "scalar", T: 9, repeated: true },
    {
      no: 2,
      name: "username",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "credential",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var SpeakersChanged = proto3.makeMessageType(
  "livekit.SpeakersChanged",
  () => [
    { no: 1, name: "speakers", kind: "message", T: SpeakerInfo, repeated: true }
  ]
);
var RoomUpdate = proto3.makeMessageType(
  "livekit.RoomUpdate",
  () => [
    { no: 1, name: "room", kind: "message", T: Room }
  ]
);
var ConnectionQualityInfo = proto3.makeMessageType(
  "livekit.ConnectionQualityInfo",
  () => [
    {
      no: 1,
      name: "participant_sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "quality", kind: "enum", T: proto3.getEnumType(ConnectionQuality) },
    {
      no: 3,
      name: "score",
      kind: "scalar",
      T: 2
      /* ScalarType.FLOAT */
    }
  ]
);
var ConnectionQualityUpdate = proto3.makeMessageType(
  "livekit.ConnectionQualityUpdate",
  () => [
    { no: 1, name: "updates", kind: "message", T: ConnectionQualityInfo, repeated: true }
  ]
);
var StreamStateInfo = proto3.makeMessageType(
  "livekit.StreamStateInfo",
  () => [
    {
      no: 1,
      name: "participant_sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "track_sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "state", kind: "enum", T: proto3.getEnumType(StreamState) }
  ]
);
var StreamStateUpdate = proto3.makeMessageType(
  "livekit.StreamStateUpdate",
  () => [
    { no: 1, name: "stream_states", kind: "message", T: StreamStateInfo, repeated: true }
  ]
);
var SubscribedQuality = proto3.makeMessageType(
  "livekit.SubscribedQuality",
  () => [
    { no: 1, name: "quality", kind: "enum", T: proto3.getEnumType(VideoQuality) },
    {
      no: 2,
      name: "enabled",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]
);
var SubscribedCodec = proto3.makeMessageType(
  "livekit.SubscribedCodec",
  () => [
    {
      no: 1,
      name: "codec",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "qualities", kind: "message", T: SubscribedQuality, repeated: true }
  ]
);
var SubscribedQualityUpdate = proto3.makeMessageType(
  "livekit.SubscribedQualityUpdate",
  () => [
    {
      no: 1,
      name: "track_sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "subscribed_qualities", kind: "message", T: SubscribedQuality, repeated: true },
    { no: 3, name: "subscribed_codecs", kind: "message", T: SubscribedCodec, repeated: true }
  ]
);
var TrackPermission = proto3.makeMessageType(
  "livekit.TrackPermission",
  () => [
    {
      no: 1,
      name: "participant_sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "all_tracks",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 3, name: "track_sids", kind: "scalar", T: 9, repeated: true },
    {
      no: 4,
      name: "participant_identity",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var SubscriptionPermission = proto3.makeMessageType(
  "livekit.SubscriptionPermission",
  () => [
    {
      no: 1,
      name: "all_participants",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 2, name: "track_permissions", kind: "message", T: TrackPermission, repeated: true }
  ]
);
var SubscriptionPermissionUpdate = proto3.makeMessageType(
  "livekit.SubscriptionPermissionUpdate",
  () => [
    {
      no: 1,
      name: "participant_sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "track_sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "allowed",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]
);
var SyncState = proto3.makeMessageType(
  "livekit.SyncState",
  () => [
    { no: 1, name: "answer", kind: "message", T: SessionDescription },
    { no: 2, name: "subscription", kind: "message", T: UpdateSubscription },
    { no: 3, name: "publish_tracks", kind: "message", T: TrackPublishedResponse, repeated: true },
    { no: 4, name: "data_channels", kind: "message", T: DataChannelInfo, repeated: true },
    { no: 5, name: "offer", kind: "message", T: SessionDescription },
    { no: 6, name: "track_sids_disabled", kind: "scalar", T: 9, repeated: true }
  ]
);
var DataChannelInfo = proto3.makeMessageType(
  "livekit.DataChannelInfo",
  () => [
    {
      no: 1,
      name: "label",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "id",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    { no: 3, name: "target", kind: "enum", T: proto3.getEnumType(SignalTarget) }
  ]
);
var SimulateScenario = proto3.makeMessageType(
  "livekit.SimulateScenario",
  () => [
    { no: 1, name: "speaker_update", kind: "scalar", T: 5, oneof: "scenario" },
    { no: 2, name: "node_failure", kind: "scalar", T: 8, oneof: "scenario" },
    { no: 3, name: "migration", kind: "scalar", T: 8, oneof: "scenario" },
    { no: 4, name: "server_leave", kind: "scalar", T: 8, oneof: "scenario" },
    { no: 5, name: "switch_candidate_protocol", kind: "enum", T: proto3.getEnumType(CandidateProtocol), oneof: "scenario" },
    { no: 6, name: "subscriber_bandwidth", kind: "scalar", T: 3, oneof: "scenario" },
    { no: 7, name: "disconnect_signal_on_resume", kind: "scalar", T: 8, oneof: "scenario" },
    { no: 8, name: "disconnect_signal_on_resume_no_messages", kind: "scalar", T: 8, oneof: "scenario" },
    { no: 9, name: "leave_request_full_reconnect", kind: "scalar", T: 8, oneof: "scenario" }
  ]
);
var Ping = proto3.makeMessageType(
  "livekit.Ping",
  () => [
    {
      no: 1,
      name: "timestamp",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 2,
      name: "rtt",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    }
  ]
);
var Pong = proto3.makeMessageType(
  "livekit.Pong",
  () => [
    {
      no: 1,
      name: "last_ping_timestamp",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 2,
      name: "timestamp",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    }
  ]
);
var RegionSettings = proto3.makeMessageType(
  "livekit.RegionSettings",
  () => [
    { no: 1, name: "regions", kind: "message", T: RegionInfo, repeated: true }
  ]
);
var RegionInfo = proto3.makeMessageType(
  "livekit.RegionInfo",
  () => [
    {
      no: 1,
      name: "region",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "distance",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    }
  ]
);
var SubscriptionResponse = proto3.makeMessageType(
  "livekit.SubscriptionResponse",
  () => [
    {
      no: 1,
      name: "track_sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "err", kind: "enum", T: proto3.getEnumType(SubscriptionError) }
  ]
);
var RequestResponse = proto3.makeMessageType(
  "livekit.RequestResponse",
  () => [
    {
      no: 1,
      name: "request_id",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    { no: 2, name: "reason", kind: "enum", T: proto3.getEnumType(RequestResponse_Reason) },
    {
      no: 3,
      name: "message",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var RequestResponse_Reason = proto3.makeEnum(
  "livekit.RequestResponse.Reason",
  [
    { no: 0, name: "OK" },
    { no: 1, name: "NOT_FOUND" },
    { no: 2, name: "NOT_ALLOWED" },
    { no: 3, name: "LIMIT_EXCEEDED" }
  ]
);
var TrackSubscribed = proto3.makeMessageType(
  "livekit.TrackSubscribed",
  () => [
    {
      no: 1,
      name: "track_sid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var SIPStatusCode = proto3.makeEnum(
  "livekit.SIPStatusCode",
  [
    { no: 0, name: "SIP_STATUS_UNKNOWN" },
    { no: 100, name: "SIP_STATUS_TRYING" },
    { no: 180, name: "SIP_STATUS_RINGING" },
    { no: 181, name: "SIP_STATUS_CALL_IS_FORWARDED" },
    { no: 182, name: "SIP_STATUS_QUEUED" },
    { no: 183, name: "SIP_STATUS_SESSION_PROGRESS" },
    { no: 200, name: "SIP_STATUS_OK" },
    { no: 202, name: "SIP_STATUS_ACCEPTED" },
    { no: 301, name: "SIP_STATUS_MOVED_PERMANENTLY" },
    { no: 302, name: "SIP_STATUS_MOVED_TEMPORARILY" },
    { no: 305, name: "SIP_STATUS_USE_PROXY" },
    { no: 400, name: "SIP_STATUS_BAD_REQUEST" },
    { no: 401, name: "SIP_STATUS_UNAUTHORIZED" },
    { no: 402, name: "SIP_STATUS_PAYMENT_REQUIRED" },
    { no: 403, name: "SIP_STATUS_FORBIDDEN" },
    { no: 404, name: "SIP_STATUS_NOTFOUND" },
    { no: 405, name: "SIP_STATUS_METHOD_NOT_ALLOWED" },
    { no: 406, name: "SIP_STATUS_NOT_ACCEPTABLE" },
    { no: 407, name: "SIP_STATUS_PROXY_AUTH_REQUIRED" },
    { no: 408, name: "SIP_STATUS_REQUEST_TIMEOUT" },
    { no: 409, name: "SIP_STATUS_CONFLICT" },
    { no: 410, name: "SIP_STATUS_GONE" },
    { no: 413, name: "SIP_STATUS_REQUEST_ENTITY_TOO_LARGE" },
    { no: 414, name: "SIP_STATUS_REQUEST_URI_TOO_LONG" },
    { no: 415, name: "SIP_STATUS_UNSUPPORTED_MEDIA_TYPE" },
    { no: 416, name: "SIP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE" },
    { no: 420, name: "SIP_STATUS_BAD_EXTENSION" },
    { no: 421, name: "SIP_STATUS_EXTENSION_REQUIRED" },
    { no: 423, name: "SIP_STATUS_INTERVAL_TOO_BRIEF" },
    { no: 480, name: "SIP_STATUS_TEMPORARILY_UNAVAILABLE" },
    { no: 481, name: "SIP_STATUS_CALL_TRANSACTION_DOES_NOT_EXISTS" },
    { no: 482, name: "SIP_STATUS_LOOP_DETECTED" },
    { no: 483, name: "SIP_STATUS_TOO_MANY_HOPS" },
    { no: 484, name: "SIP_STATUS_ADDRESS_INCOMPLETE" },
    { no: 485, name: "SIP_STATUS_AMBIGUOUS" },
    { no: 486, name: "SIP_STATUS_BUSY_HERE" },
    { no: 487, name: "SIP_STATUS_REQUEST_TERMINATED" },
    { no: 488, name: "SIP_STATUS_NOT_ACCEPTABLE_HERE" },
    { no: 500, name: "SIP_STATUS_INTERNAL_SERVER_ERROR" },
    { no: 501, name: "SIP_STATUS_NOT_IMPLEMENTED" },
    { no: 502, name: "SIP_STATUS_BAD_GATEWAY" },
    { no: 503, name: "SIP_STATUS_SERVICE_UNAVAILABLE" },
    { no: 504, name: "SIP_STATUS_GATEWAY_TIMEOUT" },
    { no: 505, name: "SIP_STATUS_VERSION_NOT_SUPPORTED" },
    { no: 513, name: "SIP_STATUS_MESSAGE_TOO_LARGE" },
    { no: 600, name: "SIP_STATUS_GLOBAL_BUSY_EVERYWHERE" },
    { no: 603, name: "SIP_STATUS_GLOBAL_DECLINE" },
    { no: 604, name: "SIP_STATUS_GLOBAL_DOES_NOT_EXIST_ANYWHERE" },
    { no: 606, name: "SIP_STATUS_GLOBAL_NOT_ACCEPTABLE" }
  ]
);
var SIPTransport = proto3.makeEnum(
  "livekit.SIPTransport",
  [
    { no: 0, name: "SIP_TRANSPORT_AUTO" },
    { no: 1, name: "SIP_TRANSPORT_UDP" },
    { no: 2, name: "SIP_TRANSPORT_TCP" },
    { no: 3, name: "SIP_TRANSPORT_TLS" }
  ]
);
var SIPHeaderOptions = proto3.makeEnum(
  "livekit.SIPHeaderOptions",
  [
    { no: 0, name: "SIP_NO_HEADERS" },
    { no: 1, name: "SIP_X_HEADERS" },
    { no: 2, name: "SIP_ALL_HEADERS" }
  ]
);
var SIPMediaEncryption = proto3.makeEnum(
  "livekit.SIPMediaEncryption",
  [
    { no: 0, name: "SIP_MEDIA_ENCRYPT_DISABLE" },
    { no: 1, name: "SIP_MEDIA_ENCRYPT_ALLOW" },
    { no: 2, name: "SIP_MEDIA_ENCRYPT_REQUIRE" }
  ]
);
var SIPCallStatus = proto3.makeEnum(
  "livekit.SIPCallStatus",
  [
    { no: 0, name: "SCS_CALL_INCOMING" },
    { no: 1, name: "SCS_PARTICIPANT_JOINED" },
    { no: 2, name: "SCS_ACTIVE" },
    { no: 3, name: "SCS_DISCONNECTED" },
    { no: 4, name: "SCS_ERROR" }
  ]
);
var SIPFeature = proto3.makeEnum(
  "livekit.SIPFeature",
  [
    { no: 0, name: "NONE" },
    { no: 1, name: "KRISP_ENABLED" }
  ]
);
var SIPCallDirection = proto3.makeEnum(
  "livekit.SIPCallDirection",
  [
    { no: 0, name: "SCD_UNKNOWN" },
    { no: 1, name: "SCD_INBOUND" },
    { no: 2, name: "SCD_OUTBOUND" }
  ]
);
var SIPStatus = proto3.makeMessageType(
  "livekit.SIPStatus",
  () => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(SIPStatusCode) },
    {
      no: 2,
      name: "status",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var CreateSIPTrunkRequest = proto3.makeMessageType(
  "livekit.CreateSIPTrunkRequest",
  () => [
    { no: 1, name: "inbound_addresses", kind: "scalar", T: 9, repeated: true },
    {
      no: 2,
      name: "outbound_address",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "outbound_number",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 4, name: "inbound_numbers_regex", kind: "scalar", T: 9, repeated: true },
    { no: 9, name: "inbound_numbers", kind: "scalar", T: 9, repeated: true },
    {
      no: 5,
      name: "inbound_username",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "inbound_password",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: "outbound_username",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 8,
      name: "outbound_password",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 10,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 11,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var SIPTrunkInfo = proto3.makeMessageType(
  "livekit.SIPTrunkInfo",
  () => [
    {
      no: 1,
      name: "sip_trunk_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 14, name: "kind", kind: "enum", T: proto3.getEnumType(SIPTrunkInfo_TrunkKind) },
    { no: 2, name: "inbound_addresses", kind: "scalar", T: 9, repeated: true },
    {
      no: 3,
      name: "outbound_address",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "outbound_number",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 13, name: "transport", kind: "enum", T: proto3.getEnumType(SIPTransport) },
    { no: 5, name: "inbound_numbers_regex", kind: "scalar", T: 9, repeated: true },
    { no: 10, name: "inbound_numbers", kind: "scalar", T: 9, repeated: true },
    {
      no: 6,
      name: "inbound_username",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: "inbound_password",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 8,
      name: "outbound_username",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 9,
      name: "outbound_password",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 11,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 12,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var SIPTrunkInfo_TrunkKind = proto3.makeEnum(
  "livekit.SIPTrunkInfo.TrunkKind",
  [
    { no: 0, name: "TRUNK_LEGACY" },
    { no: 1, name: "TRUNK_INBOUND" },
    { no: 2, name: "TRUNK_OUTBOUND" }
  ]
);
var CreateSIPInboundTrunkRequest = proto3.makeMessageType(
  "livekit.CreateSIPInboundTrunkRequest",
  () => [
    { no: 1, name: "trunk", kind: "message", T: SIPInboundTrunkInfo }
  ]
);
var UpdateSIPInboundTrunkRequest = proto3.makeMessageType(
  "livekit.UpdateSIPInboundTrunkRequest",
  () => [
    {
      no: 1,
      name: "sip_trunk_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "replace", kind: "message", T: SIPInboundTrunkInfo, oneof: "action" },
    { no: 3, name: "update", kind: "message", T: SIPInboundTrunkUpdate, oneof: "action" }
  ]
);
var SIPInboundTrunkInfo = proto3.makeMessageType(
  "livekit.SIPInboundTrunkInfo",
  () => [
    {
      no: 1,
      name: "sip_trunk_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 4, name: "numbers", kind: "scalar", T: 9, repeated: true },
    { no: 5, name: "allowed_addresses", kind: "scalar", T: 9, repeated: true },
    { no: 6, name: "allowed_numbers", kind: "scalar", T: 9, repeated: true },
    {
      no: 7,
      name: "auth_username",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 8,
      name: "auth_password",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 9, name: "headers", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } },
    { no: 10, name: "headers_to_attributes", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } },
    { no: 14, name: "attributes_to_headers", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } },
    { no: 15, name: "include_headers", kind: "enum", T: proto3.getEnumType(SIPHeaderOptions) },
    { no: 11, name: "ringing_timeout", kind: "message", T: Duration },
    { no: 12, name: "max_call_duration", kind: "message", T: Duration },
    {
      no: 13,
      name: "krisp_enabled",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 16, name: "media_encryption", kind: "enum", T: proto3.getEnumType(SIPMediaEncryption) }
  ]
);
var SIPInboundTrunkUpdate = proto3.makeMessageType(
  "livekit.SIPInboundTrunkUpdate",
  () => [
    { no: 1, name: "numbers", kind: "message", T: ListUpdate },
    { no: 2, name: "allowed_addresses", kind: "message", T: ListUpdate },
    { no: 3, name: "allowed_numbers", kind: "message", T: ListUpdate },
    { no: 4, name: "auth_username", kind: "scalar", T: 9, opt: true },
    { no: 5, name: "auth_password", kind: "scalar", T: 9, opt: true },
    { no: 6, name: "name", kind: "scalar", T: 9, opt: true },
    { no: 7, name: "metadata", kind: "scalar", T: 9, opt: true }
  ]
);
var CreateSIPOutboundTrunkRequest = proto3.makeMessageType(
  "livekit.CreateSIPOutboundTrunkRequest",
  () => [
    { no: 1, name: "trunk", kind: "message", T: SIPOutboundTrunkInfo }
  ]
);
var UpdateSIPOutboundTrunkRequest = proto3.makeMessageType(
  "livekit.UpdateSIPOutboundTrunkRequest",
  () => [
    {
      no: 1,
      name: "sip_trunk_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "replace", kind: "message", T: SIPOutboundTrunkInfo, oneof: "action" },
    { no: 3, name: "update", kind: "message", T: SIPOutboundTrunkUpdate, oneof: "action" }
  ]
);
var SIPOutboundTrunkInfo = proto3.makeMessageType(
  "livekit.SIPOutboundTrunkInfo",
  () => [
    {
      no: 1,
      name: "sip_trunk_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "address",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 5, name: "transport", kind: "enum", T: proto3.getEnumType(SIPTransport) },
    { no: 6, name: "numbers", kind: "scalar", T: 9, repeated: true },
    {
      no: 7,
      name: "auth_username",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 8,
      name: "auth_password",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 9, name: "headers", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } },
    { no: 10, name: "headers_to_attributes", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } },
    { no: 11, name: "attributes_to_headers", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } },
    { no: 12, name: "include_headers", kind: "enum", T: proto3.getEnumType(SIPHeaderOptions) },
    { no: 13, name: "media_encryption", kind: "enum", T: proto3.getEnumType(SIPMediaEncryption) }
  ]
);
var SIPOutboundTrunkUpdate = proto3.makeMessageType(
  "livekit.SIPOutboundTrunkUpdate",
  () => [
    { no: 1, name: "address", kind: "scalar", T: 9, opt: true },
    { no: 2, name: "transport", kind: "enum", T: proto3.getEnumType(SIPTransport), opt: true },
    { no: 3, name: "numbers", kind: "message", T: ListUpdate },
    { no: 4, name: "auth_username", kind: "scalar", T: 9, opt: true },
    { no: 5, name: "auth_password", kind: "scalar", T: 9, opt: true },
    { no: 6, name: "name", kind: "scalar", T: 9, opt: true },
    { no: 7, name: "metadata", kind: "scalar", T: 9, opt: true }
  ]
);
var GetSIPInboundTrunkRequest = proto3.makeMessageType(
  "livekit.GetSIPInboundTrunkRequest",
  () => [
    {
      no: 1,
      name: "sip_trunk_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var GetSIPInboundTrunkResponse = proto3.makeMessageType(
  "livekit.GetSIPInboundTrunkResponse",
  () => [
    { no: 1, name: "trunk", kind: "message", T: SIPInboundTrunkInfo }
  ]
);
var GetSIPOutboundTrunkRequest = proto3.makeMessageType(
  "livekit.GetSIPOutboundTrunkRequest",
  () => [
    {
      no: 1,
      name: "sip_trunk_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var GetSIPOutboundTrunkResponse = proto3.makeMessageType(
  "livekit.GetSIPOutboundTrunkResponse",
  () => [
    { no: 1, name: "trunk", kind: "message", T: SIPOutboundTrunkInfo }
  ]
);
var ListSIPTrunkRequest = proto3.makeMessageType(
  "livekit.ListSIPTrunkRequest",
  () => [
    { no: 1, name: "page", kind: "message", T: Pagination }
  ]
);
var ListSIPTrunkResponse = proto3.makeMessageType(
  "livekit.ListSIPTrunkResponse",
  () => [
    { no: 1, name: "items", kind: "message", T: SIPTrunkInfo, repeated: true }
  ]
);
var ListSIPInboundTrunkRequest = proto3.makeMessageType(
  "livekit.ListSIPInboundTrunkRequest",
  () => [
    { no: 3, name: "page", kind: "message", T: Pagination },
    { no: 1, name: "trunk_ids", kind: "scalar", T: 9, repeated: true },
    { no: 2, name: "numbers", kind: "scalar", T: 9, repeated: true }
  ]
);
var ListSIPInboundTrunkResponse = proto3.makeMessageType(
  "livekit.ListSIPInboundTrunkResponse",
  () => [
    { no: 1, name: "items", kind: "message", T: SIPInboundTrunkInfo, repeated: true }
  ]
);
var ListSIPOutboundTrunkRequest = proto3.makeMessageType(
  "livekit.ListSIPOutboundTrunkRequest",
  () => [
    { no: 3, name: "page", kind: "message", T: Pagination },
    { no: 1, name: "trunk_ids", kind: "scalar", T: 9, repeated: true },
    { no: 2, name: "numbers", kind: "scalar", T: 9, repeated: true }
  ]
);
var ListSIPOutboundTrunkResponse = proto3.makeMessageType(
  "livekit.ListSIPOutboundTrunkResponse",
  () => [
    { no: 1, name: "items", kind: "message", T: SIPOutboundTrunkInfo, repeated: true }
  ]
);
var DeleteSIPTrunkRequest = proto3.makeMessageType(
  "livekit.DeleteSIPTrunkRequest",
  () => [
    {
      no: 1,
      name: "sip_trunk_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var SIPDispatchRuleDirect = proto3.makeMessageType(
  "livekit.SIPDispatchRuleDirect",
  () => [
    {
      no: 1,
      name: "room_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "pin",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var SIPDispatchRuleIndividual = proto3.makeMessageType(
  "livekit.SIPDispatchRuleIndividual",
  () => [
    {
      no: 1,
      name: "room_prefix",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "pin",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var SIPDispatchRuleCallee = proto3.makeMessageType(
  "livekit.SIPDispatchRuleCallee",
  () => [
    {
      no: 1,
      name: "room_prefix",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "pin",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "randomize",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]
);
var SIPDispatchRule = proto3.makeMessageType(
  "livekit.SIPDispatchRule",
  () => [
    { no: 1, name: "dispatch_rule_direct", kind: "message", T: SIPDispatchRuleDirect, oneof: "rule" },
    { no: 2, name: "dispatch_rule_individual", kind: "message", T: SIPDispatchRuleIndividual, oneof: "rule" },
    { no: 3, name: "dispatch_rule_callee", kind: "message", T: SIPDispatchRuleCallee, oneof: "rule" }
  ]
);
var CreateSIPDispatchRuleRequest = proto3.makeMessageType(
  "livekit.CreateSIPDispatchRuleRequest",
  () => [
    { no: 10, name: "dispatch_rule", kind: "message", T: SIPDispatchRuleInfo },
    { no: 1, name: "rule", kind: "message", T: SIPDispatchRule },
    { no: 2, name: "trunk_ids", kind: "scalar", T: 9, repeated: true },
    {
      no: 3,
      name: "hide_phone_number",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 6, name: "inbound_numbers", kind: "scalar", T: 9, repeated: true },
    {
      no: 4,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 7, name: "attributes", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } },
    {
      no: 8,
      name: "room_preset",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 9, name: "room_config", kind: "message", T: RoomConfiguration }
  ]
);
var UpdateSIPDispatchRuleRequest = proto3.makeMessageType(
  "livekit.UpdateSIPDispatchRuleRequest",
  () => [
    {
      no: 1,
      name: "sip_dispatch_rule_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "replace", kind: "message", T: SIPDispatchRuleInfo, oneof: "action" },
    { no: 3, name: "update", kind: "message", T: SIPDispatchRuleUpdate, oneof: "action" }
  ]
);
var SIPDispatchRuleInfo = proto3.makeMessageType(
  "livekit.SIPDispatchRuleInfo",
  () => [
    {
      no: 1,
      name: "sip_dispatch_rule_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "rule", kind: "message", T: SIPDispatchRule },
    { no: 3, name: "trunk_ids", kind: "scalar", T: 9, repeated: true },
    {
      no: 4,
      name: "hide_phone_number",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 7, name: "inbound_numbers", kind: "scalar", T: 9, repeated: true },
    {
      no: 5,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 8, name: "attributes", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } },
    {
      no: 9,
      name: "room_preset",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 10, name: "room_config", kind: "message", T: RoomConfiguration },
    {
      no: 11,
      name: "krisp_enabled",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 12, name: "media_encryption", kind: "enum", T: proto3.getEnumType(SIPMediaEncryption) }
  ]
);
var SIPDispatchRuleUpdate = proto3.makeMessageType(
  "livekit.SIPDispatchRuleUpdate",
  () => [
    { no: 1, name: "trunk_ids", kind: "message", T: ListUpdate },
    { no: 2, name: "rule", kind: "message", T: SIPDispatchRule },
    { no: 3, name: "name", kind: "scalar", T: 9, opt: true },
    { no: 4, name: "metadata", kind: "scalar", T: 9, opt: true },
    { no: 5, name: "attributes", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } }
  ]
);
var ListSIPDispatchRuleRequest = proto3.makeMessageType(
  "livekit.ListSIPDispatchRuleRequest",
  () => [
    { no: 3, name: "page", kind: "message", T: Pagination },
    { no: 1, name: "dispatch_rule_ids", kind: "scalar", T: 9, repeated: true },
    { no: 2, name: "trunk_ids", kind: "scalar", T: 9, repeated: true }
  ]
);
var ListSIPDispatchRuleResponse = proto3.makeMessageType(
  "livekit.ListSIPDispatchRuleResponse",
  () => [
    { no: 1, name: "items", kind: "message", T: SIPDispatchRuleInfo, repeated: true }
  ]
);
var DeleteSIPDispatchRuleRequest = proto3.makeMessageType(
  "livekit.DeleteSIPDispatchRuleRequest",
  () => [
    {
      no: 1,
      name: "sip_dispatch_rule_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var SIPOutboundConfig = proto3.makeMessageType(
  "livekit.SIPOutboundConfig",
  () => [
    {
      no: 1,
      name: "hostname",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "transport", kind: "enum", T: proto3.getEnumType(SIPTransport) },
    {
      no: 3,
      name: "auth_username",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "auth_password",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 5, name: "headers_to_attributes", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } },
    { no: 6, name: "attributes_to_headers", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } }
  ]
);
var CreateSIPParticipantRequest = proto3.makeMessageType(
  "livekit.CreateSIPParticipantRequest",
  () => [
    {
      no: 1,
      name: "sip_trunk_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 20, name: "trunk", kind: "message", T: SIPOutboundConfig },
    {
      no: 2,
      name: "sip_call_to",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 15,
      name: "sip_number",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "room_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "participant_identity",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: "participant_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 8,
      name: "participant_metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 9, name: "participant_attributes", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } },
    {
      no: 5,
      name: "dtmf",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "play_ringtone",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 13,
      name: "play_dialtone",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 10,
      name: "hide_phone_number",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 16, name: "headers", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } },
    { no: 17, name: "include_headers", kind: "enum", T: proto3.getEnumType(SIPHeaderOptions) },
    { no: 11, name: "ringing_timeout", kind: "message", T: Duration },
    { no: 12, name: "max_call_duration", kind: "message", T: Duration },
    {
      no: 14,
      name: "krisp_enabled",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 18, name: "media_encryption", kind: "enum", T: proto3.getEnumType(SIPMediaEncryption) },
    {
      no: 19,
      name: "wait_until_answered",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]
);
var SIPParticipantInfo = proto3.makeMessageType(
  "livekit.SIPParticipantInfo",
  () => [
    {
      no: 1,
      name: "participant_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "participant_identity",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "room_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "sip_call_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var TransferSIPParticipantRequest = proto3.makeMessageType(
  "livekit.TransferSIPParticipantRequest",
  () => [
    {
      no: 1,
      name: "participant_identity",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "room_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "transfer_to",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "play_dialtone",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 5, name: "headers", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } }
  ]
);
var SIPCallInfo = proto3.makeMessageType(
  "livekit.SIPCallInfo",
  () => [
    {
      no: 1,
      name: "call_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "trunk_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 16,
      name: "dispatch_rule_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 17,
      name: "region",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "room_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "room_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "participant_identity",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 18, name: "participant_attributes", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } },
    { no: 6, name: "from_uri", kind: "message", T: SIPUri },
    { no: 7, name: "to_uri", kind: "message", T: SIPUri },
    {
      no: 9,
      name: "created_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 10,
      name: "started_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 11,
      name: "ended_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    { no: 14, name: "enabled_features", kind: "enum", T: proto3.getEnumType(SIPFeature), repeated: true },
    { no: 15, name: "call_direction", kind: "enum", T: proto3.getEnumType(SIPCallDirection) },
    { no: 8, name: "call_status", kind: "enum", T: proto3.getEnumType(SIPCallStatus) },
    {
      no: 22,
      name: "created_at_ns",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 23,
      name: "started_at_ns",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 24,
      name: "ended_at_ns",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    { no: 12, name: "disconnect_reason", kind: "enum", T: proto3.getEnumType(DisconnectReason) },
    {
      no: 13,
      name: "error",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 19, name: "call_status_code", kind: "message", T: SIPStatus },
    {
      no: 20,
      name: "audio_codec",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 21,
      name: "media_encryption",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]
);
var SIPUri = proto3.makeMessageType(
  "livekit.SIPUri",
  () => [
    {
      no: 1,
      name: "user",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "host",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "ip",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "port",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    { no: 5, name: "transport", kind: "enum", T: proto3.getEnumType(SIPTransport) }
  ]
);
var WebhookEvent = proto3.makeMessageType(
  "livekit.WebhookEvent",
  () => [
    {
      no: 1,
      name: "event",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "room", kind: "message", T: Room },
    { no: 3, name: "participant", kind: "message", T: ParticipantInfo },
    { no: 9, name: "egress_info", kind: "message", T: EgressInfo },
    { no: 10, name: "ingress_info", kind: "message", T: IngressInfo },
    { no: 8, name: "track", kind: "message", T: TrackInfo },
    {
      no: 6,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: "created_at",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 11,
      name: "num_dropped",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]
);

// node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default = crypto;
var isCryptoKey = (key) => key instanceof CryptoKey;

// node_modules/jose/dist/browser/lib/buffer_utils.js
var encoder = new TextEncoder();
var decoder = new TextDecoder();
var MAX_INT32 = 2 ** 32;
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  for (const buffer of buffers) {
    buf.set(buffer, i);
    i += buffer.length;
  }
  return buf;
}

// node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase64 = (input) => {
  let unencoded = input;
  if (typeof unencoded === "string") {
    unencoded = encoder.encode(unencoded);
  }
  const CHUNK_SIZE = 32768;
  const arr = [];
  for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {
    arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
  }
  return btoa(arr.join(""));
};
var encode = (input) => {
  return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
};
var decodeBase64 = (encoded) => {
  const binary = atob(encoded);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
};
var decode = (input) => {
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return decodeBase64(encoded);
  } catch {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
};

// node_modules/jose/dist/browser/util/errors.js
var errors_exports = {};
__export(errors_exports, {
  JOSEAlgNotAllowed: () => JOSEAlgNotAllowed,
  JOSEError: () => JOSEError,
  JOSENotSupported: () => JOSENotSupported,
  JWEDecryptionFailed: () => JWEDecryptionFailed,
  JWEInvalid: () => JWEInvalid,
  JWKInvalid: () => JWKInvalid,
  JWKSInvalid: () => JWKSInvalid,
  JWKSMultipleMatchingKeys: () => JWKSMultipleMatchingKeys,
  JWKSNoMatchingKey: () => JWKSNoMatchingKey,
  JWKSTimeout: () => JWKSTimeout,
  JWSInvalid: () => JWSInvalid,
  JWSSignatureVerificationFailed: () => JWSSignatureVerificationFailed,
  JWTClaimValidationFailed: () => JWTClaimValidationFailed,
  JWTExpired: () => JWTExpired,
  JWTInvalid: () => JWTInvalid
});
var JOSEError = class extends Error {
  constructor(message2, options) {
    var _a2;
    super(message2, options);
    this.code = "ERR_JOSE_GENERIC";
    this.name = this.constructor.name;
    (_a2 = Error.captureStackTrace) == null ? void 0 : _a2.call(Error, this, this.constructor);
  }
};
JOSEError.code = "ERR_JOSE_GENERIC";
var JWTClaimValidationFailed = class extends JOSEError {
  constructor(message2, payload, claim = "unspecified", reason = "unspecified") {
    super(message2, { cause: { claim, reason, payload } });
    this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
    this.claim = claim;
    this.reason = reason;
    this.payload = payload;
  }
};
JWTClaimValidationFailed.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
var JWTExpired = class extends JOSEError {
  constructor(message2, payload, claim = "unspecified", reason = "unspecified") {
    super(message2, { cause: { claim, reason, payload } });
    this.code = "ERR_JWT_EXPIRED";
    this.claim = claim;
    this.reason = reason;
    this.payload = payload;
  }
};
JWTExpired.code = "ERR_JWT_EXPIRED";
var JOSEAlgNotAllowed = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
  }
};
JOSEAlgNotAllowed.code = "ERR_JOSE_ALG_NOT_ALLOWED";
var JOSENotSupported = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
};
JOSENotSupported.code = "ERR_JOSE_NOT_SUPPORTED";
var JWEDecryptionFailed = class extends JOSEError {
  constructor(message2 = "decryption operation failed", options) {
    super(message2, options);
    this.code = "ERR_JWE_DECRYPTION_FAILED";
  }
};
JWEDecryptionFailed.code = "ERR_JWE_DECRYPTION_FAILED";
var JWEInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWE_INVALID";
  }
};
JWEInvalid.code = "ERR_JWE_INVALID";
var JWSInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_INVALID";
  }
};
JWSInvalid.code = "ERR_JWS_INVALID";
var JWTInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWT_INVALID";
  }
};
JWTInvalid.code = "ERR_JWT_INVALID";
var JWKInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWK_INVALID";
  }
};
JWKInvalid.code = "ERR_JWK_INVALID";
var JWKSInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWKS_INVALID";
  }
};
JWKSInvalid.code = "ERR_JWKS_INVALID";
var JWKSNoMatchingKey = class extends JOSEError {
  constructor(message2 = "no applicable key found in the JSON Web Key Set", options) {
    super(message2, options);
    this.code = "ERR_JWKS_NO_MATCHING_KEY";
  }
};
JWKSNoMatchingKey.code = "ERR_JWKS_NO_MATCHING_KEY";
var JWKSMultipleMatchingKeys = class extends JOSEError {
  constructor(message2 = "multiple matching keys found in the JSON Web Key Set", options) {
    super(message2, options);
    this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
  }
};
JWKSMultipleMatchingKeys.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
var JWKSTimeout = class extends JOSEError {
  constructor(message2 = "request timed out", options) {
    super(message2, options);
    this.code = "ERR_JWKS_TIMEOUT";
  }
};
JWKSTimeout.code = "ERR_JWKS_TIMEOUT";
var JWSSignatureVerificationFailed = class extends JOSEError {
  constructor(message2 = "signature verification failed", options) {
    super(message2, options);
    this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  }
};
JWSSignatureVerificationFailed.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";

// node_modules/jose/dist/browser/runtime/random.js
var random_default = webcrypto_default.getRandomValues.bind(webcrypto_default);

// node_modules/jose/dist/browser/lib/crypto_key.js
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
function getHashLength(hash) {
  return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "Ed25519": {
      if (!isAlgorithm(key.algorithm, "Ed25519"))
        throw unusable("Ed25519");
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}

// node_modules/jose/dist/browser/lib/invalid_key_input.js
function message(msg, actual, ...types2) {
  var _a2;
  types2 = types2.filter(Boolean);
  if (types2.length > 2) {
    const last = types2.pop();
    msg += `one of type ${types2.join(", ")}, or ${last}.`;
  } else if (types2.length === 2) {
    msg += `one of type ${types2[0]} or ${types2[1]}.`;
  } else {
    msg += `of type ${types2[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if ((_a2 = actual.constructor) == null ? void 0 : _a2.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
var invalid_key_input_default = (actual, ...types2) => {
  return message("Key must be ", actual, ...types2);
};
function withAlg(alg, actual, ...types2) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types2);
}

// node_modules/jose/dist/browser/runtime/is_key_like.js
var is_key_like_default = (key) => {
  if (isCryptoKey(key)) {
    return true;
  }
  return (key == null ? void 0 : key[Symbol.toStringTag]) === "KeyObject";
};
var types = ["CryptoKey"];

// node_modules/jose/dist/browser/lib/is_disjoint.js
var isDisjoint = (...headers) => {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
};
var is_disjoint_default = isDisjoint;

// node_modules/jose/dist/browser/lib/is_object.js
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}

// node_modules/jose/dist/browser/runtime/check_key_length.js
var check_key_length_default = (alg, key) => {
  if (alg.startsWith("RS") || alg.startsWith("PS")) {
    const { modulusLength } = key.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  }
};

// node_modules/jose/dist/browser/lib/is_jwk.js
function isJWK(key) {
  return isObject(key) && typeof key.kty === "string";
}
function isPrivateJWK(key) {
  return key.kty !== "oct" && typeof key.d === "string";
}
function isPublicJWK(key) {
  return key.kty !== "oct" && typeof key.d === "undefined";
}
function isSecretJWK(key) {
  return isJWK(key) && key.kty === "oct" && typeof key.k === "string";
}

// node_modules/jose/dist/browser/runtime/jwk_to_key.js
function subtleMapping(jwk) {
  let algorithm;
  let keyUsages;
  switch (jwk.kty) {
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "OKP": {
      switch (jwk.alg) {
        case "Ed25519":
          algorithm = { name: "Ed25519" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "EdDSA":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm, keyUsages };
}
var parse = async (jwk) => {
  if (!jwk.alg) {
    throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
  }
  const { algorithm, keyUsages } = subtleMapping(jwk);
  const rest = [
    algorithm,
    jwk.ext ?? false,
    jwk.key_ops ?? keyUsages
  ];
  const keyData = { ...jwk };
  delete keyData.alg;
  delete keyData.use;
  return webcrypto_default.subtle.importKey("jwk", keyData, ...rest);
};
var jwk_to_key_default = parse;

// node_modules/jose/dist/browser/runtime/normalize_key.js
var exportKeyValue = (k) => decode(k);
var privCache;
var pubCache;
var isKeyObject = (key) => {
  return (key == null ? void 0 : key[Symbol.toStringTag]) === "KeyObject";
};
var importAndCache = async (cache, key, jwk, alg, freeze = false) => {
  let cached = cache.get(key);
  if (cached == null ? void 0 : cached[alg]) {
    return cached[alg];
  }
  const cryptoKey = await jwk_to_key_default({ ...jwk, alg });
  if (freeze)
    Object.freeze(key);
  if (!cached) {
    cache.set(key, { [alg]: cryptoKey });
  } else {
    cached[alg] = cryptoKey;
  }
  return cryptoKey;
};
var normalizePublicKey = (key, alg) => {
  if (isKeyObject(key)) {
    let jwk = key.export({ format: "jwk" });
    delete jwk.d;
    delete jwk.dp;
    delete jwk.dq;
    delete jwk.p;
    delete jwk.q;
    delete jwk.qi;
    if (jwk.k) {
      return exportKeyValue(jwk.k);
    }
    pubCache || (pubCache = /* @__PURE__ */ new WeakMap());
    return importAndCache(pubCache, key, jwk, alg);
  }
  if (isJWK(key)) {
    if (key.k)
      return decode(key.k);
    pubCache || (pubCache = /* @__PURE__ */ new WeakMap());
    const cryptoKey = importAndCache(pubCache, key, key, alg, true);
    return cryptoKey;
  }
  return key;
};
var normalizePrivateKey = (key, alg) => {
  if (isKeyObject(key)) {
    let jwk = key.export({ format: "jwk" });
    if (jwk.k) {
      return exportKeyValue(jwk.k);
    }
    privCache || (privCache = /* @__PURE__ */ new WeakMap());
    return importAndCache(privCache, key, jwk, alg);
  }
  if (isJWK(key)) {
    if (key.k)
      return decode(key.k);
    privCache || (privCache = /* @__PURE__ */ new WeakMap());
    const cryptoKey = importAndCache(privCache, key, key, alg, true);
    return cryptoKey;
  }
  return key;
};
var normalize_key_default = { normalizePublicKey, normalizePrivateKey };

// node_modules/jose/dist/browser/key/import.js
async function importJWK(jwk, alg) {
  if (!isObject(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  alg || (alg = jwk.alg);
  switch (jwk.kty) {
    case "oct":
      if (typeof jwk.k !== "string" || !jwk.k) {
        throw new TypeError('missing "k" (Key Value) Parameter value');
      }
      return decode(jwk.k);
    case "RSA":
      if ("oth" in jwk && jwk.oth !== void 0) {
        throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
      }
    case "EC":
    case "OKP":
      return jwk_to_key_default({ ...jwk, alg });
    default:
      throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
  }
}

// node_modules/jose/dist/browser/lib/check_key_type.js
var tag = (key) => key == null ? void 0 : key[Symbol.toStringTag];
var jwkMatchesOp = (alg, key, usage) => {
  var _a2, _b2;
  if (key.use !== void 0 && key.use !== "sig") {
    throw new TypeError("Invalid key for this operation, when present its use must be sig");
  }
  if (key.key_ops !== void 0 && ((_b2 = (_a2 = key.key_ops).includes) == null ? void 0 : _b2.call(_a2, usage)) !== true) {
    throw new TypeError(`Invalid key for this operation, when present its key_ops must include ${usage}`);
  }
  if (key.alg !== void 0 && key.alg !== alg) {
    throw new TypeError(`Invalid key for this operation, when present its alg must be ${alg}`);
  }
  return true;
};
var symmetricTypeCheck = (alg, key, usage, allowJwk) => {
  if (key instanceof Uint8Array)
    return;
  if (allowJwk && isJWK(key)) {
    if (isSecretJWK(key) && jwkMatchesOp(alg, key, usage))
      return;
    throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present`);
  }
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types, "Uint8Array", allowJwk ? "JSON Web Key" : null));
  }
  if (key.type !== "secret") {
    throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type "secret"`);
  }
};
var asymmetricTypeCheck = (alg, key, usage, allowJwk) => {
  if (allowJwk && isJWK(key)) {
    switch (usage) {
      case "sign":
        if (isPrivateJWK(key) && jwkMatchesOp(alg, key, usage))
          return;
        throw new TypeError(`JSON Web Key for this operation be a private JWK`);
      case "verify":
        if (isPublicJWK(key) && jwkMatchesOp(alg, key, usage))
          return;
        throw new TypeError(`JSON Web Key for this operation be a public JWK`);
    }
  }
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types, allowJwk ? "JSON Web Key" : null));
  }
  if (key.type === "secret") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (usage === "sign" && key.type === "public") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type "private"`);
  }
  if (usage === "decrypt" && key.type === "public") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type "private"`);
  }
  if (key.algorithm && usage === "verify" && key.type === "private") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type "public"`);
  }
  if (key.algorithm && usage === "encrypt" && key.type === "private") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type "public"`);
  }
};
function checkKeyType(allowJwk, alg, key, usage) {
  const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
  if (symmetric) {
    symmetricTypeCheck(alg, key, usage, allowJwk);
  } else {
    asymmetricTypeCheck(alg, key, usage, allowJwk);
  }
}
var check_key_type_default = checkKeyType.bind(void 0, false);
var checkKeyTypeWithJwk = checkKeyType.bind(void 0, true);

// node_modules/jose/dist/browser/lib/validate_crit.js
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && (protectedHeader == null ? void 0 : protectedHeader.crit) === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    }
    if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
var validate_crit_default = validateCrit;

// node_modules/jose/dist/browser/lib/validate_algorithms.js
var validateAlgorithms = (option, algorithms) => {
  if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
    throw new TypeError(`"${option}" option must be an array of strings`);
  }
  if (!algorithms) {
    return void 0;
  }
  return new Set(algorithms);
};
var validate_algorithms_default = validateAlgorithms;

// node_modules/jose/dist/browser/lib/private_symbols.js
var unprotected = Symbol();

// node_modules/jose/dist/browser/runtime/subtle_dsa.js
function subtleDsa(alg, algorithm) {
  const hash = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "Ed25519":
      return { name: "Ed25519" };
    case "EdDSA":
      return { name: algorithm.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}

// node_modules/jose/dist/browser/runtime/get_sign_verify_key.js
async function getCryptoKey(alg, key, usage) {
  if (usage === "sign") {
    key = await normalize_key_default.normalizePrivateKey(key, alg);
  }
  if (usage === "verify") {
    key = await normalize_key_default.normalizePublicKey(key, alg);
  }
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types));
    }
    return webcrypto_default.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array", "JSON Web Key"));
}

// node_modules/jose/dist/browser/runtime/verify.js
var verify = async (alg, key, signature, data) => {
  const cryptoKey = await getCryptoKey(alg, key, "verify");
  check_key_length_default(alg, cryptoKey);
  const algorithm = subtleDsa(alg, cryptoKey.algorithm);
  try {
    return await webcrypto_default.subtle.verify(algorithm, cryptoKey, signature, data);
  } catch {
    return false;
  }
};
var verify_default = verify;

// node_modules/jose/dist/browser/jws/flattened/verify.js
async function flattenedVerify(jws, key, options) {
  if (!isObject(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === void 0 && jws.header === void 0) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== void 0 && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === void 0) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== void 0 && !isObject(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options == null ? void 0 : options.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validate_algorithms_default("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
    checkKeyTypeWithJwk(alg, key, "verify");
    if (isJWK(key)) {
      key = await importJWK(key, alg);
    }
  } else {
    checkKeyTypeWithJwk(alg, key, "verify");
  }
  const data = concat(encoder.encode(jws.protected ?? ""), encoder.encode("."), typeof jws.payload === "string" ? encoder.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode(jws.signature);
  } catch {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const verified = await verify_default(alg, key, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed();
  }
  let payload;
  if (b64) {
    try {
      payload = decode(jws.payload);
    } catch {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== void 0) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}

// node_modules/jose/dist/browser/jws/compact/verify.js
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}

// node_modules/jose/dist/browser/lib/epoch.js
var epoch_default = (date) => Math.floor(date.getTime() / 1e3);

// node_modules/jose/dist/browser/lib/secs.js
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;
var REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
var secs_default = (str) => {
  const matched = REGEX.exec(str);
  if (!matched || matched[4] && matched[1]) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[2]);
  const unit = matched[3].toLowerCase();
  let numericDate;
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      numericDate = Math.round(value);
      break;
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      numericDate = Math.round(value * minute);
      break;
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      numericDate = Math.round(value * hour);
      break;
    case "day":
    case "days":
    case "d":
      numericDate = Math.round(value * day);
      break;
    case "week":
    case "weeks":
    case "w":
      numericDate = Math.round(value * week);
      break;
    default:
      numericDate = Math.round(value * year);
      break;
  }
  if (matched[1] === "-" || matched[4] === "ago") {
    return -numericDate;
  }
  return numericDate;
};

// node_modules/jose/dist/browser/lib/jwt_claims_set.js
var normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
var checkAudiencePresence = (audPayload, audOption) => {
  if (typeof audPayload === "string") {
    return audOption.includes(audPayload);
  }
  if (Array.isArray(audPayload)) {
    return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
  }
  return false;
};
var jwt_claims_set_default = (protectedHeader, encodedPayload, options = {}) => {
  let payload;
  try {
    payload = JSON.parse(decoder.decode(encodedPayload));
  } catch {
  }
  if (!isObject(payload)) {
    throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
  }
  const { typ } = options;
  if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
    throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', payload, "typ", "check_failed");
  }
  const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
  const presenceCheck = [...requiredClaims];
  if (maxTokenAge !== void 0)
    presenceCheck.push("iat");
  if (audience !== void 0)
    presenceCheck.push("aud");
  if (subject !== void 0)
    presenceCheck.push("sub");
  if (issuer !== void 0)
    presenceCheck.push("iss");
  for (const claim of new Set(presenceCheck.reverse())) {
    if (!(claim in payload)) {
      throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, payload, claim, "missing");
    }
  }
  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
    throw new JWTClaimValidationFailed('unexpected "iss" claim value', payload, "iss", "check_failed");
  }
  if (subject && payload.sub !== subject) {
    throw new JWTClaimValidationFailed('unexpected "sub" claim value', payload, "sub", "check_failed");
  }
  if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
    throw new JWTClaimValidationFailed('unexpected "aud" claim value', payload, "aud", "check_failed");
  }
  let tolerance;
  switch (typeof options.clockTolerance) {
    case "string":
      tolerance = secs_default(options.clockTolerance);
      break;
    case "number":
      tolerance = options.clockTolerance;
      break;
    case "undefined":
      tolerance = 0;
      break;
    default:
      throw new TypeError("Invalid clockTolerance option type");
  }
  const { currentDate } = options;
  const now = epoch_default(currentDate || /* @__PURE__ */ new Date());
  if ((payload.iat !== void 0 || maxTokenAge) && typeof payload.iat !== "number") {
    throw new JWTClaimValidationFailed('"iat" claim must be a number', payload, "iat", "invalid");
  }
  if (payload.nbf !== void 0) {
    if (typeof payload.nbf !== "number") {
      throw new JWTClaimValidationFailed('"nbf" claim must be a number', payload, "nbf", "invalid");
    }
    if (payload.nbf > now + tolerance) {
      throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', payload, "nbf", "check_failed");
    }
  }
  if (payload.exp !== void 0) {
    if (typeof payload.exp !== "number") {
      throw new JWTClaimValidationFailed('"exp" claim must be a number', payload, "exp", "invalid");
    }
    if (payload.exp <= now - tolerance) {
      throw new JWTExpired('"exp" claim timestamp check failed', payload, "exp", "check_failed");
    }
  }
  if (maxTokenAge) {
    const age = now - payload.iat;
    const max = typeof maxTokenAge === "number" ? maxTokenAge : secs_default(maxTokenAge);
    if (age - tolerance > max) {
      throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', payload, "iat", "check_failed");
    }
    if (age < 0 - tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', payload, "iat", "check_failed");
    }
  }
  return payload;
};

// node_modules/jose/dist/browser/jwt/verify.js
async function jwtVerify(jwt, key, options) {
  var _a2;
  const verified = await compactVerify(jwt, key, options);
  if (((_a2 = verified.protectedHeader.crit) == null ? void 0 : _a2.includes("b64")) && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = jwt_claims_set_default(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}

// node_modules/jose/dist/browser/runtime/sign.js
var sign = async (alg, key, data) => {
  const cryptoKey = await getCryptoKey(alg, key, "sign");
  check_key_length_default(alg, cryptoKey);
  const signature = await webcrypto_default.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
  return new Uint8Array(signature);
};
var sign_default = sign;

// node_modules/jose/dist/browser/jws/flattened/sign.js
var FlattenedSign = class {
  constructor(payload) {
    if (!(payload instanceof Uint8Array)) {
      throw new TypeError("payload must be an instance of Uint8Array");
    }
    this._payload = payload;
  }
  setProtectedHeader(protectedHeader) {
    if (this._protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this._protectedHeader = protectedHeader;
    return this;
  }
  setUnprotectedHeader(unprotectedHeader) {
    if (this._unprotectedHeader) {
      throw new TypeError("setUnprotectedHeader can only be called once");
    }
    this._unprotectedHeader = unprotectedHeader;
    return this;
  }
  async sign(key, options) {
    if (!this._protectedHeader && !this._unprotectedHeader) {
      throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
    }
    if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
      throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...this._protectedHeader,
      ...this._unprotectedHeader
    };
    const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options == null ? void 0 : options.crit, this._protectedHeader, joseHeader);
    let b64 = true;
    if (extensions.has("b64")) {
      b64 = this._protectedHeader.b64;
      if (typeof b64 !== "boolean") {
        throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
      }
    }
    const { alg } = joseHeader;
    if (typeof alg !== "string" || !alg) {
      throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    checkKeyTypeWithJwk(alg, key, "sign");
    let payload = this._payload;
    if (b64) {
      payload = encoder.encode(encode(payload));
    }
    let protectedHeader;
    if (this._protectedHeader) {
      protectedHeader = encoder.encode(encode(JSON.stringify(this._protectedHeader)));
    } else {
      protectedHeader = encoder.encode("");
    }
    const data = concat(protectedHeader, encoder.encode("."), payload);
    const signature = await sign_default(alg, key, data);
    const jws = {
      signature: encode(signature),
      payload: ""
    };
    if (b64) {
      jws.payload = decoder.decode(payload);
    }
    if (this._unprotectedHeader) {
      jws.header = this._unprotectedHeader;
    }
    if (this._protectedHeader) {
      jws.protected = decoder.decode(protectedHeader);
    }
    return jws;
  }
};

// node_modules/jose/dist/browser/jws/compact/sign.js
var CompactSign = class {
  constructor(payload) {
    this._flattened = new FlattenedSign(payload);
  }
  setProtectedHeader(protectedHeader) {
    this._flattened.setProtectedHeader(protectedHeader);
    return this;
  }
  async sign(key, options) {
    const jws = await this._flattened.sign(key, options);
    if (jws.payload === void 0) {
      throw new TypeError("use the flattened module for creating JWS with b64: false");
    }
    return `${jws.protected}.${jws.payload}.${jws.signature}`;
  }
};

// node_modules/jose/dist/browser/jwt/produce.js
function validateInput(label, input) {
  if (!Number.isFinite(input)) {
    throw new TypeError(`Invalid ${label} input`);
  }
  return input;
}
var ProduceJWT = class {
  constructor(payload = {}) {
    if (!isObject(payload)) {
      throw new TypeError("JWT Claims Set MUST be an object");
    }
    this._payload = payload;
  }
  setIssuer(issuer) {
    this._payload = { ...this._payload, iss: issuer };
    return this;
  }
  setSubject(subject) {
    this._payload = { ...this._payload, sub: subject };
    return this;
  }
  setAudience(audience) {
    this._payload = { ...this._payload, aud: audience };
    return this;
  }
  setJti(jwtId) {
    this._payload = { ...this._payload, jti: jwtId };
    return this;
  }
  setNotBefore(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, nbf: validateInput("setNotBefore", input) };
    } else if (input instanceof Date) {
      this._payload = { ...this._payload, nbf: validateInput("setNotBefore", epoch_default(input)) };
    } else {
      this._payload = { ...this._payload, nbf: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
    }
    return this;
  }
  setExpirationTime(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, exp: validateInput("setExpirationTime", input) };
    } else if (input instanceof Date) {
      this._payload = { ...this._payload, exp: validateInput("setExpirationTime", epoch_default(input)) };
    } else {
      this._payload = { ...this._payload, exp: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
    }
    return this;
  }
  setIssuedAt(input) {
    if (typeof input === "undefined") {
      this._payload = { ...this._payload, iat: epoch_default(/* @__PURE__ */ new Date()) };
    } else if (input instanceof Date) {
      this._payload = { ...this._payload, iat: validateInput("setIssuedAt", epoch_default(input)) };
    } else if (typeof input === "string") {
      this._payload = {
        ...this._payload,
        iat: validateInput("setIssuedAt", epoch_default(/* @__PURE__ */ new Date()) + secs_default(input))
      };
    } else {
      this._payload = { ...this._payload, iat: validateInput("setIssuedAt", input) };
    }
    return this;
  }
};

// node_modules/jose/dist/browser/jwt/sign.js
var SignJWT = class extends ProduceJWT {
  setProtectedHeader(protectedHeader) {
    this._protectedHeader = protectedHeader;
    return this;
  }
  async sign(key, options) {
    var _a2;
    const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
    sig.setProtectedHeader(this._protectedHeader);
    if (Array.isArray((_a2 = this._protectedHeader) == null ? void 0 : _a2.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
      throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
    }
    return sig.sign(key, options);
  }
};

// node_modules/jose/dist/browser/jwks/remote.js
var USER_AGENT;
var _a, _b;
if (typeof navigator === "undefined" || !((_b = (_a = navigator.userAgent) == null ? void 0 : _a.startsWith) == null ? void 0 : _b.call(_a, "Mozilla/5.0 "))) {
  const NAME = "jose";
  const VERSION = "v5.10.0";
  USER_AGENT = `${NAME}/${VERSION}`;
}
var jwksCache = Symbol();

// node_modules/jose/dist/browser/util/base64url.js
var base64url_exports2 = {};
__export(base64url_exports2, {
  decode: () => decode2,
  encode: () => encode2
});
var encode2 = encode;
var decode2 = decode;

// node_modules/livekit-server-sdk/dist/grants.js
function trackSourceToString(source) {
  switch (source) {
    case TrackSource.CAMERA:
      return "camera";
    case TrackSource.MICROPHONE:
      return "microphone";
    case TrackSource.SCREEN_SHARE:
      return "screen_share";
    case TrackSource.SCREEN_SHARE_AUDIO:
      return "screen_share_audio";
    default:
      throw new TypeError(`Cannot convert TrackSource ${source} to string`);
  }
}
function claimsToJwtPayload(grant) {
  var _a2;
  const claim = { ...grant };
  if (Array.isArray((_a2 = claim.video) == null ? void 0 : _a2.canPublishSources)) {
    claim.video.canPublishSources = claim.video.canPublishSources.map(trackSourceToString);
  }
  return claim;
}

// node_modules/livekit-server-sdk/dist/AccessToken.js
var defaultTTL = `6h`;
var defaultClockToleranceSeconds = 10;
var AccessToken = class {
  /**
   * Creates a new AccessToken
   * @param apiKey - API Key, can be set in env LIVEKIT_API_KEY
   * @param apiSecret - Secret, can be set in env LIVEKIT_API_SECRET
   */
  constructor(apiKey, apiSecret, options) {
    if (!apiKey) {
      apiKey = process.env.LIVEKIT_API_KEY;
    }
    if (!apiSecret) {
      apiSecret = process.env.LIVEKIT_API_SECRET;
    }
    if (!apiKey || !apiSecret) {
      throw Error("api-key and api-secret must be set");
    } else if (typeof document !== "undefined") {
      console.error(
        "You should not include your API secret in your web client bundle.\n\nYour web client should request a token from your backend server which should then use the API secret to generate a token. See https://docs.livekit.io/client/connect/"
      );
    }
    this.apiKey = apiKey;
    this.apiSecret = apiSecret;
    this.grants = {};
    this.identity = options == null ? void 0 : options.identity;
    this.ttl = (options == null ? void 0 : options.ttl) || defaultTTL;
    if (typeof this.ttl === "number") {
      this.ttl = `${this.ttl}s`;
    }
    if (options == null ? void 0 : options.metadata) {
      this.metadata = options.metadata;
    }
    if (options == null ? void 0 : options.attributes) {
      this.attributes = options.attributes;
    }
    if (options == null ? void 0 : options.name) {
      this.name = options.name;
    }
  }
  /**
   * Adds a video grant to this token.
   * @param grant -
   */
  addGrant(grant) {
    this.grants.video = { ...this.grants.video ?? {}, ...grant };
  }
  /**
   * Adds a SIP grant to this token.
   * @param grant -
   */
  addSIPGrant(grant) {
    this.grants.sip = { ...this.grants.sip ?? {}, ...grant };
  }
  get name() {
    return this.grants.name;
  }
  set name(name) {
    this.grants.name = name;
  }
  get metadata() {
    return this.grants.metadata;
  }
  /**
   * Set metadata to be passed to the Participant, used only when joining the room
   */
  set metadata(md) {
    this.grants.metadata = md;
  }
  get attributes() {
    return this.grants.attributes;
  }
  set attributes(attrs) {
    this.grants.attributes = attrs;
  }
  get kind() {
    return this.grants.kind;
  }
  set kind(kind) {
    this.grants.kind = kind;
  }
  get sha256() {
    return this.grants.sha256;
  }
  set sha256(sha) {
    this.grants.sha256 = sha;
  }
  get roomPreset() {
    return this.grants.roomPreset;
  }
  set roomPreset(preset) {
    this.grants.roomPreset = preset;
  }
  get roomConfig() {
    return this.grants.roomConfig;
  }
  set roomConfig(config) {
    this.grants.roomConfig = config;
  }
  /**
   * @returns JWT encoded token
   */
  async toJwt() {
    var _a2;
    const secret = new TextEncoder().encode(this.apiSecret);
    const jwt = new SignJWT(claimsToJwtPayload(this.grants)).setProtectedHeader({ alg: "HS256" }).setIssuer(this.apiKey).setExpirationTime(this.ttl).setNotBefore(0);
    if (this.identity) {
      jwt.setSubject(this.identity);
    } else if ((_a2 = this.grants.video) == null ? void 0 : _a2.roomJoin) {
      throw Error("identity is required for join but not set");
    }
    return jwt.sign(secret);
  }
};
var TokenVerifier = class {
  constructor(apiKey, apiSecret) {
    this.apiKey = apiKey;
    this.apiSecret = apiSecret;
  }
  async verify(token, clockTolerance = defaultClockToleranceSeconds) {
    const secret = new TextEncoder().encode(this.apiSecret);
    const { payload } = await jwtVerify(token, secret, {
      issuer: this.apiKey,
      clockTolerance
    });
    if (!payload) {
      throw Error("invalid token");
    }
    return payload;
  }
};

// node_modules/livekit-server-sdk/dist/ServiceBase.js
var ServiceBase = class {
  /**
   * @param apiKey - API Key.
   * @param secret - API Secret.
   * @param ttl - token TTL
   */
  constructor(apiKey, secret, ttl) {
    this.apiKey = apiKey;
    this.secret = secret;
    this.ttl = ttl || "10m";
  }
  async authHeader(grant, sip) {
    const at = new AccessToken(this.apiKey, this.secret, { ttl: this.ttl });
    if (grant) {
      at.addGrant(grant);
    }
    if (sip) {
      at.addSIPGrant(sip);
    }
    return {
      Authorization: `Bearer ${await at.toJwt()}`
    };
  }
};

// node_modules/livekit-server-sdk/dist/TwirpRPC.js
var defaultPrefix = "/twirp";
var livekitPackage = "livekit";
var TwirpError = class extends Error {
  constructor(name, message2, status, code) {
    super(message2);
    this.name = name;
    this.status = status;
    this.code = code;
  }
};
var TwirpRpc = class {
  constructor(host, pkg, prefix) {
    if (host.startsWith("ws")) {
      host = host.replace("ws", "http");
    }
    this.host = host;
    this.pkg = pkg;
    this.prefix = prefix || defaultPrefix;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async request(service, method, data, headers) {
    const path = `${this.prefix}/${this.pkg}.${service}/${method}`;
    const url = new URL(path, this.host);
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json;charset=UTF-8",
        ...headers
      },
      body: JSON.stringify(data)
    });
    if (!response.ok) {
      const isJson = response.headers.get("content-type") === "application/json";
      let errorMessage = "Unknown internal error";
      let errorCode = void 0;
      try {
        if (isJson) {
          const parsedError = await response.json();
          if ("msg" in parsedError) {
            errorMessage = parsedError.msg;
          }
          if ("code" in parsedError) {
            errorCode = parsedError.code;
          }
        } else {
          errorMessage = await response.text();
        }
      } catch (e) {
        console.debug(`Error when trying to parse error message, using defaults`, e);
      }
      throw new TwirpError(response.statusText, errorMessage, response.status, errorCode);
    }
    const parsedResp = await response.json();
    const camelcaseKeys = await import("./camelcase-keys-4CWFPAK5.js").then((mod) => mod.default);
    return camelcaseKeys(parsedResp, { deep: true });
  }
};

// node_modules/livekit-server-sdk/dist/AgentDispatchClient.js
var svc = "AgentDispatchService";
var AgentDispatchClient = class extends ServiceBase {
  /**
   * @param host - hostname including protocol. i.e. 'https://<project>.livekit.cloud'
   * @param apiKey - API Key, can be set in env var LIVEKIT_API_KEY
   * @param secret - API Secret, can be set in env var LIVEKIT_API_SECRET
   */
  constructor(host, apiKey, secret) {
    super(apiKey, secret);
    this.rpc = new TwirpRpc(host, livekitPackage);
  }
  /**
   * Create an explicit dispatch for an agent to join a room. To use explicit
   * dispatch, your agent must be registered with an `agentName`.
   * @param roomName - name of the room to dispatch to
   * @param agentName - name of the agent to dispatch
   * @param options - optional metadata to send along with the dispatch
   * @returns the dispatch that was created
   */
  async createDispatch(roomName, agentName, options) {
    const req = new CreateAgentDispatchRequest({
      room: roomName,
      agentName,
      metadata: options == null ? void 0 : options.metadata
    }).toJson();
    const data = await this.rpc.request(
      svc,
      "CreateDispatch",
      req,
      await this.authHeader({ roomAdmin: true, room: roomName })
    );
    return AgentDispatch.fromJson(data, { ignoreUnknownFields: true });
  }
  /**
   * Delete an explicit dispatch for an agent in a room.
   * @param dispatchId - id of the dispatch to delete
   * @param roomName - name of the room the dispatch is for
   */
  async deleteDispatch(dispatchId, roomName) {
    const req = new DeleteAgentDispatchRequest({
      dispatchId,
      room: roomName
    }).toJson();
    await this.rpc.request(
      svc,
      "DeleteDispatch",
      req,
      await this.authHeader({ roomAdmin: true, room: roomName })
    );
  }
  /**
   * Get an Agent dispatch by ID
   * @param dispatchId - id of the dispatch to get
   * @param roomName - name of the room the dispatch is for
   * @returns the dispatch that was found, or undefined if not found
   */
  async getDispatch(dispatchId, roomName) {
    const req = new ListAgentDispatchRequest({
      dispatchId,
      room: roomName
    }).toJson();
    const data = await this.rpc.request(
      svc,
      "ListDispatch",
      req,
      await this.authHeader({ roomAdmin: true, room: roomName })
    );
    const res = ListAgentDispatchResponse.fromJson(data, { ignoreUnknownFields: true });
    if (res.agentDispatches.length === 0) {
      return void 0;
    }
    return res.agentDispatches[0];
  }
  /**
   * List all agent dispatches for a room
   * @param roomName - name of the room to list dispatches for
   * @returns the list of dispatches
   */
  async listDispatch(roomName) {
    const req = new ListAgentDispatchRequest({
      room: roomName
    }).toJson();
    const data = await this.rpc.request(
      svc,
      "ListDispatch",
      req,
      await this.authHeader({ roomAdmin: true, room: roomName })
    );
    const res = ListAgentDispatchResponse.fromJson(data, { ignoreUnknownFields: true });
    return res.agentDispatches;
  }
};

// node_modules/livekit-server-sdk/dist/EgressClient.js
var svc2 = "Egress";
var EgressClient = class extends ServiceBase {
  /**
   * @param host - hostname including protocol. i.e. 'https://<project>.livekit.cloud'
   * @param apiKey - API Key, can be set in env var LIVEKIT_API_KEY
   * @param secret - API Secret, can be set in env var LIVEKIT_API_SECRET
   */
  constructor(host, apiKey, secret) {
    super(apiKey, secret);
    this.rpc = new TwirpRpc(host, livekitPackage);
  }
  async startRoomCompositeEgress(roomName, output, optsOrLayout, options, audioOnly, videoOnly, customBaseUrl) {
    let layout;
    if (optsOrLayout !== void 0) {
      if (typeof optsOrLayout === "string") {
        layout = optsOrLayout;
      } else {
        const opts = optsOrLayout;
        layout = opts.layout;
        options = opts.encodingOptions;
        audioOnly = opts.audioOnly;
        videoOnly = opts.videoOnly;
        customBaseUrl = opts.customBaseUrl;
      }
    }
    layout ?? (layout = "");
    audioOnly ?? (audioOnly = false);
    videoOnly ?? (videoOnly = false);
    customBaseUrl ?? (customBaseUrl = "");
    const {
      output: legacyOutput,
      options: egressOptions,
      fileOutputs,
      streamOutputs,
      segmentOutputs,
      imageOutputs
    } = this.getOutputParams(output, options);
    const req = new RoomCompositeEgressRequest({
      roomName,
      layout,
      audioOnly,
      videoOnly,
      customBaseUrl,
      output: legacyOutput,
      options: egressOptions,
      fileOutputs,
      streamOutputs,
      segmentOutputs,
      imageOutputs
    }).toJson();
    const data = await this.rpc.request(
      svc2,
      "StartRoomCompositeEgress",
      req,
      await this.authHeader({ roomRecord: true })
    );
    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });
  }
  /**
   * @param url - url
   * @param output - file or stream output
   * @param opts - WebOptions
   */
  async startWebEgress(url, output, opts) {
    const audioOnly = (opts == null ? void 0 : opts.audioOnly) || false;
    const videoOnly = (opts == null ? void 0 : opts.videoOnly) || false;
    const awaitStartSignal = (opts == null ? void 0 : opts.awaitStartSignal) || false;
    const {
      output: legacyOutput,
      options,
      fileOutputs,
      streamOutputs,
      segmentOutputs,
      imageOutputs
    } = this.getOutputParams(output, opts == null ? void 0 : opts.encodingOptions);
    const req = new WebEgressRequest({
      url,
      audioOnly,
      videoOnly,
      awaitStartSignal,
      output: legacyOutput,
      options,
      fileOutputs,
      streamOutputs,
      segmentOutputs,
      imageOutputs
    }).toJson();
    const data = await this.rpc.request(
      svc2,
      "StartWebEgress",
      req,
      await this.authHeader({ roomRecord: true })
    );
    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });
  }
  /**
   * Export a participant's audio and video tracks,
   *
   * @param roomName - room name
   * @param output - one or more outputs
   * @param opts - ParticipantEgressOptions
   */
  async startParticipantEgress(roomName, identity, output, opts) {
    const { options, fileOutputs, streamOutputs, segmentOutputs, imageOutputs } = this.getOutputParams(output, opts == null ? void 0 : opts.encodingOptions);
    const req = new ParticipantEgressRequest({
      roomName,
      identity,
      screenShare: (opts == null ? void 0 : opts.screenShare) ?? false,
      options,
      fileOutputs,
      streamOutputs,
      segmentOutputs,
      imageOutputs
    }).toJson();
    const data = await this.rpc.request(
      svc2,
      "StartParticipantEgress",
      req,
      await this.authHeader({ roomRecord: true })
    );
    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });
  }
  async startTrackCompositeEgress(roomName, output, optsOrAudioTrackId, videoTrackId, options) {
    let audioTrackId;
    if (optsOrAudioTrackId !== void 0) {
      if (typeof optsOrAudioTrackId === "string") {
        audioTrackId = optsOrAudioTrackId;
      } else {
        const opts = optsOrAudioTrackId;
        audioTrackId = opts.audioTrackId;
        videoTrackId = opts.videoTrackId;
        options = opts.encodingOptions;
      }
    }
    audioTrackId ?? (audioTrackId = "");
    videoTrackId ?? (videoTrackId = "");
    const {
      output: legacyOutput,
      options: egressOptions,
      fileOutputs,
      streamOutputs,
      segmentOutputs,
      imageOutputs
    } = this.getOutputParams(output, options);
    const req = new TrackCompositeEgressRequest({
      roomName,
      audioTrackId,
      videoTrackId,
      output: legacyOutput,
      options: egressOptions,
      fileOutputs,
      streamOutputs,
      segmentOutputs,
      imageOutputs
    }).toJson();
    const data = await this.rpc.request(
      svc2,
      "StartTrackCompositeEgress",
      req,
      await this.authHeader({ roomRecord: true })
    );
    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  isEncodedOutputs(output) {
    return output.file !== void 0 || output.stream !== void 0 || output.segments !== void 0 || output.images !== void 0;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  isEncodedFileOutput(output) {
    return output.filepath !== void 0 || output.fileType !== void 0;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  isSegmentedFileOutput(output) {
    return output.filenamePrefix !== void 0 || output.playlistName !== void 0 || output.filenameSuffix !== void 0;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  isStreamOutput(output) {
    return output.protocol !== void 0 || output.urls !== void 0;
  }
  getOutputParams(output, opts) {
    let file;
    let fileOutputs;
    let stream;
    let streamOutputs;
    let segments;
    let segmentOutputs;
    let imageOutputs;
    if (this.isEncodedOutputs(output)) {
      if (output.file !== void 0) {
        fileOutputs = [output.file];
      }
      if (output.stream !== void 0) {
        streamOutputs = [output.stream];
      }
      if (output.segments !== void 0) {
        segmentOutputs = [output.segments];
      }
      if (output.images !== void 0) {
        imageOutputs = [output.images];
      }
    } else if (this.isEncodedFileOutput(output)) {
      file = output;
      fileOutputs = [file];
    } else if (this.isSegmentedFileOutput(output)) {
      segments = output;
      segmentOutputs = [segments];
    } else if (this.isStreamOutput(output)) {
      stream = output;
      streamOutputs = [stream];
    }
    let legacyOutput;
    if (file) {
      legacyOutput = {
        case: "file",
        value: file
      };
    } else if (stream) {
      legacyOutput = {
        case: "stream",
        value: stream
      };
    } else if (segments) {
      legacyOutput = {
        case: "segments",
        value: segments
      };
    }
    let egressOptions;
    if (opts) {
      if (typeof opts === "number") {
        egressOptions = {
          case: "preset",
          value: opts
        };
      } else {
        egressOptions = {
          case: "advanced",
          value: opts
        };
      }
    }
    return {
      output: legacyOutput,
      options: egressOptions,
      fileOutputs,
      streamOutputs,
      segmentOutputs,
      imageOutputs
    };
  }
  /**
   * @param roomName - room name
   * @param output - file or websocket output
   * @param trackId - track Id
   */
  async startTrackEgress(roomName, output, trackId) {
    let legacyOutput;
    if (typeof output === "string") {
      legacyOutput = {
        case: "websocketUrl",
        value: output
      };
    } else {
      legacyOutput = {
        case: "file",
        value: output
      };
    }
    const req = new TrackEgressRequest({
      roomName,
      trackId,
      output: legacyOutput
    }).toJson();
    const data = await this.rpc.request(
      svc2,
      "StartTrackEgress",
      req,
      await this.authHeader({ roomRecord: true })
    );
    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });
  }
  /**
   * @param egressId -
   * @param layout -
   */
  async updateLayout(egressId, layout) {
    const data = await this.rpc.request(
      svc2,
      "UpdateLayout",
      new UpdateLayoutRequest({ egressId, layout }).toJson(),
      await this.authHeader({ roomRecord: true })
    );
    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });
  }
  /**
   * @param egressId -
   * @param addOutputUrls -
   * @param removeOutputUrls -
   */
  async updateStream(egressId, addOutputUrls, removeOutputUrls) {
    addOutputUrls ?? (addOutputUrls = []);
    removeOutputUrls ?? (removeOutputUrls = []);
    const data = await this.rpc.request(
      svc2,
      "UpdateStream",
      new UpdateStreamRequest({ egressId, addOutputUrls, removeOutputUrls }).toJson(),
      await this.authHeader({ roomRecord: true })
    );
    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });
  }
  /**
   * @param roomName - list egress for one room only
   */
  async listEgress(options) {
    let req = {};
    if (typeof options === "string") {
      req.roomName = options;
    } else if (options !== void 0) {
      req = options;
    }
    const data = await this.rpc.request(
      svc2,
      "ListEgress",
      new ListEgressRequest(req).toJson(),
      await this.authHeader({ roomRecord: true })
    );
    return ListEgressResponse.fromJson(data, { ignoreUnknownFields: true }).items ?? [];
  }
  /**
   * @param egressId -
   */
  async stopEgress(egressId) {
    const data = await this.rpc.request(
      svc2,
      "StopEgress",
      new StopEgressRequest({ egressId }).toJson(),
      await this.authHeader({ roomRecord: true })
    );
    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });
  }
};

// node_modules/livekit-server-sdk/dist/IngressClient.js
var svc3 = "Ingress";
var IngressClient = class extends ServiceBase {
  /**
   * @param host - hostname including protocol. i.e. 'https://<project>.livekit.cloud'
   * @param apiKey - API Key, can be set in env var LIVEKIT_API_KEY
   * @param secret - API Secret, can be set in env var LIVEKIT_API_SECRET
   */
  constructor(host, apiKey, secret) {
    super(apiKey, secret);
    this.rpc = new TwirpRpc(host, livekitPackage);
  }
  /**
   * @param inputType - protocol for the ingress
   * @param opts - CreateIngressOptions
   */
  async createIngress(inputType, opts) {
    let name = "";
    let participantName = "";
    let participantIdentity = "";
    let bypassTranscoding = false;
    let url = "";
    if (opts == null) {
      throw new Error("options dictionary is required");
    }
    const roomName = opts.roomName;
    const enableTranscoding = opts.enableTranscoding;
    const audio = opts.audio;
    const video = opts.video;
    const participantMetadata = opts.participantMetadata;
    name = opts.name || "";
    participantName = opts.participantName || "";
    participantIdentity = opts.participantIdentity || "";
    bypassTranscoding = opts.bypassTranscoding || false;
    url = opts.url || "";
    if (typeof roomName == "undefined") {
      throw new Error("required roomName option not provided");
    }
    if (participantIdentity == "") {
      throw new Error("required participantIdentity option not provided");
    }
    const req = new CreateIngressRequest({
      inputType,
      name,
      roomName,
      participantIdentity,
      participantMetadata,
      participantName,
      bypassTranscoding,
      enableTranscoding,
      url,
      audio,
      video
    }).toJson();
    const data = await this.rpc.request(
      svc3,
      "CreateIngress",
      req,
      await this.authHeader({ ingressAdmin: true })
    );
    return IngressInfo.fromJson(data, { ignoreUnknownFields: true });
  }
  /**
   * @param ingressId - ID of the ingress to update
   * @param opts - UpdateIngressOptions
   */
  async updateIngress(ingressId, opts) {
    const name = opts.name || "";
    const roomName = opts.roomName || "";
    const participantName = opts.participantName || "";
    const participantIdentity = opts.participantIdentity || "";
    const { participantMetadata } = opts;
    const { audio, video, bypassTranscoding, enableTranscoding } = opts;
    const req = new UpdateIngressRequest({
      ingressId,
      name,
      roomName,
      participantIdentity,
      participantName,
      participantMetadata,
      bypassTranscoding,
      enableTranscoding,
      audio,
      video
    }).toJson();
    const data = await this.rpc.request(
      svc3,
      "UpdateIngress",
      req,
      await this.authHeader({ ingressAdmin: true })
    );
    return IngressInfo.fromJson(data, { ignoreUnknownFields: true });
  }
  /**
   * @param arg - list room name or options
   */
  async listIngress(arg) {
    let req = {};
    if (typeof arg === "string") {
      req.roomName = arg;
    } else if (arg) {
      req = arg;
    }
    const data = await this.rpc.request(
      svc3,
      "ListIngress",
      new ListIngressRequest(req).toJson(),
      await this.authHeader({ ingressAdmin: true })
    );
    return ListIngressResponse.fromJson(data, { ignoreUnknownFields: true }).items ?? [];
  }
  /**
   * @param ingressId - ingress to delete
   */
  async deleteIngress(ingressId) {
    const data = await this.rpc.request(
      svc3,
      "DeleteIngress",
      new DeleteIngressRequest({ ingressId }).toJson(),
      await this.authHeader({ ingressAdmin: true })
    );
    return IngressInfo.fromJson(data, { ignoreUnknownFields: true });
  }
};

// node_modules/livekit-server-sdk/dist/crypto/uuid.js
async function getRandomBytes(size = 16) {
  if (globalThis.crypto) {
    return crypto.getRandomValues(new Uint8Array(size));
  } else {
    const nodeCrypto = await import("./node_crypto-LBWC67T6.js");
    return nodeCrypto.getRandomValues(new Uint8Array(size));
  }
}

// node_modules/livekit-server-sdk/dist/RoomServiceClient.js
var svc4 = "RoomService";
var RoomServiceClient = class extends ServiceBase {
  /**
   *
   * @param host - hostname including protocol. i.e. 'https://<project>.livekit.cloud'
   * @param apiKey - API Key, can be set in env var LIVEKIT_API_KEY
   * @param secret - API Secret, can be set in env var LIVEKIT_API_SECRET
   */
  constructor(host, apiKey, secret) {
    super(apiKey, secret);
    this.rpc = new TwirpRpc(host, livekitPackage);
  }
  /**
   * Creates a new room. Explicit room creation is not required, since rooms will
   * be automatically created when the first participant joins. This method can be
   * used to customize room settings.
   * @param options -
   */
  async createRoom(options) {
    const data = await this.rpc.request(
      svc4,
      "CreateRoom",
      new CreateRoomRequest(options).toJson(),
      await this.authHeader({ roomCreate: true })
    );
    return Room.fromJson(data, { ignoreUnknownFields: true });
  }
  /**
   * List active rooms
   * @param names - when undefined or empty, list all rooms.
   *                otherwise returns rooms with matching names
   * @returns
   */
  async listRooms(names) {
    const data = await this.rpc.request(
      svc4,
      "ListRooms",
      new ListRoomsRequest({ names: names ?? [] }).toJson(),
      await this.authHeader({ roomList: true })
    );
    const res = ListRoomsResponse.fromJson(data, { ignoreUnknownFields: true });
    return res.rooms ?? [];
  }
  async deleteRoom(room) {
    await this.rpc.request(
      svc4,
      "DeleteRoom",
      new DeleteRoomRequest({ room }).toJson(),
      await this.authHeader({ roomCreate: true })
    );
  }
  /**
   * Update metadata of a room
   * @param room - name of the room
   * @param metadata - the new metadata for the room
   */
  async updateRoomMetadata(room, metadata) {
    const data = await this.rpc.request(
      svc4,
      "UpdateRoomMetadata",
      new UpdateRoomMetadataRequest({ room, metadata }).toJson(),
      await this.authHeader({ roomAdmin: true, room })
    );
    return Room.fromJson(data, { ignoreUnknownFields: true });
  }
  /**
   * List participants in a room
   * @param room - name of the room
   */
  async listParticipants(room) {
    const data = await this.rpc.request(
      svc4,
      "ListParticipants",
      new ListParticipantsRequest({ room }).toJson(),
      await this.authHeader({ roomAdmin: true, room })
    );
    const res = ListParticipantsResponse.fromJson(data, { ignoreUnknownFields: true });
    return res.participants ?? [];
  }
  /**
   * Get information on a specific participant, including the tracks that participant
   * has published
   * @param room - name of the room
   * @param identity - identity of the participant to return
   */
  async getParticipant(room, identity) {
    const data = await this.rpc.request(
      svc4,
      "GetParticipant",
      new RoomParticipantIdentity({ room, identity }).toJson(),
      await this.authHeader({ roomAdmin: true, room })
    );
    return ParticipantInfo.fromJson(data, { ignoreUnknownFields: true });
  }
  /**
   * Removes a participant in the room. This will disconnect the participant
   * and will emit a Disconnected event for that participant.
   * Even after being removed, the participant can still re-join the room.
   * @param room -
   * @param identity -
   */
  async removeParticipant(room, identity) {
    await this.rpc.request(
      svc4,
      "RemoveParticipant",
      new RoomParticipantIdentity({ room, identity }).toJson(),
      await this.authHeader({ roomAdmin: true, room })
    );
  }
  /**
   * Forwards a participant's track to another room. This will create a
   * participant to join the destination room that has same information
   * with the source participant except the kind to be `Forwarded`. All
   * changes to the source participant will be reflected to the forwarded
   * participant. When the source participant disconnects or the
   * `RemoveParticipant` method is called in the destination room, the
   * forwarding will be stopped.
   */
  async forwardParticipant(room, identity, destinationRoom) {
    await this.rpc.request(
      svc4,
      "ForwardParticipant",
      new ForwardParticipantRequest({ room, identity, destinationRoom }).toJson(),
      await this.authHeader({ roomAdmin: true, room, destinationRoom })
    );
  }
  /**
   * Mutes a track that the participant has published.
   * @param room -
   * @param identity -
   * @param trackSid - sid of the track to be muted
   * @param muted - true to mute, false to unmute
   */
  async mutePublishedTrack(room, identity, trackSid, muted) {
    const req = new MuteRoomTrackRequest({
      room,
      identity,
      trackSid,
      muted
    }).toJson();
    const data = await this.rpc.request(
      svc4,
      "MutePublishedTrack",
      req,
      await this.authHeader({ roomAdmin: true, room })
    );
    const res = MuteRoomTrackResponse.fromJson(data, { ignoreUnknownFields: true });
    return res.track;
  }
  async updateParticipant(room, identity, metadataOrOptions, maybePermission, maybeName) {
    const hasOptions = typeof metadataOrOptions === "object";
    const metadata = hasOptions ? metadataOrOptions == null ? void 0 : metadataOrOptions.metadata : metadataOrOptions;
    const permission = hasOptions ? metadataOrOptions.permission : maybePermission;
    const name = hasOptions ? metadataOrOptions.name : maybeName;
    const attributes = hasOptions ? metadataOrOptions.attributes : {};
    const req = new UpdateParticipantRequest({
      room,
      identity,
      attributes,
      metadata,
      name
    });
    if (permission) {
      req.permission = new ParticipantPermission(permission);
    }
    const data = await this.rpc.request(
      svc4,
      "UpdateParticipant",
      req.toJson(),
      await this.authHeader({ roomAdmin: true, room })
    );
    return ParticipantInfo.fromJson(data, { ignoreUnknownFields: true });
  }
  /**
   * Updates a participant's subscription to tracks
   * @param room -
   * @param identity -
   * @param trackSids -
   * @param subscribe - true to subscribe, false to unsubscribe
   */
  async updateSubscriptions(room, identity, trackSids, subscribe) {
    const req = new UpdateSubscriptionsRequest({
      room,
      identity,
      trackSids,
      subscribe,
      participantTracks: []
    }).toJson();
    await this.rpc.request(
      svc4,
      "UpdateSubscriptions",
      req,
      await this.authHeader({ roomAdmin: true, room })
    );
  }
  async sendData(room, data, kind, options = {}) {
    const destinationSids = Array.isArray(options) ? options : options.destinationSids;
    const topic = Array.isArray(options) ? void 0 : options.topic;
    const req = new SendDataRequest({
      room,
      data,
      kind,
      destinationSids: destinationSids ?? [],
      topic
    });
    if (!Array.isArray(options) && options.destinationIdentities) {
      req.destinationIdentities = options.destinationIdentities;
    }
    req.nonce = await getRandomBytes(16);
    await this.rpc.request(
      svc4,
      "SendData",
      req.toJson(),
      await this.authHeader({ roomAdmin: true, room })
    );
  }
};

// node_modules/livekit-server-sdk/dist/SipClient.js
var svc5 = "SIP";
var SipClient = class extends ServiceBase {
  /**
   * @param host - hostname including protocol. i.e. 'https://<project>.livekit.cloud'
   * @param apiKey - API Key, can be set in env var LIVEKIT_API_KEY
   * @param secret - API Secret, can be set in env var LIVEKIT_API_SECRET
   */
  constructor(host, apiKey, secret) {
    super(apiKey, secret);
    this.rpc = new TwirpRpc(host, livekitPackage);
  }
  /**
   * @param number - phone number of the trunk
   * @param opts - CreateSipTrunkOptions
   * @deprecated use `createSipInboundTrunk` or `createSipOutboundTrunk`
   */
  async createSipTrunk(number, opts) {
    let inboundAddresses;
    let inboundNumbers;
    let inboundUsername = "";
    let inboundPassword = "";
    let outboundAddress = "";
    let outboundUsername = "";
    let outboundPassword = "";
    let name = "";
    let metadata = "";
    if (opts !== void 0) {
      inboundAddresses = opts.inbound_addresses;
      inboundNumbers = opts.inbound_numbers;
      inboundUsername = opts.inbound_username || "";
      inboundPassword = opts.inbound_password || "";
      outboundAddress = opts.outbound_address || "";
      outboundUsername = opts.outbound_username || "";
      outboundPassword = opts.outbound_password || "";
      name = opts.name || "";
      metadata = opts.metadata || "";
    }
    const req = new CreateSIPTrunkRequest({
      name,
      metadata,
      inboundAddresses,
      inboundNumbers,
      inboundUsername,
      inboundPassword,
      outboundNumber: number,
      outboundAddress,
      outboundUsername,
      outboundPassword
    }).toJson();
    const data = await this.rpc.request(
      svc5,
      "CreateSIPTrunk",
      req,
      await this.authHeader({}, { admin: true })
    );
    return SIPTrunkInfo.fromJson(data, { ignoreUnknownFields: true });
  }
  /**
   * @param name - human-readable name of the trunk
   * @param numbers - phone numbers of the trunk
   * @param opts - CreateSipTrunkOptions
   */
  async createSipInboundTrunk(name, numbers, opts) {
    if (opts === void 0) {
      opts = {};
    }
    const req = new CreateSIPInboundTrunkRequest({
      trunk: new SIPInboundTrunkInfo({
        name,
        numbers,
        metadata: opts == null ? void 0 : opts.metadata,
        allowedAddresses: opts.allowedAddresses ?? opts.allowed_addresses,
        allowedNumbers: opts.allowedNumbers ?? opts.allowed_numbers,
        authUsername: opts.authUsername ?? opts.auth_username,
        authPassword: opts.authPassword ?? opts.auth_password,
        headers: opts.headers,
        headersToAttributes: opts.headersToAttributes,
        includeHeaders: opts.includeHeaders,
        krispEnabled: opts.krispEnabled
      })
    }).toJson();
    const data = await this.rpc.request(
      svc5,
      "CreateSIPInboundTrunk",
      req,
      await this.authHeader({}, { admin: true })
    );
    return SIPInboundTrunkInfo.fromJson(data, { ignoreUnknownFields: true });
  }
  /**
   * @param name - human-readable name of the trunk
   * @param address - hostname and port of the SIP server to dial
   * @param numbers - phone numbers of the trunk
   * @param opts - CreateSipTrunkOptions
   */
  async createSipOutboundTrunk(name, address, numbers, opts) {
    if (opts === void 0) {
      opts = {
        transport: SIPTransport.SIP_TRANSPORT_AUTO
      };
    }
    const req = new CreateSIPOutboundTrunkRequest({
      trunk: new SIPOutboundTrunkInfo({
        name,
        address,
        numbers,
        metadata: opts.metadata,
        transport: opts.transport,
        authUsername: opts.authUsername ?? opts.auth_username,
        authPassword: opts.authPassword ?? opts.auth_password,
        headers: opts.headers,
        headersToAttributes: opts.headersToAttributes,
        includeHeaders: opts.includeHeaders
      })
    }).toJson();
    const data = await this.rpc.request(
      svc5,
      "CreateSIPOutboundTrunk",
      req,
      await this.authHeader({}, { admin: true })
    );
    return SIPOutboundTrunkInfo.fromJson(data, { ignoreUnknownFields: true });
  }
  /**
   * @deprecated use `listSipInboundTrunk` or `listSipOutboundTrunk`
   */
  async listSipTrunk() {
    const req = {};
    const data = await this.rpc.request(
      svc5,
      "ListSIPTrunk",
      new ListSIPTrunkRequest(req).toJson(),
      await this.authHeader({}, { admin: true })
    );
    return ListSIPTrunkResponse.fromJson(data, { ignoreUnknownFields: true }).items ?? [];
  }
  async listSipInboundTrunk() {
    const req = {};
    const data = await this.rpc.request(
      svc5,
      "ListSIPInboundTrunk",
      new ListSIPInboundTrunkRequest(req).toJson(),
      await this.authHeader({}, { admin: true })
    );
    return ListSIPInboundTrunkResponse.fromJson(data, { ignoreUnknownFields: true }).items ?? [];
  }
  async listSipOutboundTrunk() {
    const req = {};
    const data = await this.rpc.request(
      svc5,
      "ListSIPOutboundTrunk",
      new ListSIPOutboundTrunkRequest(req).toJson(),
      await this.authHeader({}, { admin: true })
    );
    return ListSIPOutboundTrunkResponse.fromJson(data, { ignoreUnknownFields: true }).items ?? [];
  }
  /**
   * @param sipTrunkId - sip trunk to delete
   */
  async deleteSipTrunk(sipTrunkId) {
    const data = await this.rpc.request(
      svc5,
      "DeleteSIPTrunk",
      new DeleteSIPTrunkRequest({ sipTrunkId }).toJson(),
      await this.authHeader({}, { admin: true })
    );
    return SIPTrunkInfo.fromJson(data, { ignoreUnknownFields: true });
  }
  /**
   * @param rule - sip dispatch rule
   * @param opts - CreateSipDispatchRuleOptions
   */
  async createSipDispatchRule(rule, opts) {
    if (opts === void 0) {
      opts = {};
    }
    let ruleProto = void 0;
    if (rule.type == "direct") {
      ruleProto = new SIPDispatchRule({
        rule: {
          case: "dispatchRuleDirect",
          value: new SIPDispatchRuleDirect({
            roomName: rule.roomName,
            pin: rule.pin || ""
          })
        }
      });
    } else if (rule.type == "individual") {
      ruleProto = new SIPDispatchRule({
        rule: {
          case: "dispatchRuleIndividual",
          value: new SIPDispatchRuleIndividual({
            roomPrefix: rule.roomPrefix,
            pin: rule.pin || ""
          })
        }
      });
    }
    const req = new CreateSIPDispatchRuleRequest({
      rule: ruleProto,
      trunkIds: opts.trunkIds,
      hidePhoneNumber: opts.hidePhoneNumber,
      name: opts.name,
      metadata: opts.metadata,
      attributes: opts.attributes,
      roomPreset: opts.roomPreset,
      roomConfig: opts.roomConfig
    }).toJson();
    const data = await this.rpc.request(
      svc5,
      "CreateSIPDispatchRule",
      req,
      await this.authHeader({}, { admin: true })
    );
    return SIPDispatchRuleInfo.fromJson(data, { ignoreUnknownFields: true });
  }
  async listSipDispatchRule() {
    const req = {};
    const data = await this.rpc.request(
      svc5,
      "ListSIPDispatchRule",
      new ListSIPDispatchRuleRequest(req).toJson(),
      await this.authHeader({}, { admin: true })
    );
    return ListSIPDispatchRuleResponse.fromJson(data, { ignoreUnknownFields: true }).items ?? [];
  }
  /**
   * @param sipDispatchRuleId - sip trunk to delete
   */
  async deleteSipDispatchRule(sipDispatchRuleId) {
    const data = await this.rpc.request(
      svc5,
      "DeleteSIPDispatchRule",
      new DeleteSIPDispatchRuleRequest({ sipDispatchRuleId }).toJson(),
      await this.authHeader({}, { admin: true })
    );
    return SIPDispatchRuleInfo.fromJson(data, { ignoreUnknownFields: true });
  }
  /**
   * @param sipTrunkId - sip trunk to use for the call
   * @param number - number to dial
   * @param roomName - room to attach the call to
   * @param opts - CreateSipParticipantOptions
   */
  async createSipParticipant(sipTrunkId, number, roomName, opts) {
    if (opts === void 0) {
      opts = {};
    }
    const req = new CreateSIPParticipantRequest({
      sipTrunkId,
      sipCallTo: number,
      sipNumber: opts.fromNumber,
      roomName,
      participantIdentity: opts.participantIdentity || "sip-participant",
      participantName: opts.participantName,
      participantMetadata: opts.participantMetadata,
      participantAttributes: opts.participantAttributes,
      dtmf: opts.dtmf,
      playDialtone: opts.playDialtone ?? opts.playRingtone,
      headers: opts.headers,
      hidePhoneNumber: opts.hidePhoneNumber,
      includeHeaders: opts.includeHeaders,
      ringingTimeout: opts.ringingTimeout ? new Duration({ seconds: BigInt(opts.ringingTimeout) }) : void 0,
      maxCallDuration: opts.maxCallDuration ? new Duration({ seconds: BigInt(opts.maxCallDuration) }) : void 0,
      krispEnabled: opts.krispEnabled
    }).toJson();
    const data = await this.rpc.request(
      svc5,
      "CreateSIPParticipant",
      req,
      await this.authHeader({}, { call: true })
    );
    return SIPParticipantInfo.fromJson(data, { ignoreUnknownFields: true });
  }
  /**
   * @param roomName - room the SIP participant to transfer is connectd to
   * @param participantIdentity - identity of the SIP participant to transfer
   * @param transferTo - SIP URL to transfer the participant to
   */
  async transferSipParticipant(roomName, participantIdentity, transferTo, opts) {
    if (opts === void 0) {
      opts = {};
    }
    const req = new TransferSIPParticipantRequest({
      participantIdentity,
      roomName,
      transferTo,
      playDialtone: opts.playDialtone,
      headers: opts.headers
    }).toJson();
    await this.rpc.request(
      svc5,
      "TransferSIPParticipant",
      req,
      await this.authHeader({ roomAdmin: true, room: roomName }, { call: true })
    );
  }
};

// node_modules/livekit-server-sdk/dist/crypto/digest.js
async function digest(data) {
  var _a2;
  if ((_a2 = globalThis.crypto) == null ? void 0 : _a2.subtle) {
    const encoder2 = new TextEncoder();
    return crypto.subtle.digest("SHA-256", encoder2.encode(data));
  } else {
    const nodeCrypto = await import("./node_crypto-LBWC67T6.js");
    return nodeCrypto.createHash("sha256").update(data).digest();
  }
}

// node_modules/livekit-server-sdk/dist/WebhookReceiver.js
var authorizeHeader = "Authorize";
var WebhookEvent2 = class _WebhookEvent extends WebhookEvent {
  constructor() {
    super(...arguments);
    this.event = "";
  }
  static fromBinary(bytes, options) {
    return new _WebhookEvent().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _WebhookEvent().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _WebhookEvent().fromJsonString(jsonString, options);
  }
};
var WebhookReceiver = class {
  constructor(apiKey, apiSecret) {
    this.verifier = new TokenVerifier(apiKey, apiSecret);
  }
  /**
   * @param body - string of the posted body
   * @param authHeader - `Authorization` header from the request
   * @param skipAuth - true to skip auth validation
   * @param clockTolerance - How much tolerance to allow for checks against the auth header to be skewed from the claims
   * @returns The processed webhook event
   */
  async receive(body, authHeader, skipAuth = false, clockTolerance) {
    if (!skipAuth) {
      if (!authHeader) {
        throw new Error("authorization header is empty");
      }
      const claims = await this.verifier.verify(authHeader, clockTolerance);
      const hash = await digest(body);
      const hashDecoded = btoa(
        Array.from(new Uint8Array(hash)).map((v) => String.fromCharCode(v)).join("")
      );
      if (claims.sha256 !== hashDecoded) {
        throw new Error("sha256 checksum of body does not match");
      }
    }
    return WebhookEvent2.fromJson(JSON.parse(body), { ignoreUnknownFields: true });
  }
};
export {
  AccessToken,
  AgentDispatchClient,
  AliOSSUpload,
  AudioCodec,
  AutoParticipantEgress,
  AutoTrackEgress,
  AzureBlobUpload,
  DataPacket_Kind,
  DirectFileOutput,
  EgressClient,
  EgressInfo,
  EgressStatus,
  EncodedFileOutput,
  EncodedFileType,
  EncodingOptions,
  EncodingOptionsPreset,
  GCPUpload,
  ImageCodec,
  ImageFileSuffix,
  ImageOutput,
  IngressAudioEncodingOptions,
  IngressAudioEncodingPreset,
  IngressAudioOptions,
  IngressClient,
  IngressInfo,
  IngressInput,
  IngressState,
  IngressVideoEncodingOptions,
  IngressVideoEncodingPreset,
  IngressVideoOptions,
  ParticipantEgressRequest,
  ParticipantInfo,
  ParticipantInfo_State,
  ParticipantPermission,
  Room,
  RoomCompositeEgressRequest,
  RoomEgress,
  RoomServiceClient,
  S3Upload,
  SIPDispatchRuleInfo,
  SIPParticipantInfo,
  SIPTrunkInfo,
  SegmentedFileOutput,
  SegmentedFileProtocol,
  SipClient,
  StreamOutput,
  StreamProtocol,
  TokenVerifier,
  TrackCompositeEgressRequest,
  TrackEgressRequest,
  TrackInfo,
  TrackSource,
  TrackType,
  VideoCodec,
  WebEgressRequest,
  WebhookEvent2 as WebhookEvent,
  WebhookReceiver,
  authorizeHeader,
  claimsToJwtPayload,
  trackSourceToString
};
//# sourceMappingURL=livekit-server-sdk.js.map
